<?php
/**
 * OperationsApi
 * PHP version 7.2
 *
 * @category Class
 * @package  Bzzhh\Tzkt
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * TzKT API
 *
 * # Introduction  TzKT Explorer provides a free REST-like API and WebSocket API for accessing detailed Tezos blockchain data and helps developers build more services and applications on top of Tezos. TzKT is an open-source project, so you can easily clone and build it and use it as a self-hosted service to avoid any risks depending on third-party services.  TzKT API is available for the following Tezos networks with the following base URLs:  - Mainnet: `https://api.tzkt.io/` or `https://api.mainnet.tzkt.io/` ([view docs](https://api.tzkt.io)) - Edo2net: `https://api.edo2net.tzkt.io/` ([view docs](https://api.edo2net.tzkt.io)) - Florencenet: `https://api.florencenet.tzkt.io/` ([view docs](https://api.florencenet.tzkt.io))  We also provide a staging environment for testing newest features and pre-updating client applications before deploying to production:  - Mainnet staging: `https://staging.api.tzkt.io/` or `https://staging.api.mainnet.tzkt.io/` ([view docs](https://staging.api.tzkt.io)) - Edo2net staging: `https://staging.api.edo2net.tzkt.io/` ([view docs](https://staging.api.edo2net.tzkt.io))      Feel free to contact us if you have any questions or feature requests. Your feedback really helps us make TzKT better!  - Email: hello@baking-bad.org - Twitter: https://twitter.com/TezosBakingBad - Telegram: [tg://resolve?domain=baking_bad_chat](tg://resolve?domain=baking_bad_chat) - Slack: https://tezos-dev.slack.com/archives/CV5NX7F2L  And don't forget to star TzKT project [on GitHub](https://github.com/baking-bad/tzkt) ;)  # Terms of Use  TzKT API is free for everyone and for both commercial and non-commercial usage.  If your application or service uses the TzKT API in any forms: directly on frontend or indirectly on backend, you should mention that fact on your website or application by placing the label **\"Powered by TzKT API\"** with a direct link to [tzkt.io](https://tzkt.io).   # Rate Limits  There will be no rate limits as long as our servers can handle the load without additional infrastructure costs. However, any apparent abuse will be prevented by setting targeted rate limits.  Check out [Tezos Explorer API Best Practices](https://baking-bad.org/blog/tag/TzKT/) and in particular [how to optimize requests count](https://baking-bad.org/blog/2020/07/29/tezos-explorer-api-tzkt-how-often-to-make-requests/).  ---
 *
 * The version of the OpenAPI document: v1.5
 * Contact: hello@baking-bad.org
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.2.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Bzzhh\Tzkt\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Bzzhh\Tzkt\ApiException;
use Bzzhh\Tzkt\Configuration;
use Bzzhh\Tzkt\HeaderSelector;
use Bzzhh\Tzkt\ObjectSerializer;

/**
 * OperationsApi Class Doc Comment
 *
 * @category Class
 * @package  Bzzhh\Tzkt
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class OperationsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation operationsGetActivationByHash
     *
     * Get activation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\ActivationOperation[]
     */
    public function operationsGetActivationByHash($hash, $quote = null)
    {
        list($response) = $this->operationsGetActivationByHashWithHttpInfo($hash, $quote);
        return $response;
    }

    /**
     * Operation operationsGetActivationByHashWithHttpInfo
     *
     * Get activation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\ActivationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetActivationByHashWithHttpInfo($hash, $quote = null)
    {
        $request = $this->operationsGetActivationByHashRequest($hash, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\ActivationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\ActivationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\ActivationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\ActivationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetActivationByHashAsync
     *
     * Get activation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetActivationByHashAsync($hash, $quote = null)
    {
        return $this->operationsGetActivationByHashAsyncWithHttpInfo($hash, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetActivationByHashAsyncWithHttpInfo
     *
     * Get activation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetActivationByHashAsyncWithHttpInfo($hash, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\ActivationOperation[]';
        $request = $this->operationsGetActivationByHashRequest($hash, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetActivationByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetActivationByHashRequest($hash, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetActivationByHash'
            );
        }

        $resourcePath = '/v1/operations/activations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetActivations
     *
     * Get activations
     *
     * @param  OneOfAccountParameter $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters activations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters activations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\ActivationOperation[]
     */
    public function operationsGetActivations($account = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        list($response) = $this->operationsGetActivationsWithHttpInfo($account, $level, $timestamp, $select, $sort, $offset, $limit, $quote);
        return $response;
    }

    /**
     * Operation operationsGetActivationsWithHttpInfo
     *
     * Get activations
     *
     * @param  OneOfAccountParameter $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters activations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters activations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\ActivationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetActivationsWithHttpInfo($account = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $request = $this->operationsGetActivationsRequest($account, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\ActivationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\ActivationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\ActivationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\ActivationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetActivationsAsync
     *
     * Get activations
     *
     * @param  OneOfAccountParameter $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters activations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters activations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetActivationsAsync($account = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        return $this->operationsGetActivationsAsyncWithHttpInfo($account, $level, $timestamp, $select, $sort, $offset, $limit, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetActivationsAsyncWithHttpInfo
     *
     * Get activations
     *
     * @param  OneOfAccountParameter $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters activations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters activations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetActivationsAsyncWithHttpInfo($account = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\ActivationOperation[]';
        $request = $this->operationsGetActivationsRequest($account, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetActivations'
     *
     * @param  OneOfAccountParameter $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters activations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters activations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetActivationsRequest($account = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetActivations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetActivations, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v1/operations/activations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($account !== null) {
            if('form' === 'form' && is_array($account)) {
                foreach($account as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['account'] = $account;
            }
        }
        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($select !== null) {
            if('form' === 'form' && is_array($select)) {
                foreach($select as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['select'] = $select;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetActivationsCount
     *
     * Get activations count
     *
     * @param  OneOfInt32Parameter $level Filters activations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters activations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetActivationsCount($level = null, $timestamp = null)
    {
        list($response) = $this->operationsGetActivationsCountWithHttpInfo($level, $timestamp);
        return $response;
    }

    /**
     * Operation operationsGetActivationsCountWithHttpInfo
     *
     * Get activations count
     *
     * @param  OneOfInt32Parameter $level Filters activations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters activations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetActivationsCountWithHttpInfo($level = null, $timestamp = null)
    {
        $request = $this->operationsGetActivationsCountRequest($level, $timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetActivationsCountAsync
     *
     * Get activations count
     *
     * @param  OneOfInt32Parameter $level Filters activations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters activations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetActivationsCountAsync($level = null, $timestamp = null)
    {
        return $this->operationsGetActivationsCountAsyncWithHttpInfo($level, $timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetActivationsCountAsyncWithHttpInfo
     *
     * Get activations count
     *
     * @param  OneOfInt32Parameter $level Filters activations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters activations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetActivationsCountAsyncWithHttpInfo($level = null, $timestamp = null)
    {
        $returnType = 'int';
        $request = $this->operationsGetActivationsCountRequest($level, $timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetActivationsCount'
     *
     * @param  OneOfInt32Parameter $level Filters activations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters activations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetActivationsCountRequest($level = null, $timestamp = null)
    {

        $resourcePath = '/v1/operations/activations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBaking
     *
     * Get baking
     *
     * @param  OneOfAccountParameter $baker Filters baking operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\BakingOperation[]
     */
    public function operationsGetBaking($baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        list($response) = $this->operationsGetBakingWithHttpInfo($baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote);
        return $response;
    }

    /**
     * Operation operationsGetBakingWithHttpInfo
     *
     * Get baking
     *
     * @param  OneOfAccountParameter $baker Filters baking operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\BakingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBakingWithHttpInfo($baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $request = $this->operationsGetBakingRequest($baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\BakingOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\BakingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\BakingOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\BakingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBakingAsync
     *
     * Get baking
     *
     * @param  OneOfAccountParameter $baker Filters baking operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBakingAsync($baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        return $this->operationsGetBakingAsyncWithHttpInfo($baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBakingAsyncWithHttpInfo
     *
     * Get baking
     *
     * @param  OneOfAccountParameter $baker Filters baking operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBakingAsyncWithHttpInfo($baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\BakingOperation[]';
        $request = $this->operationsGetBakingRequest($baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBaking'
     *
     * @param  OneOfAccountParameter $baker Filters baking operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBakingRequest($baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetBaking, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetBaking, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v1/operations/baking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($baker !== null) {
            if('form' === 'form' && is_array($baker)) {
                foreach($baker as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['baker'] = $baker;
            }
        }
        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($select !== null) {
            if('form' === 'form' && is_array($select)) {
                foreach($select as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['select'] = $select;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBakingCount
     *
     * Get baking count
     *
     * @param  OneOfInt32Parameter $level Filters baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters baking operations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetBakingCount($level = null, $timestamp = null)
    {
        list($response) = $this->operationsGetBakingCountWithHttpInfo($level, $timestamp);
        return $response;
    }

    /**
     * Operation operationsGetBakingCountWithHttpInfo
     *
     * Get baking count
     *
     * @param  OneOfInt32Parameter $level Filters baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters baking operations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBakingCountWithHttpInfo($level = null, $timestamp = null)
    {
        $request = $this->operationsGetBakingCountRequest($level, $timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBakingCountAsync
     *
     * Get baking count
     *
     * @param  OneOfInt32Parameter $level Filters baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters baking operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBakingCountAsync($level = null, $timestamp = null)
    {
        return $this->operationsGetBakingCountAsyncWithHttpInfo($level, $timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBakingCountAsyncWithHttpInfo
     *
     * Get baking count
     *
     * @param  OneOfInt32Parameter $level Filters baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters baking operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBakingCountAsyncWithHttpInfo($level = null, $timestamp = null)
    {
        $returnType = 'int';
        $request = $this->operationsGetBakingCountRequest($level, $timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBakingCount'
     *
     * @param  OneOfInt32Parameter $level Filters baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters baking operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBakingCountRequest($level = null, $timestamp = null)
    {

        $resourcePath = '/v1/operations/baking/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBallotByHash
     *
     * Get ballot by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\BallotOperation[]
     */
    public function operationsGetBallotByHash($hash, $quote = null)
    {
        list($response) = $this->operationsGetBallotByHashWithHttpInfo($hash, $quote);
        return $response;
    }

    /**
     * Operation operationsGetBallotByHashWithHttpInfo
     *
     * Get ballot by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\BallotOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBallotByHashWithHttpInfo($hash, $quote = null)
    {
        $request = $this->operationsGetBallotByHashRequest($hash, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\BallotOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\BallotOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\BallotOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\BallotOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBallotByHashAsync
     *
     * Get ballot by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBallotByHashAsync($hash, $quote = null)
    {
        return $this->operationsGetBallotByHashAsyncWithHttpInfo($hash, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBallotByHashAsyncWithHttpInfo
     *
     * Get ballot by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBallotByHashAsyncWithHttpInfo($hash, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\BallotOperation[]';
        $request = $this->operationsGetBallotByHashRequest($hash, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBallotByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBallotByHashRequest($hash, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetBallotByHash'
            );
        }

        $resourcePath = '/v1/operations/ballots/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBallots
     *
     * Get ballots
     *
     * @param  OneOfAccountParameter $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters ballots by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters ballots by timestamp. (optional)
     * @param  OneOfInt32Parameter $epoch Filters ballots by voting epoch. (optional)
     * @param  OneOfInt32Parameter $period Filters ballots by voting period. (optional)
     * @param  OneOfProtocolParameter $proposal Filters ballots by proposal hash. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\BallotOperation[]
     */
    public function operationsGetBallots($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        list($response) = $this->operationsGetBallotsWithHttpInfo($delegate, $level, $timestamp, $epoch, $period, $proposal, $select, $sort, $offset, $limit, $quote);
        return $response;
    }

    /**
     * Operation operationsGetBallotsWithHttpInfo
     *
     * Get ballots
     *
     * @param  OneOfAccountParameter $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters ballots by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters ballots by timestamp. (optional)
     * @param  OneOfInt32Parameter $epoch Filters ballots by voting epoch. (optional)
     * @param  OneOfInt32Parameter $period Filters ballots by voting period. (optional)
     * @param  OneOfProtocolParameter $proposal Filters ballots by proposal hash. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\BallotOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBallotsWithHttpInfo($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $request = $this->operationsGetBallotsRequest($delegate, $level, $timestamp, $epoch, $period, $proposal, $select, $sort, $offset, $limit, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\BallotOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\BallotOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\BallotOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\BallotOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBallotsAsync
     *
     * Get ballots
     *
     * @param  OneOfAccountParameter $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters ballots by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters ballots by timestamp. (optional)
     * @param  OneOfInt32Parameter $epoch Filters ballots by voting epoch. (optional)
     * @param  OneOfInt32Parameter $period Filters ballots by voting period. (optional)
     * @param  OneOfProtocolParameter $proposal Filters ballots by proposal hash. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBallotsAsync($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        return $this->operationsGetBallotsAsyncWithHttpInfo($delegate, $level, $timestamp, $epoch, $period, $proposal, $select, $sort, $offset, $limit, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBallotsAsyncWithHttpInfo
     *
     * Get ballots
     *
     * @param  OneOfAccountParameter $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters ballots by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters ballots by timestamp. (optional)
     * @param  OneOfInt32Parameter $epoch Filters ballots by voting epoch. (optional)
     * @param  OneOfInt32Parameter $period Filters ballots by voting period. (optional)
     * @param  OneOfProtocolParameter $proposal Filters ballots by proposal hash. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBallotsAsyncWithHttpInfo($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\BallotOperation[]';
        $request = $this->operationsGetBallotsRequest($delegate, $level, $timestamp, $epoch, $period, $proposal, $select, $sort, $offset, $limit, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBallots'
     *
     * @param  OneOfAccountParameter $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters ballots by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters ballots by timestamp. (optional)
     * @param  OneOfInt32Parameter $epoch Filters ballots by voting epoch. (optional)
     * @param  OneOfInt32Parameter $period Filters ballots by voting period. (optional)
     * @param  OneOfProtocolParameter $proposal Filters ballots by proposal hash. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBallotsRequest($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetBallots, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetBallots, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v1/operations/ballots';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($delegate !== null) {
            if('form' === 'form' && is_array($delegate)) {
                foreach($delegate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['delegate'] = $delegate;
            }
        }
        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($epoch !== null) {
            if('form' === 'form' && is_array($epoch)) {
                foreach($epoch as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['epoch'] = $epoch;
            }
        }
        // query params
        if ($period !== null) {
            if('form' === 'form' && is_array($period)) {
                foreach($period as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['period'] = $period;
            }
        }
        // query params
        if ($proposal !== null) {
            if('form' === 'form' && is_array($proposal)) {
                foreach($proposal as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['proposal'] = $proposal;
            }
        }
        // query params
        if ($select !== null) {
            if('form' === 'form' && is_array($select)) {
                foreach($select as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['select'] = $select;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBallotsCount
     *
     * Get ballots count
     *
     * @param  OneOfInt32Parameter $level Filters ballot operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters ballot operations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetBallotsCount($level = null, $timestamp = null)
    {
        list($response) = $this->operationsGetBallotsCountWithHttpInfo($level, $timestamp);
        return $response;
    }

    /**
     * Operation operationsGetBallotsCountWithHttpInfo
     *
     * Get ballots count
     *
     * @param  OneOfInt32Parameter $level Filters ballot operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters ballot operations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBallotsCountWithHttpInfo($level = null, $timestamp = null)
    {
        $request = $this->operationsGetBallotsCountRequest($level, $timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBallotsCountAsync
     *
     * Get ballots count
     *
     * @param  OneOfInt32Parameter $level Filters ballot operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters ballot operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBallotsCountAsync($level = null, $timestamp = null)
    {
        return $this->operationsGetBallotsCountAsyncWithHttpInfo($level, $timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBallotsCountAsyncWithHttpInfo
     *
     * Get ballots count
     *
     * @param  OneOfInt32Parameter $level Filters ballot operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters ballot operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBallotsCountAsyncWithHttpInfo($level = null, $timestamp = null)
    {
        $returnType = 'int';
        $request = $this->operationsGetBallotsCountRequest($level, $timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBallotsCount'
     *
     * @param  OneOfInt32Parameter $level Filters ballot operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters ballot operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBallotsCountRequest($level = null, $timestamp = null)
    {

        $resourcePath = '/v1/operations/ballots/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetByHash
     *
     * Get operations by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\Operation[]
     */
    public function operationsGetByHash($hash, $micheline = null, $quote = null)
    {
        list($response) = $this->operationsGetByHashWithHttpInfo($hash, $micheline, $quote);
        return $response;
    }

    /**
     * Operation operationsGetByHashWithHttpInfo
     *
     * Get operations by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\Operation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetByHashWithHttpInfo($hash, $micheline = null, $quote = null)
    {
        $request = $this->operationsGetByHashRequest($hash, $micheline, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\Operation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\Operation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\Operation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\Operation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetByHashAsync
     *
     * Get operations by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetByHashAsync($hash, $micheline = null, $quote = null)
    {
        return $this->operationsGetByHashAsyncWithHttpInfo($hash, $micheline, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetByHashAsyncWithHttpInfo
     *
     * Get operations by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetByHashAsyncWithHttpInfo($hash, $micheline = null, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\Operation[]';
        $request = $this->operationsGetByHashRequest($hash, $micheline, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetByHashRequest($hash, $micheline = null, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetByHash'
            );
        }

        $resourcePath = '/v1/operations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($micheline !== null) {
            if('form' === 'form' && is_array($micheline)) {
                foreach($micheline as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['micheline'] = $micheline;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetByHashCounter
     *
     * Get operations by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\Operation[]
     */
    public function operationsGetByHashCounter($hash, $counter, $micheline = null, $quote = null)
    {
        list($response) = $this->operationsGetByHashCounterWithHttpInfo($hash, $counter, $micheline, $quote);
        return $response;
    }

    /**
     * Operation operationsGetByHashCounterWithHttpInfo
     *
     * Get operations by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\Operation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetByHashCounterWithHttpInfo($hash, $counter, $micheline = null, $quote = null)
    {
        $request = $this->operationsGetByHashCounterRequest($hash, $counter, $micheline, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\Operation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\Operation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\Operation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\Operation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetByHashCounterAsync
     *
     * Get operations by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetByHashCounterAsync($hash, $counter, $micheline = null, $quote = null)
    {
        return $this->operationsGetByHashCounterAsyncWithHttpInfo($hash, $counter, $micheline, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetByHashCounterAsyncWithHttpInfo
     *
     * Get operations by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetByHashCounterAsyncWithHttpInfo($hash, $counter, $micheline = null, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\Operation[]';
        $request = $this->operationsGetByHashCounterRequest($hash, $counter, $micheline, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetByHashCounter'
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetByHashCounterRequest($hash, $counter, $micheline = null, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetByHashCounter'
            );
        }
        // verify the required parameter 'counter' is set
        if ($counter === null || (is_array($counter) && count($counter) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $counter when calling operationsGetByHashCounter'
            );
        }

        $resourcePath = '/v1/operations/{hash}/{counter}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($micheline !== null) {
            if('form' === 'form' && is_array($micheline)) {
                foreach($micheline as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['micheline'] = $micheline;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }
        // path params
        if ($counter !== null) {
            $resourcePath = str_replace(
                '{' . 'counter' . '}',
                ObjectSerializer::toPathValue($counter),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetByHashCounterNonce
     *
     * Get operations by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\Operation[]
     */
    public function operationsGetByHashCounterNonce($hash, $counter, $nonce, $micheline = null, $quote = null)
    {
        list($response) = $this->operationsGetByHashCounterNonceWithHttpInfo($hash, $counter, $nonce, $micheline, $quote);
        return $response;
    }

    /**
     * Operation operationsGetByHashCounterNonceWithHttpInfo
     *
     * Get operations by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\Operation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetByHashCounterNonceWithHttpInfo($hash, $counter, $nonce, $micheline = null, $quote = null)
    {
        $request = $this->operationsGetByHashCounterNonceRequest($hash, $counter, $nonce, $micheline, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\Operation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\Operation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\Operation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\Operation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetByHashCounterNonceAsync
     *
     * Get operations by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetByHashCounterNonceAsync($hash, $counter, $nonce, $micheline = null, $quote = null)
    {
        return $this->operationsGetByHashCounterNonceAsyncWithHttpInfo($hash, $counter, $nonce, $micheline, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetByHashCounterNonceAsyncWithHttpInfo
     *
     * Get operations by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetByHashCounterNonceAsyncWithHttpInfo($hash, $counter, $nonce, $micheline = null, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\Operation[]';
        $request = $this->operationsGetByHashCounterNonceRequest($hash, $counter, $nonce, $micheline, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetByHashCounterNonce'
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetByHashCounterNonceRequest($hash, $counter, $nonce, $micheline = null, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetByHashCounterNonce'
            );
        }
        // verify the required parameter 'counter' is set
        if ($counter === null || (is_array($counter) && count($counter) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $counter when calling operationsGetByHashCounterNonce'
            );
        }
        // verify the required parameter 'nonce' is set
        if ($nonce === null || (is_array($nonce) && count($nonce) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nonce when calling operationsGetByHashCounterNonce'
            );
        }

        $resourcePath = '/v1/operations/{hash}/{counter}/{nonce}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($micheline !== null) {
            if('form' === 'form' && is_array($micheline)) {
                foreach($micheline as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['micheline'] = $micheline;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }
        // path params
        if ($counter !== null) {
            $resourcePath = str_replace(
                '{' . 'counter' . '}',
                ObjectSerializer::toPathValue($counter),
                $resourcePath
            );
        }
        // path params
        if ($nonce !== null) {
            $resourcePath = str_replace(
                '{' . 'nonce' . '}',
                ObjectSerializer::toPathValue($nonce),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDelegationByHash
     *
     * Get delegation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DelegationOperation[]
     */
    public function operationsGetDelegationByHash($hash, $quote = null)
    {
        list($response) = $this->operationsGetDelegationByHashWithHttpInfo($hash, $quote);
        return $response;
    }

    /**
     * Operation operationsGetDelegationByHashWithHttpInfo
     *
     * Get delegation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DelegationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDelegationByHashWithHttpInfo($hash, $quote = null)
    {
        $request = $this->operationsGetDelegationByHashRequest($hash, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DelegationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DelegationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DelegationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DelegationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDelegationByHashAsync
     *
     * Get delegation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDelegationByHashAsync($hash, $quote = null)
    {
        return $this->operationsGetDelegationByHashAsyncWithHttpInfo($hash, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDelegationByHashAsyncWithHttpInfo
     *
     * Get delegation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDelegationByHashAsyncWithHttpInfo($hash, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\DelegationOperation[]';
        $request = $this->operationsGetDelegationByHashRequest($hash, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDelegationByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDelegationByHashRequest($hash, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDelegationByHash'
            );
        }

        $resourcePath = '/v1/operations/delegations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDelegations
     *
     * Get delegations
     *
     * @param  string $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters delegations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DelegationOperation[]
     */
    public function operationsGetDelegations($anyof = null, $initiator = null, $sender = null, $prev_delegate = null, $new_delegate = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        list($response) = $this->operationsGetDelegationsWithHttpInfo($anyof, $initiator, $sender, $prev_delegate, $new_delegate, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote);
        return $response;
    }

    /**
     * Operation operationsGetDelegationsWithHttpInfo
     *
     * Get delegations
     *
     * @param  string $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters delegations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DelegationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDelegationsWithHttpInfo($anyof = null, $initiator = null, $sender = null, $prev_delegate = null, $new_delegate = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $request = $this->operationsGetDelegationsRequest($anyof, $initiator, $sender, $prev_delegate, $new_delegate, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DelegationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DelegationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DelegationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DelegationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDelegationsAsync
     *
     * Get delegations
     *
     * @param  string $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters delegations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDelegationsAsync($anyof = null, $initiator = null, $sender = null, $prev_delegate = null, $new_delegate = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        return $this->operationsGetDelegationsAsyncWithHttpInfo($anyof, $initiator, $sender, $prev_delegate, $new_delegate, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDelegationsAsyncWithHttpInfo
     *
     * Get delegations
     *
     * @param  string $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters delegations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDelegationsAsyncWithHttpInfo($anyof = null, $initiator = null, $sender = null, $prev_delegate = null, $new_delegate = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\DelegationOperation[]';
        $request = $this->operationsGetDelegationsRequest($anyof, $initiator, $sender, $prev_delegate, $new_delegate, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDelegations'
     *
     * @param  string $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters delegations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDelegationsRequest($anyof = null, $initiator = null, $sender = null, $prev_delegate = null, $new_delegate = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDelegations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDelegations, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v1/operations/delegations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($anyof !== null) {
            if('form' === 'form' && is_array($anyof)) {
                foreach($anyof as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['anyof'] = $anyof;
            }
        }
        // query params
        if ($initiator !== null) {
            if('form' === 'form' && is_array($initiator)) {
                foreach($initiator as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['initiator'] = $initiator;
            }
        }
        // query params
        if ($sender !== null) {
            if('form' === 'form' && is_array($sender)) {
                foreach($sender as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sender'] = $sender;
            }
        }
        // query params
        if ($prev_delegate !== null) {
            if('form' === 'form' && is_array($prev_delegate)) {
                foreach($prev_delegate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['prevDelegate'] = $prev_delegate;
            }
        }
        // query params
        if ($new_delegate !== null) {
            if('form' === 'form' && is_array($new_delegate)) {
                foreach($new_delegate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['newDelegate'] = $new_delegate;
            }
        }
        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($select !== null) {
            if('form' === 'form' && is_array($select)) {
                foreach($select as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['select'] = $select;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDelegationsCount
     *
     * Get delegations count
     *
     * @param  OneOfInt32Parameter $level Filters delegations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters delegations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetDelegationsCount($level = null, $timestamp = null)
    {
        list($response) = $this->operationsGetDelegationsCountWithHttpInfo($level, $timestamp);
        return $response;
    }

    /**
     * Operation operationsGetDelegationsCountWithHttpInfo
     *
     * Get delegations count
     *
     * @param  OneOfInt32Parameter $level Filters delegations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters delegations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDelegationsCountWithHttpInfo($level = null, $timestamp = null)
    {
        $request = $this->operationsGetDelegationsCountRequest($level, $timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDelegationsCountAsync
     *
     * Get delegations count
     *
     * @param  OneOfInt32Parameter $level Filters delegations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters delegations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDelegationsCountAsync($level = null, $timestamp = null)
    {
        return $this->operationsGetDelegationsCountAsyncWithHttpInfo($level, $timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDelegationsCountAsyncWithHttpInfo
     *
     * Get delegations count
     *
     * @param  OneOfInt32Parameter $level Filters delegations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters delegations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDelegationsCountAsyncWithHttpInfo($level = null, $timestamp = null)
    {
        $returnType = 'int';
        $request = $this->operationsGetDelegationsCountRequest($level, $timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDelegationsCount'
     *
     * @param  OneOfInt32Parameter $level Filters delegations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters delegations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDelegationsCountRequest($level = null, $timestamp = null)
    {

        $resourcePath = '/v1/operations/delegations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleBaking
     *
     * Get double baking
     *
     * @param  string $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  OneOfAccountParameter $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters double baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DoubleBakingOperation[]
     */
    public function operationsGetDoubleBaking($anyof = null, $accuser = null, $offender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        list($response) = $this->operationsGetDoubleBakingWithHttpInfo($anyof, $accuser, $offender, $level, $timestamp, $select, $sort, $offset, $limit, $quote);
        return $response;
    }

    /**
     * Operation operationsGetDoubleBakingWithHttpInfo
     *
     * Get double baking
     *
     * @param  string $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  OneOfAccountParameter $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters double baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DoubleBakingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleBakingWithHttpInfo($anyof = null, $accuser = null, $offender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $request = $this->operationsGetDoubleBakingRequest($anyof, $accuser, $offender, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DoubleBakingOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleBakingAsync
     *
     * Get double baking
     *
     * @param  string $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  OneOfAccountParameter $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters double baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleBakingAsync($anyof = null, $accuser = null, $offender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        return $this->operationsGetDoubleBakingAsyncWithHttpInfo($anyof, $accuser, $offender, $level, $timestamp, $select, $sort, $offset, $limit, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleBakingAsyncWithHttpInfo
     *
     * Get double baking
     *
     * @param  string $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  OneOfAccountParameter $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters double baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleBakingAsyncWithHttpInfo($anyof = null, $accuser = null, $offender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]';
        $request = $this->operationsGetDoubleBakingRequest($anyof, $accuser, $offender, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleBaking'
     *
     * @param  string $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  OneOfAccountParameter $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters double baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleBakingRequest($anyof = null, $accuser = null, $offender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoubleBaking, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoubleBaking, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v1/operations/double_baking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($anyof !== null) {
            if('form' === 'form' && is_array($anyof)) {
                foreach($anyof as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['anyof'] = $anyof;
            }
        }
        // query params
        if ($accuser !== null) {
            if('form' === 'form' && is_array($accuser)) {
                foreach($accuser as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['accuser'] = $accuser;
            }
        }
        // query params
        if ($offender !== null) {
            if('form' === 'form' && is_array($offender)) {
                foreach($offender as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offender'] = $offender;
            }
        }
        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($select !== null) {
            if('form' === 'form' && is_array($select)) {
                foreach($select as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['select'] = $select;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleBakingByHash
     *
     * Get double baking by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DoubleBakingOperation[]
     */
    public function operationsGetDoubleBakingByHash($hash, $quote = null)
    {
        list($response) = $this->operationsGetDoubleBakingByHashWithHttpInfo($hash, $quote);
        return $response;
    }

    /**
     * Operation operationsGetDoubleBakingByHashWithHttpInfo
     *
     * Get double baking by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DoubleBakingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleBakingByHashWithHttpInfo($hash, $quote = null)
    {
        $request = $this->operationsGetDoubleBakingByHashRequest($hash, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DoubleBakingOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleBakingByHashAsync
     *
     * Get double baking by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleBakingByHashAsync($hash, $quote = null)
    {
        return $this->operationsGetDoubleBakingByHashAsyncWithHttpInfo($hash, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleBakingByHashAsyncWithHttpInfo
     *
     * Get double baking by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleBakingByHashAsyncWithHttpInfo($hash, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]';
        $request = $this->operationsGetDoubleBakingByHashRequest($hash, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleBakingByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleBakingByHashRequest($hash, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDoubleBakingByHash'
            );
        }

        $resourcePath = '/v1/operations/double_baking/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleBakingCount
     *
     * Get double baking count
     *
     * @param  OneOfInt32Parameter $level Filters double baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double baking operations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetDoubleBakingCount($level = null, $timestamp = null)
    {
        list($response) = $this->operationsGetDoubleBakingCountWithHttpInfo($level, $timestamp);
        return $response;
    }

    /**
     * Operation operationsGetDoubleBakingCountWithHttpInfo
     *
     * Get double baking count
     *
     * @param  OneOfInt32Parameter $level Filters double baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double baking operations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleBakingCountWithHttpInfo($level = null, $timestamp = null)
    {
        $request = $this->operationsGetDoubleBakingCountRequest($level, $timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleBakingCountAsync
     *
     * Get double baking count
     *
     * @param  OneOfInt32Parameter $level Filters double baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double baking operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleBakingCountAsync($level = null, $timestamp = null)
    {
        return $this->operationsGetDoubleBakingCountAsyncWithHttpInfo($level, $timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleBakingCountAsyncWithHttpInfo
     *
     * Get double baking count
     *
     * @param  OneOfInt32Parameter $level Filters double baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double baking operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleBakingCountAsyncWithHttpInfo($level = null, $timestamp = null)
    {
        $returnType = 'int';
        $request = $this->operationsGetDoubleBakingCountRequest($level, $timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleBakingCount'
     *
     * @param  OneOfInt32Parameter $level Filters double baking operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double baking operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleBakingCountRequest($level = null, $timestamp = null)
    {

        $resourcePath = '/v1/operations/double_baking/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleEndorsing
     *
     * Get double endorsing
     *
     * @param  string $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  OneOfAccountParameter $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters double endorsing operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]
     */
    public function operationsGetDoubleEndorsing($anyof = null, $accuser = null, $offender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        list($response) = $this->operationsGetDoubleEndorsingWithHttpInfo($anyof, $accuser, $offender, $level, $timestamp, $select, $sort, $offset, $limit, $quote);
        return $response;
    }

    /**
     * Operation operationsGetDoubleEndorsingWithHttpInfo
     *
     * Get double endorsing
     *
     * @param  string $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  OneOfAccountParameter $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters double endorsing operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DoubleEndorsingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleEndorsingWithHttpInfo($anyof = null, $accuser = null, $offender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $request = $this->operationsGetDoubleEndorsingRequest($anyof, $accuser, $offender, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleEndorsingAsync
     *
     * Get double endorsing
     *
     * @param  string $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  OneOfAccountParameter $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters double endorsing operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleEndorsingAsync($anyof = null, $accuser = null, $offender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        return $this->operationsGetDoubleEndorsingAsyncWithHttpInfo($anyof, $accuser, $offender, $level, $timestamp, $select, $sort, $offset, $limit, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleEndorsingAsyncWithHttpInfo
     *
     * Get double endorsing
     *
     * @param  string $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  OneOfAccountParameter $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters double endorsing operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleEndorsingAsyncWithHttpInfo($anyof = null, $accuser = null, $offender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]';
        $request = $this->operationsGetDoubleEndorsingRequest($anyof, $accuser, $offender, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleEndorsing'
     *
     * @param  string $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  OneOfAccountParameter $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters double endorsing operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleEndorsingRequest($anyof = null, $accuser = null, $offender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoubleEndorsing, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoubleEndorsing, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v1/operations/double_endorsing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($anyof !== null) {
            if('form' === 'form' && is_array($anyof)) {
                foreach($anyof as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['anyof'] = $anyof;
            }
        }
        // query params
        if ($accuser !== null) {
            if('form' === 'form' && is_array($accuser)) {
                foreach($accuser as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['accuser'] = $accuser;
            }
        }
        // query params
        if ($offender !== null) {
            if('form' === 'form' && is_array($offender)) {
                foreach($offender as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offender'] = $offender;
            }
        }
        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($select !== null) {
            if('form' === 'form' && is_array($select)) {
                foreach($select as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['select'] = $select;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleEndorsingByHash
     *
     * Get double endorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]
     */
    public function operationsGetDoubleEndorsingByHash($hash, $quote = null)
    {
        list($response) = $this->operationsGetDoubleEndorsingByHashWithHttpInfo($hash, $quote);
        return $response;
    }

    /**
     * Operation operationsGetDoubleEndorsingByHashWithHttpInfo
     *
     * Get double endorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DoubleEndorsingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleEndorsingByHashWithHttpInfo($hash, $quote = null)
    {
        $request = $this->operationsGetDoubleEndorsingByHashRequest($hash, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleEndorsingByHashAsync
     *
     * Get double endorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleEndorsingByHashAsync($hash, $quote = null)
    {
        return $this->operationsGetDoubleEndorsingByHashAsyncWithHttpInfo($hash, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleEndorsingByHashAsyncWithHttpInfo
     *
     * Get double endorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleEndorsingByHashAsyncWithHttpInfo($hash, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]';
        $request = $this->operationsGetDoubleEndorsingByHashRequest($hash, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleEndorsingByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleEndorsingByHashRequest($hash, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDoubleEndorsingByHash'
            );
        }

        $resourcePath = '/v1/operations/double_endorsing/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleEndorsingCount
     *
     * Get double endorsing count
     *
     * @param  OneOfInt32Parameter $level Filters double endorsing operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetDoubleEndorsingCount($level = null, $timestamp = null)
    {
        list($response) = $this->operationsGetDoubleEndorsingCountWithHttpInfo($level, $timestamp);
        return $response;
    }

    /**
     * Operation operationsGetDoubleEndorsingCountWithHttpInfo
     *
     * Get double endorsing count
     *
     * @param  OneOfInt32Parameter $level Filters double endorsing operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleEndorsingCountWithHttpInfo($level = null, $timestamp = null)
    {
        $request = $this->operationsGetDoubleEndorsingCountRequest($level, $timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleEndorsingCountAsync
     *
     * Get double endorsing count
     *
     * @param  OneOfInt32Parameter $level Filters double endorsing operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleEndorsingCountAsync($level = null, $timestamp = null)
    {
        return $this->operationsGetDoubleEndorsingCountAsyncWithHttpInfo($level, $timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleEndorsingCountAsyncWithHttpInfo
     *
     * Get double endorsing count
     *
     * @param  OneOfInt32Parameter $level Filters double endorsing operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleEndorsingCountAsyncWithHttpInfo($level = null, $timestamp = null)
    {
        $returnType = 'int';
        $request = $this->operationsGetDoubleEndorsingCountRequest($level, $timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleEndorsingCount'
     *
     * @param  OneOfInt32Parameter $level Filters double endorsing operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleEndorsingCountRequest($level = null, $timestamp = null)
    {

        $resourcePath = '/v1/operations/double_endorsing/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsementByHash
     *
     * Get endorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\EndorsementOperation[]
     */
    public function operationsGetEndorsementByHash($hash, $quote = null)
    {
        list($response) = $this->operationsGetEndorsementByHashWithHttpInfo($hash, $quote);
        return $response;
    }

    /**
     * Operation operationsGetEndorsementByHashWithHttpInfo
     *
     * Get endorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\EndorsementOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsementByHashWithHttpInfo($hash, $quote = null)
    {
        $request = $this->operationsGetEndorsementByHashRequest($hash, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\EndorsementOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\EndorsementOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\EndorsementOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\EndorsementOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsementByHashAsync
     *
     * Get endorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsementByHashAsync($hash, $quote = null)
    {
        return $this->operationsGetEndorsementByHashAsyncWithHttpInfo($hash, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsementByHashAsyncWithHttpInfo
     *
     * Get endorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsementByHashAsyncWithHttpInfo($hash, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\EndorsementOperation[]';
        $request = $this->operationsGetEndorsementByHashRequest($hash, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsementByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsementByHashRequest($hash, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetEndorsementByHash'
            );
        }

        $resourcePath = '/v1/operations/endorsements/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsements
     *
     * Get endorsements
     *
     * @param  OneOfAccountParameter $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters endorsements by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\EndorsementOperation[]
     */
    public function operationsGetEndorsements($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        list($response) = $this->operationsGetEndorsementsWithHttpInfo($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote);
        return $response;
    }

    /**
     * Operation operationsGetEndorsementsWithHttpInfo
     *
     * Get endorsements
     *
     * @param  OneOfAccountParameter $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters endorsements by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\EndorsementOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsementsWithHttpInfo($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $request = $this->operationsGetEndorsementsRequest($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\EndorsementOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\EndorsementOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\EndorsementOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\EndorsementOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsementsAsync
     *
     * Get endorsements
     *
     * @param  OneOfAccountParameter $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters endorsements by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsementsAsync($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        return $this->operationsGetEndorsementsAsyncWithHttpInfo($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsementsAsyncWithHttpInfo
     *
     * Get endorsements
     *
     * @param  OneOfAccountParameter $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters endorsements by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsementsAsyncWithHttpInfo($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\EndorsementOperation[]';
        $request = $this->operationsGetEndorsementsRequest($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsements'
     *
     * @param  OneOfAccountParameter $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters endorsements by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsementsRequest($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetEndorsements, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetEndorsements, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v1/operations/endorsements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($delegate !== null) {
            if('form' === 'form' && is_array($delegate)) {
                foreach($delegate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['delegate'] = $delegate;
            }
        }
        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($select !== null) {
            if('form' === 'form' && is_array($select)) {
                foreach($select as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['select'] = $select;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsementsCount
     *
     * Get endorsements count
     *
     * @param  OneOfInt32Parameter $level Filters endorsements by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters endorsements by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetEndorsementsCount($level = null, $timestamp = null)
    {
        list($response) = $this->operationsGetEndorsementsCountWithHttpInfo($level, $timestamp);
        return $response;
    }

    /**
     * Operation operationsGetEndorsementsCountWithHttpInfo
     *
     * Get endorsements count
     *
     * @param  OneOfInt32Parameter $level Filters endorsements by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters endorsements by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsementsCountWithHttpInfo($level = null, $timestamp = null)
    {
        $request = $this->operationsGetEndorsementsCountRequest($level, $timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsementsCountAsync
     *
     * Get endorsements count
     *
     * @param  OneOfInt32Parameter $level Filters endorsements by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters endorsements by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsementsCountAsync($level = null, $timestamp = null)
    {
        return $this->operationsGetEndorsementsCountAsyncWithHttpInfo($level, $timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsementsCountAsyncWithHttpInfo
     *
     * Get endorsements count
     *
     * @param  OneOfInt32Parameter $level Filters endorsements by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters endorsements by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsementsCountAsyncWithHttpInfo($level = null, $timestamp = null)
    {
        $returnType = 'int';
        $request = $this->operationsGetEndorsementsCountRequest($level, $timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsementsCount'
     *
     * @param  OneOfInt32Parameter $level Filters endorsements by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters endorsements by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsementsCountRequest($level = null, $timestamp = null)
    {

        $resourcePath = '/v1/operations/endorsements/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetMigrations
     *
     * Get migrations
     *
     * @param  OneOfAccountParameter $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfMigrationKindParameter $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;). (optional)
     * @param  OneOfInt64Parameter $balance_change Filters migration operations by amount. (optional)
     * @param  OneOfInt32Parameter $level Filters migration operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters migration operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\MigrationOperation[]
     */
    public function operationsGetMigrations($account = null, $kind = null, $balance_change = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        list($response) = $this->operationsGetMigrationsWithHttpInfo($account, $kind, $balance_change, $level, $timestamp, $select, $sort, $offset, $limit, $quote);
        return $response;
    }

    /**
     * Operation operationsGetMigrationsWithHttpInfo
     *
     * Get migrations
     *
     * @param  OneOfAccountParameter $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfMigrationKindParameter $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;). (optional)
     * @param  OneOfInt64Parameter $balance_change Filters migration operations by amount. (optional)
     * @param  OneOfInt32Parameter $level Filters migration operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters migration operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\MigrationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetMigrationsWithHttpInfo($account = null, $kind = null, $balance_change = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $request = $this->operationsGetMigrationsRequest($account, $kind, $balance_change, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\MigrationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\MigrationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\MigrationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\MigrationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetMigrationsAsync
     *
     * Get migrations
     *
     * @param  OneOfAccountParameter $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfMigrationKindParameter $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;). (optional)
     * @param  OneOfInt64Parameter $balance_change Filters migration operations by amount. (optional)
     * @param  OneOfInt32Parameter $level Filters migration operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters migration operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetMigrationsAsync($account = null, $kind = null, $balance_change = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        return $this->operationsGetMigrationsAsyncWithHttpInfo($account, $kind, $balance_change, $level, $timestamp, $select, $sort, $offset, $limit, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetMigrationsAsyncWithHttpInfo
     *
     * Get migrations
     *
     * @param  OneOfAccountParameter $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfMigrationKindParameter $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;). (optional)
     * @param  OneOfInt64Parameter $balance_change Filters migration operations by amount. (optional)
     * @param  OneOfInt32Parameter $level Filters migration operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters migration operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetMigrationsAsyncWithHttpInfo($account = null, $kind = null, $balance_change = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\MigrationOperation[]';
        $request = $this->operationsGetMigrationsRequest($account, $kind, $balance_change, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetMigrations'
     *
     * @param  OneOfAccountParameter $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfMigrationKindParameter $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;). (optional)
     * @param  OneOfInt64Parameter $balance_change Filters migration operations by amount. (optional)
     * @param  OneOfInt32Parameter $level Filters migration operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters migration operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetMigrationsRequest($account = null, $kind = null, $balance_change = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetMigrations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetMigrations, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v1/operations/migrations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($account !== null) {
            if('form' === 'form' && is_array($account)) {
                foreach($account as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['account'] = $account;
            }
        }
        // query params
        if ($kind !== null) {
            if('form' === 'form' && is_array($kind)) {
                foreach($kind as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['kind'] = $kind;
            }
        }
        // query params
        if ($balance_change !== null) {
            if('form' === 'form' && is_array($balance_change)) {
                foreach($balance_change as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['balanceChange'] = $balance_change;
            }
        }
        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($select !== null) {
            if('form' === 'form' && is_array($select)) {
                foreach($select as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['select'] = $select;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetMigrationsCount
     *
     * Get migrations count
     *
     * @param  OneOfInt32Parameter $level Filters migrations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters migrations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetMigrationsCount($level = null, $timestamp = null)
    {
        list($response) = $this->operationsGetMigrationsCountWithHttpInfo($level, $timestamp);
        return $response;
    }

    /**
     * Operation operationsGetMigrationsCountWithHttpInfo
     *
     * Get migrations count
     *
     * @param  OneOfInt32Parameter $level Filters migrations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters migrations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetMigrationsCountWithHttpInfo($level = null, $timestamp = null)
    {
        $request = $this->operationsGetMigrationsCountRequest($level, $timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetMigrationsCountAsync
     *
     * Get migrations count
     *
     * @param  OneOfInt32Parameter $level Filters migrations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters migrations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetMigrationsCountAsync($level = null, $timestamp = null)
    {
        return $this->operationsGetMigrationsCountAsyncWithHttpInfo($level, $timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetMigrationsCountAsyncWithHttpInfo
     *
     * Get migrations count
     *
     * @param  OneOfInt32Parameter $level Filters migrations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters migrations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetMigrationsCountAsyncWithHttpInfo($level = null, $timestamp = null)
    {
        $returnType = 'int';
        $request = $this->operationsGetMigrationsCountRequest($level, $timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetMigrationsCount'
     *
     * @param  OneOfInt32Parameter $level Filters migrations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters migrations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetMigrationsCountRequest($level = null, $timestamp = null)
    {

        $resourcePath = '/v1/operations/migrations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetNonceRevelationByHash
     *
     * Get nonce revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\NonceRevelationOperation[]
     */
    public function operationsGetNonceRevelationByHash($hash, $quote = null)
    {
        list($response) = $this->operationsGetNonceRevelationByHashWithHttpInfo($hash, $quote);
        return $response;
    }

    /**
     * Operation operationsGetNonceRevelationByHashWithHttpInfo
     *
     * Get nonce revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\NonceRevelationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetNonceRevelationByHashWithHttpInfo($hash, $quote = null)
    {
        $request = $this->operationsGetNonceRevelationByHashRequest($hash, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\NonceRevelationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetNonceRevelationByHashAsync
     *
     * Get nonce revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetNonceRevelationByHashAsync($hash, $quote = null)
    {
        return $this->operationsGetNonceRevelationByHashAsyncWithHttpInfo($hash, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetNonceRevelationByHashAsyncWithHttpInfo
     *
     * Get nonce revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetNonceRevelationByHashAsyncWithHttpInfo($hash, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]';
        $request = $this->operationsGetNonceRevelationByHashRequest($hash, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetNonceRevelationByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetNonceRevelationByHashRequest($hash, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetNonceRevelationByHash'
            );
        }

        $resourcePath = '/v1/operations/nonce_revelations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetNonceRevelations
     *
     * Get nonce revelations
     *
     * @param  string $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters nonce revelation operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\NonceRevelationOperation[]
     */
    public function operationsGetNonceRevelations($anyof = null, $baker = null, $sender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        list($response) = $this->operationsGetNonceRevelationsWithHttpInfo($anyof, $baker, $sender, $level, $timestamp, $select, $sort, $offset, $limit, $quote);
        return $response;
    }

    /**
     * Operation operationsGetNonceRevelationsWithHttpInfo
     *
     * Get nonce revelations
     *
     * @param  string $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters nonce revelation operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\NonceRevelationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetNonceRevelationsWithHttpInfo($anyof = null, $baker = null, $sender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $request = $this->operationsGetNonceRevelationsRequest($anyof, $baker, $sender, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\NonceRevelationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetNonceRevelationsAsync
     *
     * Get nonce revelations
     *
     * @param  string $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters nonce revelation operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetNonceRevelationsAsync($anyof = null, $baker = null, $sender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        return $this->operationsGetNonceRevelationsAsyncWithHttpInfo($anyof, $baker, $sender, $level, $timestamp, $select, $sort, $offset, $limit, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetNonceRevelationsAsyncWithHttpInfo
     *
     * Get nonce revelations
     *
     * @param  string $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters nonce revelation operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetNonceRevelationsAsyncWithHttpInfo($anyof = null, $baker = null, $sender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]';
        $request = $this->operationsGetNonceRevelationsRequest($anyof, $baker, $sender, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetNonceRevelations'
     *
     * @param  string $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  OneOfInt32Parameter $level Filters nonce revelation operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetNonceRevelationsRequest($anyof = null, $baker = null, $sender = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetNonceRevelations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetNonceRevelations, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v1/operations/nonce_revelations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($anyof !== null) {
            if('form' === 'form' && is_array($anyof)) {
                foreach($anyof as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['anyof'] = $anyof;
            }
        }
        // query params
        if ($baker !== null) {
            if('form' === 'form' && is_array($baker)) {
                foreach($baker as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['baker'] = $baker;
            }
        }
        // query params
        if ($sender !== null) {
            if('form' === 'form' && is_array($sender)) {
                foreach($sender as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sender'] = $sender;
            }
        }
        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($select !== null) {
            if('form' === 'form' && is_array($select)) {
                foreach($select as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['select'] = $select;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetNonceRevelationsCount
     *
     * Get nonce revelations count
     *
     * @param  OneOfInt32Parameter $level Filters seed nonce revelation operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetNonceRevelationsCount($level = null, $timestamp = null)
    {
        list($response) = $this->operationsGetNonceRevelationsCountWithHttpInfo($level, $timestamp);
        return $response;
    }

    /**
     * Operation operationsGetNonceRevelationsCountWithHttpInfo
     *
     * Get nonce revelations count
     *
     * @param  OneOfInt32Parameter $level Filters seed nonce revelation operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetNonceRevelationsCountWithHttpInfo($level = null, $timestamp = null)
    {
        $request = $this->operationsGetNonceRevelationsCountRequest($level, $timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetNonceRevelationsCountAsync
     *
     * Get nonce revelations count
     *
     * @param  OneOfInt32Parameter $level Filters seed nonce revelation operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetNonceRevelationsCountAsync($level = null, $timestamp = null)
    {
        return $this->operationsGetNonceRevelationsCountAsyncWithHttpInfo($level, $timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetNonceRevelationsCountAsyncWithHttpInfo
     *
     * Get nonce revelations count
     *
     * @param  OneOfInt32Parameter $level Filters seed nonce revelation operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetNonceRevelationsCountAsyncWithHttpInfo($level = null, $timestamp = null)
    {
        $returnType = 'int';
        $request = $this->operationsGetNonceRevelationsCountRequest($level, $timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetNonceRevelationsCount'
     *
     * @param  OneOfInt32Parameter $level Filters seed nonce revelation operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetNonceRevelationsCountRequest($level = null, $timestamp = null)
    {

        $resourcePath = '/v1/operations/nonce_revelations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetOriginationByHash
     *
     * Get origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Bzzhh\Tzkt\Model\MichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\OriginationOperation[]
     */
    public function operationsGetOriginationByHash($hash, $micheline = null, $quote = null)
    {
        list($response) = $this->operationsGetOriginationByHashWithHttpInfo($hash, $micheline, $quote);
        return $response;
    }

    /**
     * Operation operationsGetOriginationByHashWithHttpInfo
     *
     * Get origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Bzzhh\Tzkt\Model\MichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\OriginationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetOriginationByHashWithHttpInfo($hash, $micheline = null, $quote = null)
    {
        $request = $this->operationsGetOriginationByHashRequest($hash, $micheline, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\OriginationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\OriginationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\OriginationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\OriginationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetOriginationByHashAsync
     *
     * Get origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Bzzhh\Tzkt\Model\MichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetOriginationByHashAsync($hash, $micheline = null, $quote = null)
    {
        return $this->operationsGetOriginationByHashAsyncWithHttpInfo($hash, $micheline, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetOriginationByHashAsyncWithHttpInfo
     *
     * Get origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  \Bzzhh\Tzkt\Model\MichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetOriginationByHashAsyncWithHttpInfo($hash, $micheline = null, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\OriginationOperation[]';
        $request = $this->operationsGetOriginationByHashRequest($hash, $micheline, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetOriginationByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  \Bzzhh\Tzkt\Model\MichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetOriginationByHashRequest($hash, $micheline = null, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetOriginationByHash'
            );
        }

        $resourcePath = '/v1/operations/originations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($micheline !== null) {
            if('form' === 'form' && is_array($micheline)) {
                foreach($micheline as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['micheline'] = $micheline;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetOriginations
     *
     * Get originations
     *
     * @param  string $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  OneOfAccountParameter $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters origination operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters origination operations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\OriginationOperation[]
     */
    public function operationsGetOriginations($anyof = null, $initiator = null, $sender = null, $contract_manager = null, $contract_delegate = null, $originated_contract = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null)
    {
        list($response) = $this->operationsGetOriginationsWithHttpInfo($anyof, $initiator, $sender, $contract_manager, $contract_delegate, $originated_contract, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote);
        return $response;
    }

    /**
     * Operation operationsGetOriginationsWithHttpInfo
     *
     * Get originations
     *
     * @param  string $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  OneOfAccountParameter $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters origination operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters origination operations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\OriginationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetOriginationsWithHttpInfo($anyof = null, $initiator = null, $sender = null, $contract_manager = null, $contract_delegate = null, $originated_contract = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null)
    {
        $request = $this->operationsGetOriginationsRequest($anyof, $initiator, $sender, $contract_manager, $contract_delegate, $originated_contract, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\OriginationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\OriginationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\OriginationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\OriginationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetOriginationsAsync
     *
     * Get originations
     *
     * @param  string $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  OneOfAccountParameter $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters origination operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters origination operations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetOriginationsAsync($anyof = null, $initiator = null, $sender = null, $contract_manager = null, $contract_delegate = null, $originated_contract = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null)
    {
        return $this->operationsGetOriginationsAsyncWithHttpInfo($anyof, $initiator, $sender, $contract_manager, $contract_delegate, $originated_contract, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetOriginationsAsyncWithHttpInfo
     *
     * Get originations
     *
     * @param  string $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  OneOfAccountParameter $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters origination operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters origination operations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetOriginationsAsyncWithHttpInfo($anyof = null, $initiator = null, $sender = null, $contract_manager = null, $contract_delegate = null, $originated_contract = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\OriginationOperation[]';
        $request = $this->operationsGetOriginationsRequest($anyof, $initiator, $sender, $contract_manager, $contract_delegate, $originated_contract, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetOriginations'
     *
     * @param  string $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  OneOfAccountParameter $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  OneOfAccountParameter $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters origination operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters origination operations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetOriginationsRequest($anyof = null, $initiator = null, $sender = null, $contract_manager = null, $contract_delegate = null, $originated_contract = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null)
    {
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetOriginations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetOriginations, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v1/operations/originations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($anyof !== null) {
            if('form' === 'form' && is_array($anyof)) {
                foreach($anyof as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['anyof'] = $anyof;
            }
        }
        // query params
        if ($initiator !== null) {
            if('form' === 'form' && is_array($initiator)) {
                foreach($initiator as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['initiator'] = $initiator;
            }
        }
        // query params
        if ($sender !== null) {
            if('form' === 'form' && is_array($sender)) {
                foreach($sender as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sender'] = $sender;
            }
        }
        // query params
        if ($contract_manager !== null) {
            if('form' === 'form' && is_array($contract_manager)) {
                foreach($contract_manager as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contractManager'] = $contract_manager;
            }
        }
        // query params
        if ($contract_delegate !== null) {
            if('form' === 'form' && is_array($contract_delegate)) {
                foreach($contract_delegate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['contractDelegate'] = $contract_delegate;
            }
        }
        // query params
        if ($originated_contract !== null) {
            if('form' === 'form' && is_array($originated_contract)) {
                foreach($originated_contract as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['originatedContract'] = $originated_contract;
            }
        }
        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($select !== null) {
            if('form' === 'form' && is_array($select)) {
                foreach($select as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['select'] = $select;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($micheline !== null) {
            if('form' === 'form' && is_array($micheline)) {
                foreach($micheline as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['micheline'] = $micheline;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetOriginationsCount
     *
     * Get originations count
     *
     * @param  OneOfInt32Parameter $level Filters originations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters originations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetOriginationsCount($level = null, $timestamp = null)
    {
        list($response) = $this->operationsGetOriginationsCountWithHttpInfo($level, $timestamp);
        return $response;
    }

    /**
     * Operation operationsGetOriginationsCountWithHttpInfo
     *
     * Get originations count
     *
     * @param  OneOfInt32Parameter $level Filters originations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters originations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetOriginationsCountWithHttpInfo($level = null, $timestamp = null)
    {
        $request = $this->operationsGetOriginationsCountRequest($level, $timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetOriginationsCountAsync
     *
     * Get originations count
     *
     * @param  OneOfInt32Parameter $level Filters originations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters originations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetOriginationsCountAsync($level = null, $timestamp = null)
    {
        return $this->operationsGetOriginationsCountAsyncWithHttpInfo($level, $timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetOriginationsCountAsyncWithHttpInfo
     *
     * Get originations count
     *
     * @param  OneOfInt32Parameter $level Filters originations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters originations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetOriginationsCountAsyncWithHttpInfo($level = null, $timestamp = null)
    {
        $returnType = 'int';
        $request = $this->operationsGetOriginationsCountRequest($level, $timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetOriginationsCount'
     *
     * @param  OneOfInt32Parameter $level Filters originations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters originations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetOriginationsCountRequest($level = null, $timestamp = null)
    {

        $resourcePath = '/v1/operations/originations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetProposalByHash
     *
     * Get proposal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\ProposalOperation[]
     */
    public function operationsGetProposalByHash($hash, $quote = null)
    {
        list($response) = $this->operationsGetProposalByHashWithHttpInfo($hash, $quote);
        return $response;
    }

    /**
     * Operation operationsGetProposalByHashWithHttpInfo
     *
     * Get proposal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\ProposalOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetProposalByHashWithHttpInfo($hash, $quote = null)
    {
        $request = $this->operationsGetProposalByHashRequest($hash, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\ProposalOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\ProposalOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\ProposalOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\ProposalOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetProposalByHashAsync
     *
     * Get proposal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetProposalByHashAsync($hash, $quote = null)
    {
        return $this->operationsGetProposalByHashAsyncWithHttpInfo($hash, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetProposalByHashAsyncWithHttpInfo
     *
     * Get proposal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetProposalByHashAsyncWithHttpInfo($hash, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\ProposalOperation[]';
        $request = $this->operationsGetProposalByHashRequest($hash, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetProposalByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetProposalByHashRequest($hash, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetProposalByHash'
            );
        }

        $resourcePath = '/v1/operations/proposals/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetProposals
     *
     * Get proposals
     *
     * @param  OneOfAccountParameter $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters proposal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  OneOfInt32Parameter $epoch Filters proposal operations by voting epoch. (optional)
     * @param  OneOfInt32Parameter $period Filters proposal operations by voting period. (optional)
     * @param  OneOfProtocolParameter $proposal Filters proposal operations by proposal hash. (optional)
     * @param  OneOfBoolParameter $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\ProposalOperation[]
     */
    public function operationsGetProposals($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $duplicated = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        list($response) = $this->operationsGetProposalsWithHttpInfo($delegate, $level, $timestamp, $epoch, $period, $proposal, $duplicated, $select, $sort, $offset, $limit, $quote);
        return $response;
    }

    /**
     * Operation operationsGetProposalsWithHttpInfo
     *
     * Get proposals
     *
     * @param  OneOfAccountParameter $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters proposal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  OneOfInt32Parameter $epoch Filters proposal operations by voting epoch. (optional)
     * @param  OneOfInt32Parameter $period Filters proposal operations by voting period. (optional)
     * @param  OneOfProtocolParameter $proposal Filters proposal operations by proposal hash. (optional)
     * @param  OneOfBoolParameter $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\ProposalOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetProposalsWithHttpInfo($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $duplicated = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $request = $this->operationsGetProposalsRequest($delegate, $level, $timestamp, $epoch, $period, $proposal, $duplicated, $select, $sort, $offset, $limit, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\ProposalOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\ProposalOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\ProposalOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\ProposalOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetProposalsAsync
     *
     * Get proposals
     *
     * @param  OneOfAccountParameter $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters proposal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  OneOfInt32Parameter $epoch Filters proposal operations by voting epoch. (optional)
     * @param  OneOfInt32Parameter $period Filters proposal operations by voting period. (optional)
     * @param  OneOfProtocolParameter $proposal Filters proposal operations by proposal hash. (optional)
     * @param  OneOfBoolParameter $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetProposalsAsync($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $duplicated = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        return $this->operationsGetProposalsAsyncWithHttpInfo($delegate, $level, $timestamp, $epoch, $period, $proposal, $duplicated, $select, $sort, $offset, $limit, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetProposalsAsyncWithHttpInfo
     *
     * Get proposals
     *
     * @param  OneOfAccountParameter $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters proposal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  OneOfInt32Parameter $epoch Filters proposal operations by voting epoch. (optional)
     * @param  OneOfInt32Parameter $period Filters proposal operations by voting period. (optional)
     * @param  OneOfProtocolParameter $proposal Filters proposal operations by proposal hash. (optional)
     * @param  OneOfBoolParameter $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetProposalsAsyncWithHttpInfo($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $duplicated = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\ProposalOperation[]';
        $request = $this->operationsGetProposalsRequest($delegate, $level, $timestamp, $epoch, $period, $proposal, $duplicated, $select, $sort, $offset, $limit, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetProposals'
     *
     * @param  OneOfAccountParameter $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters proposal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  OneOfInt32Parameter $epoch Filters proposal operations by voting epoch. (optional)
     * @param  OneOfInt32Parameter $period Filters proposal operations by voting period. (optional)
     * @param  OneOfProtocolParameter $proposal Filters proposal operations by proposal hash. (optional)
     * @param  OneOfBoolParameter $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetProposalsRequest($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $duplicated = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetProposals, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetProposals, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v1/operations/proposals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($delegate !== null) {
            if('form' === 'form' && is_array($delegate)) {
                foreach($delegate as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['delegate'] = $delegate;
            }
        }
        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($epoch !== null) {
            if('form' === 'form' && is_array($epoch)) {
                foreach($epoch as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['epoch'] = $epoch;
            }
        }
        // query params
        if ($period !== null) {
            if('form' === 'form' && is_array($period)) {
                foreach($period as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['period'] = $period;
            }
        }
        // query params
        if ($proposal !== null) {
            if('form' === 'form' && is_array($proposal)) {
                foreach($proposal as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['proposal'] = $proposal;
            }
        }
        // query params
        if ($duplicated !== null) {
            if('form' === 'form' && is_array($duplicated)) {
                foreach($duplicated as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['duplicated'] = $duplicated;
            }
        }
        // query params
        if ($select !== null) {
            if('form' === 'form' && is_array($select)) {
                foreach($select as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['select'] = $select;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetProposalsCount
     *
     * Get proposals count
     *
     * @param  OneOfInt32Parameter $level Filters proposal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters proposal operations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetProposalsCount($level = null, $timestamp = null)
    {
        list($response) = $this->operationsGetProposalsCountWithHttpInfo($level, $timestamp);
        return $response;
    }

    /**
     * Operation operationsGetProposalsCountWithHttpInfo
     *
     * Get proposals count
     *
     * @param  OneOfInt32Parameter $level Filters proposal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters proposal operations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetProposalsCountWithHttpInfo($level = null, $timestamp = null)
    {
        $request = $this->operationsGetProposalsCountRequest($level, $timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetProposalsCountAsync
     *
     * Get proposals count
     *
     * @param  OneOfInt32Parameter $level Filters proposal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters proposal operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetProposalsCountAsync($level = null, $timestamp = null)
    {
        return $this->operationsGetProposalsCountAsyncWithHttpInfo($level, $timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetProposalsCountAsyncWithHttpInfo
     *
     * Get proposals count
     *
     * @param  OneOfInt32Parameter $level Filters proposal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters proposal operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetProposalsCountAsyncWithHttpInfo($level = null, $timestamp = null)
    {
        $returnType = 'int';
        $request = $this->operationsGetProposalsCountRequest($level, $timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetProposalsCount'
     *
     * @param  OneOfInt32Parameter $level Filters proposal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters proposal operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetProposalsCountRequest($level = null, $timestamp = null)
    {

        $resourcePath = '/v1/operations/proposals/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevealByHash
     *
     * Get reveal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\RevealOperation[]
     */
    public function operationsGetRevealByHash($hash, $quote = null)
    {
        list($response) = $this->operationsGetRevealByHashWithHttpInfo($hash, $quote);
        return $response;
    }

    /**
     * Operation operationsGetRevealByHashWithHttpInfo
     *
     * Get reveal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\RevealOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevealByHashWithHttpInfo($hash, $quote = null)
    {
        $request = $this->operationsGetRevealByHashRequest($hash, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\RevealOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\RevealOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\RevealOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\RevealOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevealByHashAsync
     *
     * Get reveal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevealByHashAsync($hash, $quote = null)
    {
        return $this->operationsGetRevealByHashAsyncWithHttpInfo($hash, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevealByHashAsyncWithHttpInfo
     *
     * Get reveal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevealByHashAsyncWithHttpInfo($hash, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\RevealOperation[]';
        $request = $this->operationsGetRevealByHashRequest($hash, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevealByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevealByHashRequest($hash, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetRevealByHash'
            );
        }

        $resourcePath = '/v1/operations/reveals/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetReveals
     *
     * Get reveals
     *
     * @param  OneOfAccountParameter $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters reveal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters reveal operations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\RevealOperation[]
     */
    public function operationsGetReveals($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        list($response) = $this->operationsGetRevealsWithHttpInfo($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote);
        return $response;
    }

    /**
     * Operation operationsGetRevealsWithHttpInfo
     *
     * Get reveals
     *
     * @param  OneOfAccountParameter $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters reveal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters reveal operations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\RevealOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevealsWithHttpInfo($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $request = $this->operationsGetRevealsRequest($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\RevealOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\RevealOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\RevealOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\RevealOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevealsAsync
     *
     * Get reveals
     *
     * @param  OneOfAccountParameter $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters reveal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters reveal operations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevealsAsync($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        return $this->operationsGetRevealsAsyncWithHttpInfo($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevealsAsyncWithHttpInfo
     *
     * Get reveals
     *
     * @param  OneOfAccountParameter $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters reveal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters reveal operations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevealsAsyncWithHttpInfo($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\RevealOperation[]';
        $request = $this->operationsGetRevealsRequest($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetReveals'
     *
     * @param  OneOfAccountParameter $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters reveal operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters reveal operations by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevealsRequest($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetReveals, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetReveals, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v1/operations/reveals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sender !== null) {
            if('form' === 'form' && is_array($sender)) {
                foreach($sender as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sender'] = $sender;
            }
        }
        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($select !== null) {
            if('form' === 'form' && is_array($select)) {
                foreach($select as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['select'] = $select;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevealsCount
     *
     * Get reveals count
     *
     * @param  OneOfInt32Parameter $level Filters reveals by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters reveals by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetRevealsCount($level = null, $timestamp = null)
    {
        list($response) = $this->operationsGetRevealsCountWithHttpInfo($level, $timestamp);
        return $response;
    }

    /**
     * Operation operationsGetRevealsCountWithHttpInfo
     *
     * Get reveals count
     *
     * @param  OneOfInt32Parameter $level Filters reveals by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters reveals by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevealsCountWithHttpInfo($level = null, $timestamp = null)
    {
        $request = $this->operationsGetRevealsCountRequest($level, $timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevealsCountAsync
     *
     * Get reveals count
     *
     * @param  OneOfInt32Parameter $level Filters reveals by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters reveals by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevealsCountAsync($level = null, $timestamp = null)
    {
        return $this->operationsGetRevealsCountAsyncWithHttpInfo($level, $timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevealsCountAsyncWithHttpInfo
     *
     * Get reveals count
     *
     * @param  OneOfInt32Parameter $level Filters reveals by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters reveals by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevealsCountAsyncWithHttpInfo($level = null, $timestamp = null)
    {
        $returnType = 'int';
        $request = $this->operationsGetRevealsCountRequest($level, $timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevealsCount'
     *
     * @param  OneOfInt32Parameter $level Filters reveals by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters reveals by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevealsCountRequest($level = null, $timestamp = null)
    {

        $resourcePath = '/v1/operations/reveals/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevelationPenalties
     *
     * Get revelation penalties
     *
     * @param  OneOfAccountParameter $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters revelation penalty operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\RevelationPenaltyOperation[]
     */
    public function operationsGetRevelationPenalties($baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        list($response) = $this->operationsGetRevelationPenaltiesWithHttpInfo($baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote);
        return $response;
    }

    /**
     * Operation operationsGetRevelationPenaltiesWithHttpInfo
     *
     * Get revelation penalties
     *
     * @param  OneOfAccountParameter $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters revelation penalty operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\RevelationPenaltyOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevelationPenaltiesWithHttpInfo($baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $request = $this->operationsGetRevelationPenaltiesRequest($baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\RevelationPenaltyOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\RevelationPenaltyOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\RevelationPenaltyOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\RevelationPenaltyOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevelationPenaltiesAsync
     *
     * Get revelation penalties
     *
     * @param  OneOfAccountParameter $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters revelation penalty operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevelationPenaltiesAsync($baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        return $this->operationsGetRevelationPenaltiesAsyncWithHttpInfo($baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevelationPenaltiesAsyncWithHttpInfo
     *
     * Get revelation penalties
     *
     * @param  OneOfAccountParameter $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters revelation penalty operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevelationPenaltiesAsyncWithHttpInfo($baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\RevelationPenaltyOperation[]';
        $request = $this->operationsGetRevelationPenaltiesRequest($baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevelationPenalties'
     *
     * @param  OneOfAccountParameter $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OneOfInt32Parameter $level Filters revelation penalty operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevelationPenaltiesRequest($baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null)
    {
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetRevelationPenalties, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetRevelationPenalties, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v1/operations/revelation_penalties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($baker !== null) {
            if('form' === 'form' && is_array($baker)) {
                foreach($baker as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['baker'] = $baker;
            }
        }
        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($select !== null) {
            if('form' === 'form' && is_array($select)) {
                foreach($select as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['select'] = $select;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevelationPenaltiesCount
     *
     * Get revelation penalties count
     *
     * @param  OneOfInt32Parameter $level Filters revelation penalty operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetRevelationPenaltiesCount($level = null, $timestamp = null)
    {
        list($response) = $this->operationsGetRevelationPenaltiesCountWithHttpInfo($level, $timestamp);
        return $response;
    }

    /**
     * Operation operationsGetRevelationPenaltiesCountWithHttpInfo
     *
     * Get revelation penalties count
     *
     * @param  OneOfInt32Parameter $level Filters revelation penalty operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevelationPenaltiesCountWithHttpInfo($level = null, $timestamp = null)
    {
        $request = $this->operationsGetRevelationPenaltiesCountRequest($level, $timestamp);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevelationPenaltiesCountAsync
     *
     * Get revelation penalties count
     *
     * @param  OneOfInt32Parameter $level Filters revelation penalty operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevelationPenaltiesCountAsync($level = null, $timestamp = null)
    {
        return $this->operationsGetRevelationPenaltiesCountAsyncWithHttpInfo($level, $timestamp)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevelationPenaltiesCountAsyncWithHttpInfo
     *
     * Get revelation penalties count
     *
     * @param  OneOfInt32Parameter $level Filters revelation penalty operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevelationPenaltiesCountAsyncWithHttpInfo($level = null, $timestamp = null)
    {
        $returnType = 'int';
        $request = $this->operationsGetRevelationPenaltiesCountRequest($level, $timestamp);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevelationPenaltiesCount'
     *
     * @param  OneOfInt32Parameter $level Filters revelation penalty operations by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevelationPenaltiesCountRequest($level = null, $timestamp = null)
    {

        $resourcePath = '/v1/operations/revelation_penalties/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactionByHash
     *
     * Get transaction by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TransactionOperation[]
     */
    public function operationsGetTransactionByHash($hash, $micheline = null, $quote = null)
    {
        list($response) = $this->operationsGetTransactionByHashWithHttpInfo($hash, $micheline, $quote);
        return $response;
    }

    /**
     * Operation operationsGetTransactionByHashWithHttpInfo
     *
     * Get transaction by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TransactionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionByHashWithHttpInfo($hash, $micheline = null, $quote = null)
    {
        $request = $this->operationsGetTransactionByHashRequest($hash, $micheline, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TransactionOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TransactionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TransactionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionByHashAsync
     *
     * Get transaction by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionByHashAsync($hash, $micheline = null, $quote = null)
    {
        return $this->operationsGetTransactionByHashAsyncWithHttpInfo($hash, $micheline, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionByHashAsyncWithHttpInfo
     *
     * Get transaction by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionByHashAsyncWithHttpInfo($hash, $micheline = null, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
        $request = $this->operationsGetTransactionByHashRequest($hash, $micheline, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactionByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionByHashRequest($hash, $micheline = null, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransactionByHash'
            );
        }

        $resourcePath = '/v1/operations/transactions/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($micheline !== null) {
            if('form' === 'form' && is_array($micheline)) {
                foreach($micheline as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['micheline'] = $micheline;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactionByHashCounter
     *
     * Get transaction by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TransactionOperation[]
     */
    public function operationsGetTransactionByHashCounter($hash, $counter, $micheline = null, $quote = null)
    {
        list($response) = $this->operationsGetTransactionByHashCounterWithHttpInfo($hash, $counter, $micheline, $quote);
        return $response;
    }

    /**
     * Operation operationsGetTransactionByHashCounterWithHttpInfo
     *
     * Get transaction by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TransactionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionByHashCounterWithHttpInfo($hash, $counter, $micheline = null, $quote = null)
    {
        $request = $this->operationsGetTransactionByHashCounterRequest($hash, $counter, $micheline, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TransactionOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TransactionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TransactionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionByHashCounterAsync
     *
     * Get transaction by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionByHashCounterAsync($hash, $counter, $micheline = null, $quote = null)
    {
        return $this->operationsGetTransactionByHashCounterAsyncWithHttpInfo($hash, $counter, $micheline, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionByHashCounterAsyncWithHttpInfo
     *
     * Get transaction by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionByHashCounterAsyncWithHttpInfo($hash, $counter, $micheline = null, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
        $request = $this->operationsGetTransactionByHashCounterRequest($hash, $counter, $micheline, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactionByHashCounter'
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionByHashCounterRequest($hash, $counter, $micheline = null, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransactionByHashCounter'
            );
        }
        // verify the required parameter 'counter' is set
        if ($counter === null || (is_array($counter) && count($counter) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $counter when calling operationsGetTransactionByHashCounter'
            );
        }

        $resourcePath = '/v1/operations/transactions/{hash}/{counter}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($micheline !== null) {
            if('form' === 'form' && is_array($micheline)) {
                foreach($micheline as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['micheline'] = $micheline;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }
        // path params
        if ($counter !== null) {
            $resourcePath = str_replace(
                '{' . 'counter' . '}',
                ObjectSerializer::toPathValue($counter),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactionByHashCounterNonce
     *
     * Get transaction by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TransactionOperation[]
     */
    public function operationsGetTransactionByHashCounterNonce($hash, $counter, $nonce, $micheline = null, $quote = null)
    {
        list($response) = $this->operationsGetTransactionByHashCounterNonceWithHttpInfo($hash, $counter, $nonce, $micheline, $quote);
        return $response;
    }

    /**
     * Operation operationsGetTransactionByHashCounterNonceWithHttpInfo
     *
     * Get transaction by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TransactionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionByHashCounterNonceWithHttpInfo($hash, $counter, $nonce, $micheline = null, $quote = null)
    {
        $request = $this->operationsGetTransactionByHashCounterNonceRequest($hash, $counter, $nonce, $micheline, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TransactionOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TransactionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TransactionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionByHashCounterNonceAsync
     *
     * Get transaction by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionByHashCounterNonceAsync($hash, $counter, $nonce, $micheline = null, $quote = null)
    {
        return $this->operationsGetTransactionByHashCounterNonceAsyncWithHttpInfo($hash, $counter, $nonce, $micheline, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionByHashCounterNonceAsyncWithHttpInfo
     *
     * Get transaction by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionByHashCounterNonceAsyncWithHttpInfo($hash, $counter, $nonce, $micheline = null, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
        $request = $this->operationsGetTransactionByHashCounterNonceRequest($hash, $counter, $nonce, $micheline, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactionByHashCounterNonce'
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionByHashCounterNonceRequest($hash, $counter, $nonce, $micheline = null, $quote = null)
    {
        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransactionByHashCounterNonce'
            );
        }
        // verify the required parameter 'counter' is set
        if ($counter === null || (is_array($counter) && count($counter) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $counter when calling operationsGetTransactionByHashCounterNonce'
            );
        }
        // verify the required parameter 'nonce' is set
        if ($nonce === null || (is_array($nonce) && count($nonce) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nonce when calling operationsGetTransactionByHashCounterNonce'
            );
        }

        $resourcePath = '/v1/operations/transactions/{hash}/{counter}/{nonce}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($micheline !== null) {
            if('form' === 'form' && is_array($micheline)) {
                foreach($micheline as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['micheline'] = $micheline;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }
        // path params
        if ($counter !== null) {
            $resourcePath = str_replace(
                '{' . 'counter' . '}',
                ObjectSerializer::toPathValue($counter),
                $resourcePath
            );
        }
        // path params
        if ($nonce !== null) {
            $resourcePath = str_replace(
                '{' . 'nonce' . '}',
                ObjectSerializer::toPathValue($nonce),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactions
     *
     * Get transactions
     *
     * @param  string $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  OneOfAccountParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  OneOfInt64Parameter $amount Filters transactions by amount (microtez). (optional)
     * @param  OneOfInt32Parameter $level Filters transactions by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  OneOfStringParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  OneOfJsonParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;. (optional)
     * @param  OneOfStringParameter $parameters **DEPRECATED**. Use &#x60;entrypoint&#x60; and &#x60;parameter&#x60; instead. (optional)
     * @param  OneOfBoolParameter $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  OneOfOperationStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TransactionOperation[]
     */
    public function operationsGetTransactions($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $level = null, $timestamp = null, $entrypoint = null, $parameter = null, $parameters = null, $has_internals = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null)
    {
        list($response) = $this->operationsGetTransactionsWithHttpInfo($anyof, $initiator, $sender, $target, $amount, $level, $timestamp, $entrypoint, $parameter, $parameters, $has_internals, $status, $select, $sort, $offset, $limit, $micheline, $quote);
        return $response;
    }

    /**
     * Operation operationsGetTransactionsWithHttpInfo
     *
     * Get transactions
     *
     * @param  string $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  OneOfAccountParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  OneOfInt64Parameter $amount Filters transactions by amount (microtez). (optional)
     * @param  OneOfInt32Parameter $level Filters transactions by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  OneOfStringParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  OneOfJsonParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;. (optional)
     * @param  OneOfStringParameter $parameters **DEPRECATED**. Use &#x60;entrypoint&#x60; and &#x60;parameter&#x60; instead. (optional)
     * @param  OneOfBoolParameter $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  OneOfOperationStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TransactionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionsWithHttpInfo($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $level = null, $timestamp = null, $entrypoint = null, $parameter = null, $parameters = null, $has_internals = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null)
    {
        $request = $this->operationsGetTransactionsRequest($anyof, $initiator, $sender, $target, $amount, $level, $timestamp, $entrypoint, $parameter, $parameters, $has_internals, $status, $select, $sort, $offset, $limit, $micheline, $quote);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TransactionOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TransactionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TransactionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionsAsync
     *
     * Get transactions
     *
     * @param  string $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  OneOfAccountParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  OneOfInt64Parameter $amount Filters transactions by amount (microtez). (optional)
     * @param  OneOfInt32Parameter $level Filters transactions by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  OneOfStringParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  OneOfJsonParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;. (optional)
     * @param  OneOfStringParameter $parameters **DEPRECATED**. Use &#x60;entrypoint&#x60; and &#x60;parameter&#x60; instead. (optional)
     * @param  OneOfBoolParameter $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  OneOfOperationStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionsAsync($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $level = null, $timestamp = null, $entrypoint = null, $parameter = null, $parameters = null, $has_internals = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null)
    {
        return $this->operationsGetTransactionsAsyncWithHttpInfo($anyof, $initiator, $sender, $target, $amount, $level, $timestamp, $entrypoint, $parameter, $parameters, $has_internals, $status, $select, $sort, $offset, $limit, $micheline, $quote)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionsAsyncWithHttpInfo
     *
     * Get transactions
     *
     * @param  string $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  OneOfAccountParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  OneOfInt64Parameter $amount Filters transactions by amount (microtez). (optional)
     * @param  OneOfInt32Parameter $level Filters transactions by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  OneOfStringParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  OneOfJsonParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;. (optional)
     * @param  OneOfStringParameter $parameters **DEPRECATED**. Use &#x60;entrypoint&#x60; and &#x60;parameter&#x60; instead. (optional)
     * @param  OneOfBoolParameter $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  OneOfOperationStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionsAsyncWithHttpInfo($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $level = null, $timestamp = null, $entrypoint = null, $parameter = null, $parameters = null, $has_internals = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null)
    {
        $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
        $request = $this->operationsGetTransactionsRequest($anyof, $initiator, $sender, $target, $amount, $level, $timestamp, $entrypoint, $parameter, $parameters, $has_internals, $status, $select, $sort, $offset, $limit, $micheline, $quote);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactions'
     *
     * @param  string $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  OneOfAccountParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  OneOfAccountParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  OneOfAccountParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  OneOfInt64Parameter $amount Filters transactions by amount (microtez). (optional)
     * @param  OneOfInt32Parameter $level Filters transactions by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  OneOfStringParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  OneOfJsonParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;. (optional)
     * @param  OneOfStringParameter $parameters **DEPRECATED**. Use &#x60;entrypoint&#x60; and &#x60;parameter&#x60; instead. (optional)
     * @param  OneOfBoolParameter $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  OneOfOperationStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  OneOfSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  OneOfSortParameter $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  OneOfOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  OneOfMichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  OneOfSymbols $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionsRequest($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $level = null, $timestamp = null, $entrypoint = null, $parameter = null, $parameters = null, $has_internals = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null)
    {
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTransactions, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTransactions, must be bigger than or equal to 0.');
        }


        $resourcePath = '/v1/operations/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($anyof !== null) {
            if('form' === 'form' && is_array($anyof)) {
                foreach($anyof as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['anyof'] = $anyof;
            }
        }
        // query params
        if ($initiator !== null) {
            if('form' === 'form' && is_array($initiator)) {
                foreach($initiator as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['initiator'] = $initiator;
            }
        }
        // query params
        if ($sender !== null) {
            if('form' === 'form' && is_array($sender)) {
                foreach($sender as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sender'] = $sender;
            }
        }
        // query params
        if ($target !== null) {
            if('form' === 'form' && is_array($target)) {
                foreach($target as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['target'] = $target;
            }
        }
        // query params
        if ($amount !== null) {
            if('form' === 'form' && is_array($amount)) {
                foreach($amount as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['amount'] = $amount;
            }
        }
        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($entrypoint !== null) {
            if('form' === 'form' && is_array($entrypoint)) {
                foreach($entrypoint as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['entrypoint'] = $entrypoint;
            }
        }
        // query params
        if ($parameter !== null) {
            if('form' === 'form' && is_array($parameter)) {
                foreach($parameter as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['parameter'] = $parameter;
            }
        }
        // query params
        if ($parameters !== null) {
            if('form' === 'form' && is_array($parameters)) {
                foreach($parameters as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['parameters'] = $parameters;
            }
        }
        // query params
        if ($has_internals !== null) {
            if('form' === 'form' && is_array($has_internals)) {
                foreach($has_internals as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['hasInternals'] = $has_internals;
            }
        }
        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }
        // query params
        if ($select !== null) {
            if('form' === 'form' && is_array($select)) {
                foreach($select as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['select'] = $select;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($micheline !== null) {
            if('form' === 'form' && is_array($micheline)) {
                foreach($micheline as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['micheline'] = $micheline;
            }
        }
        // query params
        if ($quote !== null) {
            if('form' === 'form' && is_array($quote)) {
                foreach($quote as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['quote'] = $quote;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactionsCount
     *
     * Get transactions count
     *
     * @param  OneOfInt32Parameter $level Filters transactions by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetTransactionsCount($level = null, $timestamp = null, $status = null)
    {
        list($response) = $this->operationsGetTransactionsCountWithHttpInfo($level, $timestamp, $status);
        return $response;
    }

    /**
     * Operation operationsGetTransactionsCountWithHttpInfo
     *
     * Get transactions count
     *
     * @param  OneOfInt32Parameter $level Filters transactions by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionsCountWithHttpInfo($level = null, $timestamp = null, $status = null)
    {
        $request = $this->operationsGetTransactionsCountRequest($level, $timestamp, $status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionsCountAsync
     *
     * Get transactions count
     *
     * @param  OneOfInt32Parameter $level Filters transactions by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionsCountAsync($level = null, $timestamp = null, $status = null)
    {
        return $this->operationsGetTransactionsCountAsyncWithHttpInfo($level, $timestamp, $status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionsCountAsyncWithHttpInfo
     *
     * Get transactions count
     *
     * @param  OneOfInt32Parameter $level Filters transactions by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionsCountAsyncWithHttpInfo($level = null, $timestamp = null, $status = null)
    {
        $returnType = 'int';
        $request = $this->operationsGetTransactionsCountRequest($level, $timestamp, $status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactionsCount'
     *
     * @param  OneOfInt32Parameter $level Filters transactions by level. (optional)
     * @param  OneOfDateTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  OneOfOperationStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionsCountRequest($level = null, $timestamp = null, $status = null)
    {

        $resourcePath = '/v1/operations/transactions/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($level !== null) {
            if('form' === 'form' && is_array($level)) {
                foreach($level as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['level'] = $level;
            }
        }
        // query params
        if ($timestamp !== null) {
            if('form' === 'form' && is_array($timestamp)) {
                foreach($timestamp as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['timestamp'] = $timestamp;
            }
        }
        // query params
        if ($status !== null) {
            if('form' === 'form' && is_array($status)) {
                foreach($status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['status'] = $status;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
