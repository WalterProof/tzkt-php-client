<?php
/**
 * OperationsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Bzzhh\Tzkt
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * TzKT API
 *
 * # Introduction  TzKT is the most widely used tool in Tezos that provides you with convenient and flexible access to the Tezos blockchain data, processed and indexed by its own indexer.  You can fetch all historical data via REST API, or subscribe for real-time data via WebSocket API. TzKT was built by the joint efforts of the entire Tezos community  to help developers build more services and dapps on top of Tezos.  TzKT Indexer and API are [open-source](https://github.com/baking-bad/tzkt), so don't be afraid to depend on the third-party service, because you can always clone, build and run it yourself to have full control over all the components.  Feel free to contact us if you have any questions or feature requests. Your feedback is much appreciated!  - Discord: https://discord.gg/aG8XKuwsQd - Telegram: https://t.me/baking_bad_chat - Slack: https://tezos-dev.slack.com/archives/CV5NX7F2L - Twitter: https://twitter.com/TezosBakingBad - Email: hello@bakingbad.dev  And don't forget to star TzKT [on GitHub](https://github.com/baking-bad/tzkt) if you like it ðŸ˜Š  # Get Started  There are two API services provided for public use: - **Free TzKT API** with free anonymous access; - **TzKT Pro** with paid subscriptions with increased rate limits, off-chain data, extended support and business-level SLA.  You can find more details about differences between available tiers [here](https://tzkt.io/api).  ## Free TzKT API  Free-tier TzKT API is the best way to get started and explore available Tezos data and API functionality. It doesn't require authorization and is free for everyone and for both commercial and non-commercial use.  > #### Note: attribution required If you use free-tier TzKT API, you **must** mention it on your website or application by placing the label \"Powered by TzKT API\", or \"Built with TzKT API\", or \"Data provided by TzKT API\" with a direct link to [tzkt.io](https://tzkt.io).  It's available for the following Tezos networks with the following base URLs:  - Mainnet: `https://api.tzkt.io/` or `https://api.mainnet.tzkt.io/` ([view docs](https://api.tzkt.io)) - Ghostnet: `https://api.ghostnet.tzkt.io/` ([view docs](https://api.ghostnet.tzkt.io)) - Parisnet: `https://api.parisnet.tzkt.io/` ([view docs](https://api.parisnet.tzkt.io))  ### Sending Requests  To send a request to Free TzKT API you need literally nothing. Just take the base URL of the particular network (for example, Tezos mainnet: `https://api.tzkt.io`) and append the path of the particular endpoint (for example, chain's head: `/v1/head`), that's pretty much it:   ```bash curl https://api.tzkt.io/v1/head ```  Read through this documentation to explore available endpoints, query parameters (note, if you click on a query parameter, you will see available modes, such as `.eq`, `.in`, etc.) and response models. If you have any questions, do not hesitate to ask for support, Tezos community has always been very friendly! ðŸ˜‰  ### Rate Limits  Please, refer to https://tzkt.io/api to check relevant rate limits.  If you exceed the limit, the API will respond with `HTTP 429` status code.  ## TzKT Pro  TzKT Pro is intended for professional use, for those who seek for extended capabilities, performance, reliability and business-level SLA. TzKT Pro service is provided via paid subscriptions. Please, refer to [Pricing Plans](https://tzkt.io/api) to check available tiers.  It's available for the following Tezos networks with the following base URLs:  - Mainnet: `https://pro.tzkt.io/` ([view docs](https://api.tzkt.io)) - Testnets: *let us know if you need TzKT Pro for testnets*  ### Authorization  To access TzKT Pro you will need to authorize requests with your personal API key, that you will receive on your email after purchasing a subscription. This can be done by adding the query string parameter `?apikey={your_key}` or by adding the HTTP header `apikey: {your_key}`.  Note that you can have multiple API keys within a single subscription.  Keep your API keys private, do not publish it anywhere and do not hardcode it, especially in public repositories. If your key was compromised, just let us know and we will issue a new one.  Also note that passing the API key via HTTP headers is more secure, because in HTTPS headers are encrypted, but query string is not, so the key can be unintentionally exposed to third parties.  ### Sending Requests  Sending a request with the API key passed as a query string parameter:  ```bash curl https://pro.tzkt.io/v1/head?apikey={your_key} ```  Sending a request with the API key passed via an HTTP header:  ```bash curl https://pro.tzkt.io/v1/head \\     -H 'apikey: {your_key}' ```  ### Rate Limits  Please, refer to https://tzkt.io/api to check relevant rate limits for different pricing plans.  Also, TzKT Pro provides you with the additional HTTP headers to show the allowed limits, number of available requests and the time remaining (in seconds) until the quota is reset. Here's an example:  ``` RateLimit-Limit: 50 RateLimit-Remaining: 49 RateLimit-Reset: 1 ```  It also sends general information about your rate limits per second and per day:  ``` X-RateLimit-Limit-Second: 50 X-RateLimit-Remaining-Second: 49 X-RateLimit-Limit-Day: 3000000 X-RateLimit-Remaining-Day: 2994953 ```  If you exceed the limit, the API will respond with `HTTP 429` status code.
 *
 * The version of the OpenAPI document: 1.14.4
 * Contact: hello@bakingbad.dev
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Bzzhh\Tzkt\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Bzzhh\Tzkt\ApiException;
use Bzzhh\Tzkt\Configuration;
use Bzzhh\Tzkt\HeaderSelector;
use Bzzhh\Tzkt\ObjectSerializer;

/**
 * OperationsApi Class Doc Comment
 *
 * @category Class
 * @package  Bzzhh\Tzkt
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class OperationsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'operationsGetActivationByHash' => [
            'application/json',
        ],
        'operationsGetActivations' => [
            'application/json',
        ],
        'operationsGetActivationsCount' => [
            'application/json',
        ],
        'operationsGetAutostakingOps' => [
            'application/json',
        ],
        'operationsGetAutostakingOpsCount' => [
            'application/json',
        ],
        'operationsGetBaking' => [
            'application/json',
        ],
        'operationsGetBakingById' => [
            'application/json',
        ],
        'operationsGetBakingCount' => [
            'application/json',
        ],
        'operationsGetBallotByHash' => [
            'application/json',
        ],
        'operationsGetBallots' => [
            'application/json',
        ],
        'operationsGetBallotsCount' => [
            'application/json',
        ],
        'operationsGetByHash' => [
            'application/json',
        ],
        'operationsGetByHashCounter' => [
            'application/json',
        ],
        'operationsGetByHashCounterNonce' => [
            'application/json',
        ],
        'operationsGetDalPublishCommitmentOps' => [
            'application/json',
        ],
        'operationsGetDalPublishCommitmentOpsCount' => [
            'application/json',
        ],
        'operationsGetDelegationByHash' => [
            'application/json',
        ],
        'operationsGetDelegationStatus' => [
            'application/json',
        ],
        'operationsGetDelegations' => [
            'application/json',
        ],
        'operationsGetDelegationsCount' => [
            'application/json',
        ],
        'operationsGetDoubleBaking' => [
            'application/json',
        ],
        'operationsGetDoubleBakingByHash' => [
            'application/json',
        ],
        'operationsGetDoubleBakingCount' => [
            'application/json',
        ],
        'operationsGetDoubleEndorsing' => [
            'application/json',
        ],
        'operationsGetDoubleEndorsingByHash' => [
            'application/json',
        ],
        'operationsGetDoubleEndorsingCount' => [
            'application/json',
        ],
        'operationsGetDoublePreendorsing' => [
            'application/json',
        ],
        'operationsGetDoublePreendorsingByHash' => [
            'application/json',
        ],
        'operationsGetDoublePreendorsingCount' => [
            'application/json',
        ],
        'operationsGetDrainDelegateByHash' => [
            'application/json',
        ],
        'operationsGetDrainDelegateOps' => [
            'application/json',
        ],
        'operationsGetDrainDelegateOpsCount' => [
            'application/json',
        ],
        'operationsGetEndorsementByHash' => [
            'application/json',
        ],
        'operationsGetEndorsements' => [
            'application/json',
        ],
        'operationsGetEndorsementsCount' => [
            'application/json',
        ],
        'operationsGetEndorsingRewardById' => [
            'application/json',
        ],
        'operationsGetEndorsingRewards' => [
            'application/json',
        ],
        'operationsGetEndorsingRewardsCount' => [
            'application/json',
        ],
        'operationsGetIncreasePaidStorageByHash' => [
            'application/json',
        ],
        'operationsGetIncreasePaidStorageCount' => [
            'application/json',
        ],
        'operationsGetIncreasePaidStorageOps' => [
            'application/json',
        ],
        'operationsGetMigrationById' => [
            'application/json',
        ],
        'operationsGetMigrations' => [
            'application/json',
        ],
        'operationsGetMigrationsCount' => [
            'application/json',
        ],
        'operationsGetNonceRevelationByHash' => [
            'application/json',
        ],
        'operationsGetNonceRevelations' => [
            'application/json',
        ],
        'operationsGetNonceRevelationsCount' => [
            'application/json',
        ],
        'operationsGetOriginationByHash' => [
            'application/json',
        ],
        'operationsGetOriginationStatus' => [
            'application/json',
        ],
        'operationsGetOriginations' => [
            'application/json',
        ],
        'operationsGetOriginationsCount' => [
            'application/json',
        ],
        'operationsGetPreendorsementByHash' => [
            'application/json',
        ],
        'operationsGetPreendorsements' => [
            'application/json',
        ],
        'operationsGetPreendorsementsCount' => [
            'application/json',
        ],
        'operationsGetProposalByHash' => [
            'application/json',
        ],
        'operationsGetProposals' => [
            'application/json',
        ],
        'operationsGetProposalsCount' => [
            'application/json',
        ],
        'operationsGetRegisterConstantByHash' => [
            'application/json',
        ],
        'operationsGetRegisterConstantStatus' => [
            'application/json',
        ],
        'operationsGetRegisterConstants' => [
            'application/json',
        ],
        'operationsGetRegisterConstantsCount' => [
            'application/json',
        ],
        'operationsGetRevealByHash' => [
            'application/json',
        ],
        'operationsGetRevealStatus' => [
            'application/json',
        ],
        'operationsGetReveals' => [
            'application/json',
        ],
        'operationsGetRevealsCount' => [
            'application/json',
        ],
        'operationsGetRevelationPenalties' => [
            'application/json',
        ],
        'operationsGetRevelationPenaltiesCount' => [
            'application/json',
        ],
        'operationsGetRevelationPenaltyById' => [
            'application/json',
        ],
        'operationsGetSetDelegateParametersOps' => [
            'application/json',
        ],
        'operationsGetSetDelegateParametersOpsCount' => [
            'application/json',
        ],
        'operationsGetSetDepositsLimitByHash' => [
            'application/json',
        ],
        'operationsGetSetDepositsLimitStatus' => [
            'application/json',
        ],
        'operationsGetSetDepositsLimits' => [
            'application/json',
        ],
        'operationsGetSetDepositsLimitsCount' => [
            'application/json',
        ],
        'operationsGetSmartRollupAddMessagesOps' => [
            'application/json',
        ],
        'operationsGetSmartRollupAddMessagesOpsCount' => [
            'application/json',
        ],
        'operationsGetSmartRollupCementOps' => [
            'application/json',
        ],
        'operationsGetSmartRollupCementOpsCount' => [
            'application/json',
        ],
        'operationsGetSmartRollupExecuteOps' => [
            'application/json',
        ],
        'operationsGetSmartRollupExecuteOpsCount' => [
            'application/json',
        ],
        'operationsGetSmartRollupOriginateOps' => [
            'application/json',
        ],
        'operationsGetSmartRollupOriginateOpsCount' => [
            'application/json',
        ],
        'operationsGetSmartRollupPublishOps' => [
            'application/json',
        ],
        'operationsGetSmartRollupPublishOpsCount' => [
            'application/json',
        ],
        'operationsGetSmartRollupRecoverBondOps' => [
            'application/json',
        ],
        'operationsGetSmartRollupRecoverBondOpsCount' => [
            'application/json',
        ],
        'operationsGetSmartRollupRefuteOps' => [
            'application/json',
        ],
        'operationsGetSmartRollupRefuteOpsCount' => [
            'application/json',
        ],
        'operationsGetStakingOps' => [
            'application/json',
        ],
        'operationsGetStakingOpsCount' => [
            'application/json',
        ],
        'operationsGetStatus' => [
            'application/json',
        ],
        'operationsGetTransactionByHash' => [
            'application/json',
        ],
        'operationsGetTransactionByHashCounter' => [
            'application/json',
        ],
        'operationsGetTransactionByHashCounterNonce' => [
            'application/json',
        ],
        'operationsGetTransactionStatus' => [
            'application/json',
        ],
        'operationsGetTransactions' => [
            'application/json',
        ],
        'operationsGetTransactionsCount' => [
            'application/json',
        ],
        'operationsGetTransferTicketOps' => [
            'application/json',
        ],
        'operationsGetTransferTicketOpsByHash' => [
            'application/json',
        ],
        'operationsGetTransferTicketOpsCount' => [
            'application/json',
        ],
        'operationsGetTransferTicketStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupCommitOps' => [
            'application/json',
        ],
        'operationsGetTxRollupCommitOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupCommitOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupCommitStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupDispatchTicketsOps' => [
            'application/json',
        ],
        'operationsGetTxRollupDispatchTicketsOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupDispatchTicketsOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupDispatchTicketsStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupFinalizeCommitmentOps' => [
            'application/json',
        ],
        'operationsGetTxRollupFinalizeCommitmentOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupFinalizeCommitmentOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupFinalizeCommitmentStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupOriginationOps' => [
            'application/json',
        ],
        'operationsGetTxRollupOriginationOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupOriginationOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupOriginationStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupRejectionOps' => [
            'application/json',
        ],
        'operationsGetTxRollupRejectionOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupRejectionOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupRejectionStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupRemoveCommitmentOps' => [
            'application/json',
        ],
        'operationsGetTxRollupRemoveCommitmentOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupRemoveCommitmentOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupRemoveCommitmentStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupReturnBondOps' => [
            'application/json',
        ],
        'operationsGetTxRollupReturnBondOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupReturnBondOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupReturnBondStatus' => [
            'application/json',
        ],
        'operationsGetTxRollupSubmitBatchOps' => [
            'application/json',
        ],
        'operationsGetTxRollupSubmitBatchOpsByHash' => [
            'application/json',
        ],
        'operationsGetTxRollupSubmitBatchOpsCount' => [
            'application/json',
        ],
        'operationsGetTxRollupSubmitBatchStatus' => [
            'application/json',
        ],
        'operationsGetUpdateConsensusKeyByHash' => [
            'application/json',
        ],
        'operationsGetUpdateConsensusKeyOps' => [
            'application/json',
        ],
        'operationsGetUpdateConsensusKeyOpsCount' => [
            'application/json',
        ],
        'operationsGetVdfRevelationByHash' => [
            'application/json',
        ],
        'operationsGetVdfRevelations' => [
            'application/json',
        ],
        'operationsGetVdfRevelationsCount' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation operationsGetActivationByHash
     *
     * Get activation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\ActivationOperation[]
     */
    public function operationsGetActivationByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetActivationByHash'][0])
    {
        list($response) = $this->operationsGetActivationByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetActivationByHashWithHttpInfo
     *
     * Get activation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\ActivationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetActivationByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetActivationByHash'][0])
    {
        $request = $this->operationsGetActivationByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\ActivationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\ActivationOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\ActivationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\ActivationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\ActivationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetActivationByHashAsync
     *
     * Get activation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetActivationByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetActivationByHash'][0])
    {
        return $this->operationsGetActivationByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetActivationByHashAsyncWithHttpInfo
     *
     * Get activation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetActivationByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetActivationByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\ActivationOperation[]';
        $request = $this->operationsGetActivationByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetActivationByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetActivationByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetActivationByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetActivationByHash'
            );
        }



        $resourcePath = '/v1/operations/activations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetActivations
     *
     * Get activations
     *
     * @param  AccountsGetDelegateParameter $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters activations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters activations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivations'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\ActivationOperation[]
     */
    public function operationsGetActivations($account = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetActivations'][0])
    {
        list($response) = $this->operationsGetActivationsWithHttpInfo($account, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetActivationsWithHttpInfo
     *
     * Get activations
     *
     * @param  AccountsGetDelegateParameter $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters activations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters activations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivations'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\ActivationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetActivationsWithHttpInfo($account = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetActivations'][0])
    {
        $request = $this->operationsGetActivationsRequest($account, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\ActivationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\ActivationOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\ActivationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\ActivationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\ActivationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetActivationsAsync
     *
     * Get activations
     *
     * @param  AccountsGetDelegateParameter $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters activations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters activations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetActivationsAsync($account = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetActivations'][0])
    {
        return $this->operationsGetActivationsAsyncWithHttpInfo($account, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetActivationsAsyncWithHttpInfo
     *
     * Get activations
     *
     * @param  AccountsGetDelegateParameter $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters activations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters activations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetActivationsAsyncWithHttpInfo($account = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetActivations'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\ActivationOperation[]';
        $request = $this->operationsGetActivationsRequest($account, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetActivations'
     *
     * @param  AccountsGetDelegateParameter $account Filters activations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters activations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters activations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts activations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;balance&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetActivationsRequest($account = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetActivations'][0])
    {







        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetActivations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetActivations, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/activations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account,
            'account', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetActivationsCount
     *
     * Get activations count
     *
     * @param  AccountsGetIdParameter $level Filters activations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters activations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetActivationsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetActivationsCount'][0])
    {
        list($response) = $this->operationsGetActivationsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetActivationsCountWithHttpInfo
     *
     * Get activations count
     *
     * @param  AccountsGetIdParameter $level Filters activations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters activations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetActivationsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetActivationsCount'][0])
    {
        $request = $this->operationsGetActivationsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetActivationsCountAsync
     *
     * Get activations count
     *
     * @param  AccountsGetIdParameter $level Filters activations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters activations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetActivationsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetActivationsCount'][0])
    {
        return $this->operationsGetActivationsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetActivationsCountAsyncWithHttpInfo
     *
     * Get activations count
     *
     * @param  AccountsGetIdParameter $level Filters activations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters activations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetActivationsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetActivationsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetActivationsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetActivationsCount'
     *
     * @param  AccountsGetIdParameter $level Filters activations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters activations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetActivationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetActivationsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetActivationsCount'][0])
    {




        $resourcePath = '/v1/operations/activations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetAutostakingOps
     *
     * Get autostaking ops
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\AutostakingOperation[]
     */
    public function operationsGetAutostakingOps($id = null, $level = null, $timestamp = null, $baker = null, $action = null, $amount = null, $staking_updates_count = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetAutostakingOps'][0])
    {
        list($response) = $this->operationsGetAutostakingOpsWithHttpInfo($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetAutostakingOpsWithHttpInfo
     *
     * Get autostaking ops
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\AutostakingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetAutostakingOpsWithHttpInfo($id = null, $level = null, $timestamp = null, $baker = null, $action = null, $amount = null, $staking_updates_count = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetAutostakingOps'][0])
    {
        $request = $this->operationsGetAutostakingOpsRequest($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\AutostakingOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\AutostakingOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\AutostakingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\AutostakingOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\AutostakingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetAutostakingOpsAsync
     *
     * Get autostaking ops
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetAutostakingOpsAsync($id = null, $level = null, $timestamp = null, $baker = null, $action = null, $amount = null, $staking_updates_count = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetAutostakingOps'][0])
    {
        return $this->operationsGetAutostakingOpsAsyncWithHttpInfo($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetAutostakingOpsAsyncWithHttpInfo
     *
     * Get autostaking ops
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetAutostakingOpsAsyncWithHttpInfo($id = null, $level = null, $timestamp = null, $baker = null, $action = null, $amount = null, $staking_updates_count = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetAutostakingOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\AutostakingOperation[]';
        $request = $this->operationsGetAutostakingOpsRequest($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetAutostakingOps'
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetAutostakingOpsRequest($id = null, $level = null, $timestamp = null, $baker = null, $action = null, $amount = null, $staking_updates_count = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetAutostakingOps'][0])
    {










        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetAutostakingOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetAutostakingOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/autostaking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action,
            'action', // param base name
            'OneOfStakingActionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $staking_updates_count,
            'stakingUpdatesCount', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetAutostakingOpsCount
     *
     * Get autostaking ops count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetAutostakingOpsCount($id = null, $level = null, $timestamp = null, $baker = null, $action = null, $amount = null, $staking_updates_count = null, string $contentType = self::contentTypes['operationsGetAutostakingOpsCount'][0])
    {
        list($response) = $this->operationsGetAutostakingOpsCountWithHttpInfo($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetAutostakingOpsCountWithHttpInfo
     *
     * Get autostaking ops count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetAutostakingOpsCountWithHttpInfo($id = null, $level = null, $timestamp = null, $baker = null, $action = null, $amount = null, $staking_updates_count = null, string $contentType = self::contentTypes['operationsGetAutostakingOpsCount'][0])
    {
        $request = $this->operationsGetAutostakingOpsCountRequest($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetAutostakingOpsCountAsync
     *
     * Get autostaking ops count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetAutostakingOpsCountAsync($id = null, $level = null, $timestamp = null, $baker = null, $action = null, $amount = null, $staking_updates_count = null, string $contentType = self::contentTypes['operationsGetAutostakingOpsCount'][0])
    {
        return $this->operationsGetAutostakingOpsCountAsyncWithHttpInfo($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetAutostakingOpsCountAsyncWithHttpInfo
     *
     * Get autostaking ops count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetAutostakingOpsCountAsyncWithHttpInfo($id = null, $level = null, $timestamp = null, $baker = null, $action = null, $amount = null, $staking_updates_count = null, string $contentType = self::contentTypes['operationsGetAutostakingOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetAutostakingOpsCountRequest($id, $level, $timestamp, $baker, $action, $amount, $staking_updates_count, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetAutostakingOpsCount'
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by level of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the block where the operation happened.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by autostaking action.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $amount Filter by amount.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $staking_updates_count Filter by number of staking updates.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetAutostakingOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetAutostakingOpsCountRequest($id = null, $level = null, $timestamp = null, $baker = null, $action = null, $amount = null, $staking_updates_count = null, string $contentType = self::contentTypes['operationsGetAutostakingOpsCount'][0])
    {









        $resourcePath = '/v1/operations/autostaking/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action,
            'action', // param base name
            'OneOfStakingActionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $staking_updates_count,
            'stakingUpdatesCount', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBaking
     *
     * Get baking
     *
     * @param  AccountsGetDelegateParameter $baker [DEPRECATED] (optional)
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.proposer.producer&#x3D;tz1...&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $proposer Filters by block proposer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $producer Filters by block producer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBaking'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\BakingOperation[]
     */
    public function operationsGetBaking($baker = null, $anyof = null, $proposer = null, $producer = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetBaking'][0])
    {
        list($response) = $this->operationsGetBakingWithHttpInfo($baker, $anyof, $proposer, $producer, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetBakingWithHttpInfo
     *
     * Get baking
     *
     * @param  AccountsGetDelegateParameter $baker [DEPRECATED] (optional)
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.proposer.producer&#x3D;tz1...&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $proposer Filters by block proposer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $producer Filters by block producer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBaking'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\BakingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBakingWithHttpInfo($baker = null, $anyof = null, $proposer = null, $producer = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetBaking'][0])
    {
        $request = $this->operationsGetBakingRequest($baker, $anyof, $proposer, $producer, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\BakingOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\BakingOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\BakingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\BakingOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\BakingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBakingAsync
     *
     * Get baking
     *
     * @param  AccountsGetDelegateParameter $baker [DEPRECATED] (optional)
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.proposer.producer&#x3D;tz1...&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $proposer Filters by block proposer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $producer Filters by block producer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBaking'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBakingAsync($baker = null, $anyof = null, $proposer = null, $producer = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetBaking'][0])
    {
        return $this->operationsGetBakingAsyncWithHttpInfo($baker, $anyof, $proposer, $producer, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBakingAsyncWithHttpInfo
     *
     * Get baking
     *
     * @param  AccountsGetDelegateParameter $baker [DEPRECATED] (optional)
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.proposer.producer&#x3D;tz1...&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $proposer Filters by block proposer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $producer Filters by block producer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBaking'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBakingAsyncWithHttpInfo($baker = null, $anyof = null, $proposer = null, $producer = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetBaking'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\BakingOperation[]';
        $request = $this->operationsGetBakingRequest($baker, $anyof, $proposer, $producer, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBaking'
     *
     * @param  AccountsGetDelegateParameter $baker [DEPRECATED] (optional)
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.proposer.producer&#x3D;tz1...&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $proposer Filters by block proposer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $producer Filters by block producer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBaking'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBakingRequest($baker = null, $anyof = null, $proposer = null, $producer = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetBaking'][0])
    {











        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetBaking, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetBaking, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/baking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $proposer,
            'proposer', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $producer,
            'producer', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBakingById
     *
     * Get baking by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingById'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\BakingOperation
     */
    public function operationsGetBakingById($id, $quote = null, string $contentType = self::contentTypes['operationsGetBakingById'][0])
    {
        list($response) = $this->operationsGetBakingByIdWithHttpInfo($id, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetBakingByIdWithHttpInfo
     *
     * Get baking by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingById'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\BakingOperation, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBakingByIdWithHttpInfo($id, $quote = null, string $contentType = self::contentTypes['operationsGetBakingById'][0])
    {
        $request = $this->operationsGetBakingByIdRequest($id, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\BakingOperation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\BakingOperation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\BakingOperation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\BakingOperation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\BakingOperation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBakingByIdAsync
     *
     * Get baking by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBakingByIdAsync($id, $quote = null, string $contentType = self::contentTypes['operationsGetBakingById'][0])
    {
        return $this->operationsGetBakingByIdAsyncWithHttpInfo($id, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBakingByIdAsyncWithHttpInfo
     *
     * Get baking by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBakingByIdAsyncWithHttpInfo($id, $quote = null, string $contentType = self::contentTypes['operationsGetBakingById'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\BakingOperation';
        $request = $this->operationsGetBakingByIdRequest($id, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBakingById'
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBakingByIdRequest($id, $quote = null, string $contentType = self::contentTypes['operationsGetBakingById'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling operationsGetBakingById'
            );
        }



        $resourcePath = '/v1/operations/baking/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBakingCount
     *
     * Get baking count
     *
     * @param  AccountsGetIdParameter $level Filters baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetBakingCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetBakingCount'][0])
    {
        list($response) = $this->operationsGetBakingCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetBakingCountWithHttpInfo
     *
     * Get baking count
     *
     * @param  AccountsGetIdParameter $level Filters baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBakingCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetBakingCount'][0])
    {
        $request = $this->operationsGetBakingCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBakingCountAsync
     *
     * Get baking count
     *
     * @param  AccountsGetIdParameter $level Filters baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBakingCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetBakingCount'][0])
    {
        return $this->operationsGetBakingCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBakingCountAsyncWithHttpInfo
     *
     * Get baking count
     *
     * @param  AccountsGetIdParameter $level Filters baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBakingCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetBakingCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetBakingCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBakingCount'
     *
     * @param  AccountsGetIdParameter $level Filters baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBakingCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBakingCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetBakingCount'][0])
    {




        $resourcePath = '/v1/operations/baking/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBallotByHash
     *
     * Get ballot by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\BallotOperation[]
     */
    public function operationsGetBallotByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetBallotByHash'][0])
    {
        list($response) = $this->operationsGetBallotByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetBallotByHashWithHttpInfo
     *
     * Get ballot by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\BallotOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBallotByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetBallotByHash'][0])
    {
        $request = $this->operationsGetBallotByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\BallotOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\BallotOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\BallotOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\BallotOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\BallotOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBallotByHashAsync
     *
     * Get ballot by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBallotByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetBallotByHash'][0])
    {
        return $this->operationsGetBallotByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBallotByHashAsyncWithHttpInfo
     *
     * Get ballot by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBallotByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetBallotByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\BallotOperation[]';
        $request = $this->operationsGetBallotByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBallotByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBallotByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetBallotByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetBallotByHash'
            );
        }



        $resourcePath = '/v1/operations/ballots/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBallots
     *
     * Get ballots
     *
     * @param  AccountsGetDelegateParameter $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters ballots by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters ballots by timestamp. (optional)
     * @param  AccountsGetIdParameter $epoch Filters ballots by voting epoch. (optional)
     * @param  AccountsGetIdParameter $period Filters ballots by voting period. (optional)
     * @param  OperationsGetBallotsProposalParameter $proposal Filters ballots by proposal hash. (optional)
     * @param  OperationsGetBallotsVoteParameter $vote Filters ballots by vote (&#x60;yay&#x60;, &#x60;nay&#x60;, &#x60;pass&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallots'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\BallotOperation[]
     */
    public function operationsGetBallots($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $vote = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetBallots'][0])
    {
        list($response) = $this->operationsGetBallotsWithHttpInfo($delegate, $level, $timestamp, $epoch, $period, $proposal, $vote, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetBallotsWithHttpInfo
     *
     * Get ballots
     *
     * @param  AccountsGetDelegateParameter $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters ballots by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters ballots by timestamp. (optional)
     * @param  AccountsGetIdParameter $epoch Filters ballots by voting epoch. (optional)
     * @param  AccountsGetIdParameter $period Filters ballots by voting period. (optional)
     * @param  OperationsGetBallotsProposalParameter $proposal Filters ballots by proposal hash. (optional)
     * @param  OperationsGetBallotsVoteParameter $vote Filters ballots by vote (&#x60;yay&#x60;, &#x60;nay&#x60;, &#x60;pass&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallots'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\BallotOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBallotsWithHttpInfo($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $vote = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetBallots'][0])
    {
        $request = $this->operationsGetBallotsRequest($delegate, $level, $timestamp, $epoch, $period, $proposal, $vote, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\BallotOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\BallotOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\BallotOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\BallotOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\BallotOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBallotsAsync
     *
     * Get ballots
     *
     * @param  AccountsGetDelegateParameter $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters ballots by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters ballots by timestamp. (optional)
     * @param  AccountsGetIdParameter $epoch Filters ballots by voting epoch. (optional)
     * @param  AccountsGetIdParameter $period Filters ballots by voting period. (optional)
     * @param  OperationsGetBallotsProposalParameter $proposal Filters ballots by proposal hash. (optional)
     * @param  OperationsGetBallotsVoteParameter $vote Filters ballots by vote (&#x60;yay&#x60;, &#x60;nay&#x60;, &#x60;pass&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallots'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBallotsAsync($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $vote = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetBallots'][0])
    {
        return $this->operationsGetBallotsAsyncWithHttpInfo($delegate, $level, $timestamp, $epoch, $period, $proposal, $vote, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBallotsAsyncWithHttpInfo
     *
     * Get ballots
     *
     * @param  AccountsGetDelegateParameter $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters ballots by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters ballots by timestamp. (optional)
     * @param  AccountsGetIdParameter $epoch Filters ballots by voting epoch. (optional)
     * @param  AccountsGetIdParameter $period Filters ballots by voting period. (optional)
     * @param  OperationsGetBallotsProposalParameter $proposal Filters ballots by proposal hash. (optional)
     * @param  OperationsGetBallotsVoteParameter $vote Filters ballots by vote (&#x60;yay&#x60;, &#x60;nay&#x60;, &#x60;pass&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallots'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBallotsAsyncWithHttpInfo($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $vote = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetBallots'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\BallotOperation[]';
        $request = $this->operationsGetBallotsRequest($delegate, $level, $timestamp, $epoch, $period, $proposal, $vote, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBallots'
     *
     * @param  AccountsGetDelegateParameter $delegate Filters ballots by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters ballots by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters ballots by timestamp. (optional)
     * @param  AccountsGetIdParameter $epoch Filters ballots by voting epoch. (optional)
     * @param  AccountsGetIdParameter $period Filters ballots by voting period. (optional)
     * @param  OperationsGetBallotsProposalParameter $proposal Filters ballots by proposal hash. (optional)
     * @param  OperationsGetBallotsVoteParameter $vote Filters ballots by vote (&#x60;yay&#x60;, &#x60;nay&#x60;, &#x60;pass&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts ballots by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallots'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBallotsRequest($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $vote = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetBallots'][0])
    {











        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetBallots, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetBallots, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/ballots';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delegate,
            'delegate', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $epoch,
            'epoch', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period,
            'period', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $proposal,
            'proposal', // param base name
            'OneOfProtocolParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vote,
            'vote', // param base name
            'OneOfVoteParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetBallotsCount
     *
     * Get ballots count
     *
     * @param  AccountsGetIdParameter $level Filters ballot operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters ballot operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetBallotsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetBallotsCount'][0])
    {
        list($response) = $this->operationsGetBallotsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetBallotsCountWithHttpInfo
     *
     * Get ballots count
     *
     * @param  AccountsGetIdParameter $level Filters ballot operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters ballot operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetBallotsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetBallotsCount'][0])
    {
        $request = $this->operationsGetBallotsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetBallotsCountAsync
     *
     * Get ballots count
     *
     * @param  AccountsGetIdParameter $level Filters ballot operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters ballot operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBallotsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetBallotsCount'][0])
    {
        return $this->operationsGetBallotsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetBallotsCountAsyncWithHttpInfo
     *
     * Get ballots count
     *
     * @param  AccountsGetIdParameter $level Filters ballot operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters ballot operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetBallotsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetBallotsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetBallotsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetBallotsCount'
     *
     * @param  AccountsGetIdParameter $level Filters ballot operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters ballot operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetBallotsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetBallotsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetBallotsCount'][0])
    {




        $resourcePath = '/v1/operations/ballots/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetByHash
     *
     * Get operations by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\Operation[]
     */
    public function operationsGetByHash($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHash'][0])
    {
        list($response) = $this->operationsGetByHashWithHttpInfo($hash, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetByHashWithHttpInfo
     *
     * Get operations by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\Operation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetByHashWithHttpInfo($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHash'][0])
    {
        $request = $this->operationsGetByHashRequest($hash, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\Operation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\Operation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\Operation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\Operation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\Operation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetByHashAsync
     *
     * Get operations by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetByHashAsync($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHash'][0])
    {
        return $this->operationsGetByHashAsyncWithHttpInfo($hash, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetByHashAsyncWithHttpInfo
     *
     * Get operations by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetByHashAsyncWithHttpInfo($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\Operation[]';
        $request = $this->operationsGetByHashRequest($hash, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetByHashRequest($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetByHash'
            );
        }




        $resourcePath = '/v1/operations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetByHashCounter
     *
     * Get operations by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounter'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\Operation[]
     */
    public function operationsGetByHashCounter($hash, $counter, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHashCounter'][0])
    {
        list($response) = $this->operationsGetByHashCounterWithHttpInfo($hash, $counter, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetByHashCounterWithHttpInfo
     *
     * Get operations by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounter'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\Operation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetByHashCounterWithHttpInfo($hash, $counter, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHashCounter'][0])
    {
        $request = $this->operationsGetByHashCounterRequest($hash, $counter, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\Operation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\Operation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\Operation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\Operation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\Operation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetByHashCounterAsync
     *
     * Get operations by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetByHashCounterAsync($hash, $counter, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHashCounter'][0])
    {
        return $this->operationsGetByHashCounterAsyncWithHttpInfo($hash, $counter, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetByHashCounterAsyncWithHttpInfo
     *
     * Get operations by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetByHashCounterAsyncWithHttpInfo($hash, $counter, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHashCounter'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\Operation[]';
        $request = $this->operationsGetByHashCounterRequest($hash, $counter, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetByHashCounter'
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetByHashCounterRequest($hash, $counter, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHashCounter'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetByHashCounter'
            );
        }

        // verify the required parameter 'counter' is set
        if ($counter === null || (is_array($counter) && count($counter) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $counter when calling operationsGetByHashCounter'
            );
        }




        $resourcePath = '/v1/operations/{hash}/{counter}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }
        // path params
        if ($counter !== null) {
            $resourcePath = str_replace(
                '{' . 'counter' . '}',
                ObjectSerializer::toPathValue($counter),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetByHashCounterNonce
     *
     * Get operations by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\Operation[]
     */
    public function operationsGetByHashCounterNonce($hash, $counter, $nonce, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHashCounterNonce'][0])
    {
        list($response) = $this->operationsGetByHashCounterNonceWithHttpInfo($hash, $counter, $nonce, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetByHashCounterNonceWithHttpInfo
     *
     * Get operations by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\Operation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetByHashCounterNonceWithHttpInfo($hash, $counter, $nonce, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHashCounterNonce'][0])
    {
        $request = $this->operationsGetByHashCounterNonceRequest($hash, $counter, $nonce, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\Operation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\Operation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\Operation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\Operation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\Operation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetByHashCounterNonceAsync
     *
     * Get operations by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetByHashCounterNonceAsync($hash, $counter, $nonce, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHashCounterNonce'][0])
    {
        return $this->operationsGetByHashCounterNonceAsyncWithHttpInfo($hash, $counter, $nonce, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetByHashCounterNonceAsyncWithHttpInfo
     *
     * Get operations by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetByHashCounterNonceAsyncWithHttpInfo($hash, $counter, $nonce, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHashCounterNonce'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\Operation[]';
        $request = $this->operationsGetByHashCounterNonceRequest($hash, $counter, $nonce, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetByHashCounterNonce'
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetByHashCounterNonceRequest($hash, $counter, $nonce, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetByHashCounterNonce'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetByHashCounterNonce'
            );
        }

        // verify the required parameter 'counter' is set
        if ($counter === null || (is_array($counter) && count($counter) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $counter when calling operationsGetByHashCounterNonce'
            );
        }

        // verify the required parameter 'nonce' is set
        if ($nonce === null || (is_array($nonce) && count($nonce) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nonce when calling operationsGetByHashCounterNonce'
            );
        }




        $resourcePath = '/v1/operations/{hash}/{counter}/{nonce}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }
        // path params
        if ($counter !== null) {
            $resourcePath = str_replace(
                '{' . 'counter' . '}',
                ObjectSerializer::toPathValue($counter),
                $resourcePath
            );
        }
        // path params
        if ($nonce !== null) {
            $resourcePath = str_replace(
                '{' . 'nonce' . '}',
                ObjectSerializer::toPathValue($nonce),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDalPublishCommitmentOps
     *
     * Get dal_publish_commitment ops
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DalPublishCommitmentOperation[]
     */
    public function operationsGetDalPublishCommitmentOps($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOps'][0])
    {
        list($response) = $this->operationsGetDalPublishCommitmentOpsWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDalPublishCommitmentOpsWithHttpInfo
     *
     * Get dal_publish_commitment ops
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DalPublishCommitmentOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDalPublishCommitmentOpsWithHttpInfo($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOps'][0])
    {
        $request = $this->operationsGetDalPublishCommitmentOpsRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DalPublishCommitmentOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\DalPublishCommitmentOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DalPublishCommitmentOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DalPublishCommitmentOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DalPublishCommitmentOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDalPublishCommitmentOpsAsync
     *
     * Get dal_publish_commitment ops
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDalPublishCommitmentOpsAsync($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOps'][0])
    {
        return $this->operationsGetDalPublishCommitmentOpsAsyncWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDalPublishCommitmentOpsAsyncWithHttpInfo
     *
     * Get dal_publish_commitment ops
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDalPublishCommitmentOpsAsyncWithHttpInfo($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\DalPublishCommitmentOperation[]';
        $request = $this->operationsGetDalPublishCommitmentOpsRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDalPublishCommitmentOps'
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDalPublishCommitmentOpsRequest($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOps'][0])
    {










        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDalPublishCommitmentOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDalPublishCommitmentOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/dal_publish_commitment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDalPublishCommitmentOpsCount
     *
     * Get dal_publish_commitment ops count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetDalPublishCommitmentOpsCount($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOpsCount'][0])
    {
        list($response) = $this->operationsGetDalPublishCommitmentOpsCountWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDalPublishCommitmentOpsCountWithHttpInfo
     *
     * Get dal_publish_commitment ops count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDalPublishCommitmentOpsCountWithHttpInfo($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOpsCount'][0])
    {
        $request = $this->operationsGetDalPublishCommitmentOpsCountRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDalPublishCommitmentOpsCountAsync
     *
     * Get dal_publish_commitment ops count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDalPublishCommitmentOpsCountAsync($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOpsCount'][0])
    {
        return $this->operationsGetDalPublishCommitmentOpsCountAsyncWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDalPublishCommitmentOpsCountAsyncWithHttpInfo
     *
     * Get dal_publish_commitment ops count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDalPublishCommitmentOpsCountAsyncWithHttpInfo($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetDalPublishCommitmentOpsCountRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDalPublishCommitmentOpsCount'
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDalPublishCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDalPublishCommitmentOpsCountRequest($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetDalPublishCommitmentOpsCount'][0])
    {









        $resourcePath = '/v1/operations/dal_publish_commitment/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDelegationByHash
     *
     * Get delegation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DelegationOperation[]
     */
    public function operationsGetDelegationByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDelegationByHash'][0])
    {
        list($response) = $this->operationsGetDelegationByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDelegationByHashWithHttpInfo
     *
     * Get delegation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DelegationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDelegationByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDelegationByHash'][0])
    {
        $request = $this->operationsGetDelegationByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DelegationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\DelegationOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DelegationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DelegationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DelegationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDelegationByHashAsync
     *
     * Get delegation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDelegationByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDelegationByHash'][0])
    {
        return $this->operationsGetDelegationByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDelegationByHashAsyncWithHttpInfo
     *
     * Get delegation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDelegationByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDelegationByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\DelegationOperation[]';
        $request = $this->operationsGetDelegationByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDelegationByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDelegationByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDelegationByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDelegationByHash'
            );
        }



        $resourcePath = '/v1/operations/delegations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDelegationStatus
     *
     * Get delegation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetDelegationStatus($hash, string $contentType = self::contentTypes['operationsGetDelegationStatus'][0])
    {
        list($response) = $this->operationsGetDelegationStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDelegationStatusWithHttpInfo
     *
     * Get delegation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDelegationStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetDelegationStatus'][0])
    {
        $request = $this->operationsGetDelegationStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDelegationStatusAsync
     *
     * Get delegation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDelegationStatusAsync($hash, string $contentType = self::contentTypes['operationsGetDelegationStatus'][0])
    {
        return $this->operationsGetDelegationStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDelegationStatusAsyncWithHttpInfo
     *
     * Get delegation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDelegationStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetDelegationStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetDelegationStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDelegationStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDelegationStatusRequest($hash, string $contentType = self::contentTypes['operationsGetDelegationStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDelegationStatus'
            );
        }


        $resourcePath = '/v1/operations/delegations/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDelegations
     *
     * Get delegations
     *
     * @param  BlocksGetAnyofParameter $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters delegations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegations'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DelegationOperation[]
     */
    public function operationsGetDelegations($anyof = null, $initiator = null, $sender = null, $prev_delegate = null, $new_delegate = null, $id = null, $level = null, $timestamp = null, $sender_code_hash = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDelegations'][0])
    {
        list($response) = $this->operationsGetDelegationsWithHttpInfo($anyof, $initiator, $sender, $prev_delegate, $new_delegate, $id, $level, $timestamp, $sender_code_hash, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDelegationsWithHttpInfo
     *
     * Get delegations
     *
     * @param  BlocksGetAnyofParameter $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters delegations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegations'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DelegationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDelegationsWithHttpInfo($anyof = null, $initiator = null, $sender = null, $prev_delegate = null, $new_delegate = null, $id = null, $level = null, $timestamp = null, $sender_code_hash = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDelegations'][0])
    {
        $request = $this->operationsGetDelegationsRequest($anyof, $initiator, $sender, $prev_delegate, $new_delegate, $id, $level, $timestamp, $sender_code_hash, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DelegationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\DelegationOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DelegationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DelegationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DelegationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDelegationsAsync
     *
     * Get delegations
     *
     * @param  BlocksGetAnyofParameter $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters delegations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDelegationsAsync($anyof = null, $initiator = null, $sender = null, $prev_delegate = null, $new_delegate = null, $id = null, $level = null, $timestamp = null, $sender_code_hash = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDelegations'][0])
    {
        return $this->operationsGetDelegationsAsyncWithHttpInfo($anyof, $initiator, $sender, $prev_delegate, $new_delegate, $id, $level, $timestamp, $sender_code_hash, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDelegationsAsyncWithHttpInfo
     *
     * Get delegations
     *
     * @param  BlocksGetAnyofParameter $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters delegations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDelegationsAsyncWithHttpInfo($anyof = null, $initiator = null, $sender = null, $prev_delegate = null, $new_delegate = null, $id = null, $level = null, $timestamp = null, $sender_code_hash = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDelegations'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\DelegationOperation[]';
        $request = $this->operationsGetDelegationsRequest($anyof, $initiator, $sender, $prev_delegate, $new_delegate, $id, $level, $timestamp, $sender_code_hash, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDelegations'
     *
     * @param  BlocksGetAnyofParameter $anyof Filters delegations by any of the specified fields. Example: &#x60;anyof.prevDelegate.newDelegate&#x3D;tz1...&#x60; will return operations where &#x60;prevDelegate&#x60; OR &#x60;newDelegate&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all delegations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters delegations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters delegations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;prevDelegate&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $prev_delegate Filters delegations by prev delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;newDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $new_delegate Filters delegations by new delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;prevDelegate&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters delegations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters delegations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts delegations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDelegationsRequest($anyof = null, $initiator = null, $sender = null, $prev_delegate = null, $new_delegate = null, $id = null, $level = null, $timestamp = null, $sender_code_hash = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDelegations'][0])
    {














        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDelegations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDelegations, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/delegations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $initiator,
            'initiator', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $prev_delegate,
            'prevDelegate', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $new_delegate,
            'newDelegate', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender_code_hash,
            'senderCodeHash', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDelegationsCount
     *
     * Get delegations count
     *
     * @param  AccountsGetIdParameter $level Filters delegations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetDelegationsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDelegationsCount'][0])
    {
        list($response) = $this->operationsGetDelegationsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDelegationsCountWithHttpInfo
     *
     * Get delegations count
     *
     * @param  AccountsGetIdParameter $level Filters delegations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDelegationsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDelegationsCount'][0])
    {
        $request = $this->operationsGetDelegationsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDelegationsCountAsync
     *
     * Get delegations count
     *
     * @param  AccountsGetIdParameter $level Filters delegations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDelegationsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDelegationsCount'][0])
    {
        return $this->operationsGetDelegationsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDelegationsCountAsyncWithHttpInfo
     *
     * Get delegations count
     *
     * @param  AccountsGetIdParameter $level Filters delegations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDelegationsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDelegationsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetDelegationsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDelegationsCount'
     *
     * @param  AccountsGetIdParameter $level Filters delegations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters delegations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDelegationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDelegationsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDelegationsCount'][0])
    {




        $resourcePath = '/v1/operations/delegations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleBaking
     *
     * Get double baking
     *
     * @param  BlocksGetAnyofParameter $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters double baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBaking'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DoubleBakingOperation[]
     */
    public function operationsGetDoubleBaking($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleBaking'][0])
    {
        list($response) = $this->operationsGetDoubleBakingWithHttpInfo($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoubleBakingWithHttpInfo
     *
     * Get double baking
     *
     * @param  BlocksGetAnyofParameter $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters double baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBaking'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DoubleBakingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleBakingWithHttpInfo($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleBaking'][0])
    {
        $request = $this->operationsGetDoubleBakingRequest($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DoubleBakingOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\DoubleBakingOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleBakingAsync
     *
     * Get double baking
     *
     * @param  BlocksGetAnyofParameter $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters double baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBaking'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleBakingAsync($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleBaking'][0])
    {
        return $this->operationsGetDoubleBakingAsyncWithHttpInfo($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleBakingAsyncWithHttpInfo
     *
     * Get double baking
     *
     * @param  BlocksGetAnyofParameter $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters double baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBaking'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleBakingAsyncWithHttpInfo($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleBaking'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]';
        $request = $this->operationsGetDoubleBakingRequest($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleBaking'
     *
     * @param  BlocksGetAnyofParameter $anyof Filters double baking operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters double baking operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters double baking operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters double baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts double baking operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBaking'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleBakingRequest($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleBaking'][0])
    {










        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoubleBaking, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoubleBaking, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/double_baking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $accuser,
            'accuser', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offender,
            'offender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleBakingByHash
     *
     * Get double baking by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DoubleBakingOperation[]
     */
    public function operationsGetDoubleBakingByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleBakingByHash'][0])
    {
        list($response) = $this->operationsGetDoubleBakingByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoubleBakingByHashWithHttpInfo
     *
     * Get double baking by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DoubleBakingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleBakingByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleBakingByHash'][0])
    {
        $request = $this->operationsGetDoubleBakingByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DoubleBakingOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\DoubleBakingOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleBakingByHashAsync
     *
     * Get double baking by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleBakingByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleBakingByHash'][0])
    {
        return $this->operationsGetDoubleBakingByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleBakingByHashAsyncWithHttpInfo
     *
     * Get double baking by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleBakingByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleBakingByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\DoubleBakingOperation[]';
        $request = $this->operationsGetDoubleBakingByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleBakingByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleBakingByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleBakingByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDoubleBakingByHash'
            );
        }



        $resourcePath = '/v1/operations/double_baking/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleBakingCount
     *
     * Get double baking count
     *
     * @param  AccountsGetIdParameter $level Filters double baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetDoubleBakingCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoubleBakingCount'][0])
    {
        list($response) = $this->operationsGetDoubleBakingCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoubleBakingCountWithHttpInfo
     *
     * Get double baking count
     *
     * @param  AccountsGetIdParameter $level Filters double baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleBakingCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoubleBakingCount'][0])
    {
        $request = $this->operationsGetDoubleBakingCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleBakingCountAsync
     *
     * Get double baking count
     *
     * @param  AccountsGetIdParameter $level Filters double baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleBakingCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoubleBakingCount'][0])
    {
        return $this->operationsGetDoubleBakingCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleBakingCountAsyncWithHttpInfo
     *
     * Get double baking count
     *
     * @param  AccountsGetIdParameter $level Filters double baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleBakingCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoubleBakingCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetDoubleBakingCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleBakingCount'
     *
     * @param  AccountsGetIdParameter $level Filters double baking operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double baking operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleBakingCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleBakingCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoubleBakingCount'][0])
    {




        $resourcePath = '/v1/operations/double_baking/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleEndorsing
     *
     * Get double endorsing
     *
     * @param  BlocksGetAnyofParameter $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters double endorsing operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsing'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]
     */
    public function operationsGetDoubleEndorsing($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsing'][0])
    {
        list($response) = $this->operationsGetDoubleEndorsingWithHttpInfo($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoubleEndorsingWithHttpInfo
     *
     * Get double endorsing
     *
     * @param  BlocksGetAnyofParameter $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters double endorsing operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsing'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DoubleEndorsingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleEndorsingWithHttpInfo($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsing'][0])
    {
        $request = $this->operationsGetDoubleEndorsingRequest($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleEndorsingAsync
     *
     * Get double endorsing
     *
     * @param  BlocksGetAnyofParameter $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters double endorsing operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleEndorsingAsync($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsing'][0])
    {
        return $this->operationsGetDoubleEndorsingAsyncWithHttpInfo($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleEndorsingAsyncWithHttpInfo
     *
     * Get double endorsing
     *
     * @param  BlocksGetAnyofParameter $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters double endorsing operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleEndorsingAsyncWithHttpInfo($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsing'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]';
        $request = $this->operationsGetDoubleEndorsingRequest($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleEndorsing'
     *
     * @param  BlocksGetAnyofParameter $anyof Filters double endorsing operations by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters double endorsing operations by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters double endorsing operations by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters double endorsing operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts double endorsing operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleEndorsingRequest($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsing'][0])
    {










        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoubleEndorsing, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoubleEndorsing, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/double_endorsing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $accuser,
            'accuser', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offender,
            'offender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleEndorsingByHash
     *
     * Get double endorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]
     */
    public function operationsGetDoubleEndorsingByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsingByHash'][0])
    {
        list($response) = $this->operationsGetDoubleEndorsingByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoubleEndorsingByHashWithHttpInfo
     *
     * Get double endorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DoubleEndorsingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleEndorsingByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsingByHash'][0])
    {
        $request = $this->operationsGetDoubleEndorsingByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleEndorsingByHashAsync
     *
     * Get double endorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleEndorsingByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsingByHash'][0])
    {
        return $this->operationsGetDoubleEndorsingByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleEndorsingByHashAsyncWithHttpInfo
     *
     * Get double endorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleEndorsingByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsingByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\DoubleEndorsingOperation[]';
        $request = $this->operationsGetDoubleEndorsingByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleEndorsingByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleEndorsingByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsingByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDoubleEndorsingByHash'
            );
        }



        $resourcePath = '/v1/operations/double_endorsing/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoubleEndorsingCount
     *
     * Get double endorsing count
     *
     * @param  AccountsGetIdParameter $level Filters double endorsing operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetDoubleEndorsingCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsingCount'][0])
    {
        list($response) = $this->operationsGetDoubleEndorsingCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoubleEndorsingCountWithHttpInfo
     *
     * Get double endorsing count
     *
     * @param  AccountsGetIdParameter $level Filters double endorsing operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoubleEndorsingCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsingCount'][0])
    {
        $request = $this->operationsGetDoubleEndorsingCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoubleEndorsingCountAsync
     *
     * Get double endorsing count
     *
     * @param  AccountsGetIdParameter $level Filters double endorsing operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleEndorsingCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsingCount'][0])
    {
        return $this->operationsGetDoubleEndorsingCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoubleEndorsingCountAsyncWithHttpInfo
     *
     * Get double endorsing count
     *
     * @param  AccountsGetIdParameter $level Filters double endorsing operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoubleEndorsingCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsingCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetDoubleEndorsingCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoubleEndorsingCount'
     *
     * @param  AccountsGetIdParameter $level Filters double endorsing operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters double endorsing operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoubleEndorsingCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoubleEndorsingCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoubleEndorsingCount'][0])
    {




        $resourcePath = '/v1/operations/double_endorsing/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoublePreendorsing
     *
     * Get double preendorsing
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsing'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DoublePreendorsingOperation[]
     */
    public function operationsGetDoublePreendorsing($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsing'][0])
    {
        list($response) = $this->operationsGetDoublePreendorsingWithHttpInfo($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoublePreendorsingWithHttpInfo
     *
     * Get double preendorsing
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsing'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DoublePreendorsingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoublePreendorsingWithHttpInfo($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsing'][0])
    {
        $request = $this->operationsGetDoublePreendorsingRequest($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DoublePreendorsingOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\DoublePreendorsingOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DoublePreendorsingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DoublePreendorsingOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DoublePreendorsingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoublePreendorsingAsync
     *
     * Get double preendorsing
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoublePreendorsingAsync($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsing'][0])
    {
        return $this->operationsGetDoublePreendorsingAsyncWithHttpInfo($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoublePreendorsingAsyncWithHttpInfo
     *
     * Get double preendorsing
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoublePreendorsingAsyncWithHttpInfo($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsing'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\DoublePreendorsingOperation[]';
        $request = $this->operationsGetDoublePreendorsingRequest($anyof, $accuser, $offender, $id, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoublePreendorsing'
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.accuser.offender&#x3D;tz1...&#x60; will return operations where &#x60;accuser&#x60; OR &#x60;offender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $accuser Filters by accuser. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;offender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $offender Filters by offender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;accuser&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;accusedLevel&#x60;, &#x60;accuserRewards&#x60;, &#x60;offenderLostDeposits&#x60;, &#x60;offenderLostRewards&#x60;, &#x60;offenderLostFees&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsing'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoublePreendorsingRequest($anyof = null, $accuser = null, $offender = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsing'][0])
    {










        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoublePreendorsing, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDoublePreendorsing, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/double_preendorsing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $accuser,
            'accuser', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offender,
            'offender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoublePreendorsingByHash
     *
     * Get double preendorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DoublePreendorsingOperation[]
     */
    public function operationsGetDoublePreendorsingByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsingByHash'][0])
    {
        list($response) = $this->operationsGetDoublePreendorsingByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoublePreendorsingByHashWithHttpInfo
     *
     * Get double preendorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DoublePreendorsingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoublePreendorsingByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsingByHash'][0])
    {
        $request = $this->operationsGetDoublePreendorsingByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DoublePreendorsingOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\DoublePreendorsingOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DoublePreendorsingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DoublePreendorsingOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DoublePreendorsingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoublePreendorsingByHashAsync
     *
     * Get double preendorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoublePreendorsingByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsingByHash'][0])
    {
        return $this->operationsGetDoublePreendorsingByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoublePreendorsingByHashAsyncWithHttpInfo
     *
     * Get double preendorsing by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoublePreendorsingByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsingByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\DoublePreendorsingOperation[]';
        $request = $this->operationsGetDoublePreendorsingByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoublePreendorsingByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoublePreendorsingByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsingByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDoublePreendorsingByHash'
            );
        }



        $resourcePath = '/v1/operations/double_preendorsing/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDoublePreendorsingCount
     *
     * Get double preendorsing count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetDoublePreendorsingCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsingCount'][0])
    {
        list($response) = $this->operationsGetDoublePreendorsingCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDoublePreendorsingCountWithHttpInfo
     *
     * Get double preendorsing count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDoublePreendorsingCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsingCount'][0])
    {
        $request = $this->operationsGetDoublePreendorsingCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDoublePreendorsingCountAsync
     *
     * Get double preendorsing count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoublePreendorsingCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsingCount'][0])
    {
        return $this->operationsGetDoublePreendorsingCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDoublePreendorsingCountAsyncWithHttpInfo
     *
     * Get double preendorsing count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDoublePreendorsingCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsingCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetDoublePreendorsingCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDoublePreendorsingCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDoublePreendorsingCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDoublePreendorsingCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDoublePreendorsingCount'][0])
    {




        $resourcePath = '/v1/operations/double_preendorsing/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDrainDelegateByHash
     *
     * Get drain delegate by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DrainDelegateOperation[]
     */
    public function operationsGetDrainDelegateByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDrainDelegateByHash'][0])
    {
        list($response) = $this->operationsGetDrainDelegateByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDrainDelegateByHashWithHttpInfo
     *
     * Get drain delegate by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DrainDelegateOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDrainDelegateByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDrainDelegateByHash'][0])
    {
        $request = $this->operationsGetDrainDelegateByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DrainDelegateOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\DrainDelegateOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DrainDelegateOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DrainDelegateOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DrainDelegateOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDrainDelegateByHashAsync
     *
     * Get drain delegate by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDrainDelegateByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDrainDelegateByHash'][0])
    {
        return $this->operationsGetDrainDelegateByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDrainDelegateByHashAsyncWithHttpInfo
     *
     * Get drain delegate by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDrainDelegateByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDrainDelegateByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\DrainDelegateOperation[]';
        $request = $this->operationsGetDrainDelegateByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDrainDelegateByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDrainDelegateByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetDrainDelegateByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetDrainDelegateByHash'
            );
        }



        $resourcePath = '/v1/operations/drain_delegate/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDrainDelegateOps
     *
     * Get drain delegate
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.delegate.target&#x3D;tz1...&#x60; will return operations where &#x60;delegate&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $delegate Filters by drained baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\DrainDelegateOperation[]
     */
    public function operationsGetDrainDelegateOps($anyof = null, $delegate = null, $target = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDrainDelegateOps'][0])
    {
        list($response) = $this->operationsGetDrainDelegateOpsWithHttpInfo($anyof, $delegate, $target, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDrainDelegateOpsWithHttpInfo
     *
     * Get drain delegate
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.delegate.target&#x3D;tz1...&#x60; will return operations where &#x60;delegate&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $delegate Filters by drained baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\DrainDelegateOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDrainDelegateOpsWithHttpInfo($anyof = null, $delegate = null, $target = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDrainDelegateOps'][0])
    {
        $request = $this->operationsGetDrainDelegateOpsRequest($anyof, $delegate, $target, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\DrainDelegateOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\DrainDelegateOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\DrainDelegateOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\DrainDelegateOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\DrainDelegateOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDrainDelegateOpsAsync
     *
     * Get drain delegate
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.delegate.target&#x3D;tz1...&#x60; will return operations where &#x60;delegate&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $delegate Filters by drained baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDrainDelegateOpsAsync($anyof = null, $delegate = null, $target = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDrainDelegateOps'][0])
    {
        return $this->operationsGetDrainDelegateOpsAsyncWithHttpInfo($anyof, $delegate, $target, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDrainDelegateOpsAsyncWithHttpInfo
     *
     * Get drain delegate
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.delegate.target&#x3D;tz1...&#x60; will return operations where &#x60;delegate&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $delegate Filters by drained baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDrainDelegateOpsAsyncWithHttpInfo($anyof = null, $delegate = null, $target = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDrainDelegateOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\DrainDelegateOperation[]';
        $request = $this->operationsGetDrainDelegateOpsRequest($anyof, $delegate, $target, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDrainDelegateOps'
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.delegate.target&#x3D;tz1...&#x60; will return operations where &#x60;delegate&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $delegate Filters by drained baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDrainDelegateOpsRequest($anyof = null, $delegate = null, $target = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetDrainDelegateOps'][0])
    {









        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDrainDelegateOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetDrainDelegateOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/drain_delegate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delegate,
            'delegate', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target,
            'target', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetDrainDelegateOpsCount
     *
     * Get drain delegate count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetDrainDelegateOpsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDrainDelegateOpsCount'][0])
    {
        list($response) = $this->operationsGetDrainDelegateOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetDrainDelegateOpsCountWithHttpInfo
     *
     * Get drain delegate count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetDrainDelegateOpsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDrainDelegateOpsCount'][0])
    {
        $request = $this->operationsGetDrainDelegateOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetDrainDelegateOpsCountAsync
     *
     * Get drain delegate count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDrainDelegateOpsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDrainDelegateOpsCount'][0])
    {
        return $this->operationsGetDrainDelegateOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetDrainDelegateOpsCountAsyncWithHttpInfo
     *
     * Get drain delegate count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetDrainDelegateOpsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDrainDelegateOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetDrainDelegateOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetDrainDelegateOpsCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetDrainDelegateOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetDrainDelegateOpsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetDrainDelegateOpsCount'][0])
    {




        $resourcePath = '/v1/operations/drain_delegate/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsementByHash
     *
     * Get endorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\EndorsementOperation[]
     */
    public function operationsGetEndorsementByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsementByHash'][0])
    {
        list($response) = $this->operationsGetEndorsementByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetEndorsementByHashWithHttpInfo
     *
     * Get endorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\EndorsementOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsementByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsementByHash'][0])
    {
        $request = $this->operationsGetEndorsementByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\EndorsementOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\EndorsementOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\EndorsementOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\EndorsementOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\EndorsementOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsementByHashAsync
     *
     * Get endorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsementByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsementByHash'][0])
    {
        return $this->operationsGetEndorsementByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsementByHashAsyncWithHttpInfo
     *
     * Get endorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsementByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsementByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\EndorsementOperation[]';
        $request = $this->operationsGetEndorsementByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsementByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsementByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsementByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetEndorsementByHash'
            );
        }



        $resourcePath = '/v1/operations/endorsements/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsements
     *
     * Get endorsements
     *
     * @param  AccountsGetDelegateParameter $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters endorsements by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsements'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\EndorsementOperation[]
     */
    public function operationsGetEndorsements($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsements'][0])
    {
        list($response) = $this->operationsGetEndorsementsWithHttpInfo($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetEndorsementsWithHttpInfo
     *
     * Get endorsements
     *
     * @param  AccountsGetDelegateParameter $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters endorsements by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsements'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\EndorsementOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsementsWithHttpInfo($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsements'][0])
    {
        $request = $this->operationsGetEndorsementsRequest($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\EndorsementOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\EndorsementOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\EndorsementOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\EndorsementOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\EndorsementOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsementsAsync
     *
     * Get endorsements
     *
     * @param  AccountsGetDelegateParameter $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters endorsements by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsementsAsync($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsements'][0])
    {
        return $this->operationsGetEndorsementsAsyncWithHttpInfo($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsementsAsyncWithHttpInfo
     *
     * Get endorsements
     *
     * @param  AccountsGetDelegateParameter $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters endorsements by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsementsAsyncWithHttpInfo($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsements'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\EndorsementOperation[]';
        $request = $this->operationsGetEndorsementsRequest($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsements'
     *
     * @param  AccountsGetDelegateParameter $delegate Filters endorsements by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters endorsements by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts endorsements by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsementsRequest($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsements'][0])
    {







        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetEndorsements, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetEndorsements, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/endorsements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delegate,
            'delegate', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsementsCount
     *
     * Get endorsements count
     *
     * @param  AccountsGetIdParameter $level Filters endorsements by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetEndorsementsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetEndorsementsCount'][0])
    {
        list($response) = $this->operationsGetEndorsementsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetEndorsementsCountWithHttpInfo
     *
     * Get endorsements count
     *
     * @param  AccountsGetIdParameter $level Filters endorsements by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsementsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetEndorsementsCount'][0])
    {
        $request = $this->operationsGetEndorsementsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsementsCountAsync
     *
     * Get endorsements count
     *
     * @param  AccountsGetIdParameter $level Filters endorsements by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsementsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetEndorsementsCount'][0])
    {
        return $this->operationsGetEndorsementsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsementsCountAsyncWithHttpInfo
     *
     * Get endorsements count
     *
     * @param  AccountsGetIdParameter $level Filters endorsements by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsementsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetEndorsementsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetEndorsementsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsementsCount'
     *
     * @param  AccountsGetIdParameter $level Filters endorsements by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters endorsements by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsementsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsementsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetEndorsementsCount'][0])
    {




        $resourcePath = '/v1/operations/endorsements/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsingRewardById
     *
     * Get endorsing reward by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardById'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\EndorsingRewardOperation
     */
    public function operationsGetEndorsingRewardById($id, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsingRewardById'][0])
    {
        list($response) = $this->operationsGetEndorsingRewardByIdWithHttpInfo($id, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetEndorsingRewardByIdWithHttpInfo
     *
     * Get endorsing reward by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardById'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\EndorsingRewardOperation, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsingRewardByIdWithHttpInfo($id, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsingRewardById'][0])
    {
        $request = $this->operationsGetEndorsingRewardByIdRequest($id, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\EndorsingRewardOperation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\EndorsingRewardOperation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\EndorsingRewardOperation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\EndorsingRewardOperation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\EndorsingRewardOperation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsingRewardByIdAsync
     *
     * Get endorsing reward by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsingRewardByIdAsync($id, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsingRewardById'][0])
    {
        return $this->operationsGetEndorsingRewardByIdAsyncWithHttpInfo($id, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsingRewardByIdAsyncWithHttpInfo
     *
     * Get endorsing reward by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsingRewardByIdAsyncWithHttpInfo($id, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsingRewardById'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\EndorsingRewardOperation';
        $request = $this->operationsGetEndorsingRewardByIdRequest($id, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsingRewardById'
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsingRewardByIdRequest($id, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsingRewardById'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling operationsGetEndorsingRewardById'
            );
        }



        $resourcePath = '/v1/operations/endorsing_rewards/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsingRewards
     *
     * Get endorsing rewards
     *
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewards'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\EndorsingRewardOperation[]
     */
    public function operationsGetEndorsingRewards($id = null, $baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsingRewards'][0])
    {
        list($response) = $this->operationsGetEndorsingRewardsWithHttpInfo($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetEndorsingRewardsWithHttpInfo
     *
     * Get endorsing rewards
     *
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewards'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\EndorsingRewardOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsingRewardsWithHttpInfo($id = null, $baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsingRewards'][0])
    {
        $request = $this->operationsGetEndorsingRewardsRequest($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\EndorsingRewardOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\EndorsingRewardOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\EndorsingRewardOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\EndorsingRewardOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\EndorsingRewardOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsingRewardsAsync
     *
     * Get endorsing rewards
     *
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewards'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsingRewardsAsync($id = null, $baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsingRewards'][0])
    {
        return $this->operationsGetEndorsingRewardsAsyncWithHttpInfo($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsingRewardsAsyncWithHttpInfo
     *
     * Get endorsing rewards
     *
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewards'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsingRewardsAsyncWithHttpInfo($id = null, $baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsingRewards'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\EndorsingRewardOperation[]';
        $request = $this->operationsGetEndorsingRewardsRequest($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsingRewards'
     *
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewards'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsingRewardsRequest($id = null, $baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetEndorsingRewards'][0])
    {








        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetEndorsingRewards, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetEndorsingRewards, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/endorsing_rewards';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetEndorsingRewardsCount
     *
     * Get endorsing rewards count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetEndorsingRewardsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetEndorsingRewardsCount'][0])
    {
        list($response) = $this->operationsGetEndorsingRewardsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetEndorsingRewardsCountWithHttpInfo
     *
     * Get endorsing rewards count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetEndorsingRewardsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetEndorsingRewardsCount'][0])
    {
        $request = $this->operationsGetEndorsingRewardsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetEndorsingRewardsCountAsync
     *
     * Get endorsing rewards count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsingRewardsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetEndorsingRewardsCount'][0])
    {
        return $this->operationsGetEndorsingRewardsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetEndorsingRewardsCountAsyncWithHttpInfo
     *
     * Get endorsing rewards count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetEndorsingRewardsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetEndorsingRewardsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetEndorsingRewardsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetEndorsingRewardsCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetEndorsingRewardsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetEndorsingRewardsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetEndorsingRewardsCount'][0])
    {




        $resourcePath = '/v1/operations/endorsing_rewards/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetIncreasePaidStorageByHash
     *
     * Get increase paid storage by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[]
     */
    public function operationsGetIncreasePaidStorageByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageByHash'][0])
    {
        list($response) = $this->operationsGetIncreasePaidStorageByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetIncreasePaidStorageByHashWithHttpInfo
     *
     * Get increase paid storage by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetIncreasePaidStorageByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageByHash'][0])
    {
        $request = $this->operationsGetIncreasePaidStorageByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetIncreasePaidStorageByHashAsync
     *
     * Get increase paid storage by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetIncreasePaidStorageByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageByHash'][0])
    {
        return $this->operationsGetIncreasePaidStorageByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetIncreasePaidStorageByHashAsyncWithHttpInfo
     *
     * Get increase paid storage by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetIncreasePaidStorageByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[]';
        $request = $this->operationsGetIncreasePaidStorageByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetIncreasePaidStorageByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetIncreasePaidStorageByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetIncreasePaidStorageByHash'
            );
        }



        $resourcePath = '/v1/operations/increase_paid_storage/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetIncreasePaidStorageCount
     *
     * Get increase paid storage count
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetIncreasePaidStorageCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageCount'][0])
    {
        list($response) = $this->operationsGetIncreasePaidStorageCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetIncreasePaidStorageCountWithHttpInfo
     *
     * Get increase paid storage count
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetIncreasePaidStorageCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageCount'][0])
    {
        $request = $this->operationsGetIncreasePaidStorageCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetIncreasePaidStorageCountAsync
     *
     * Get increase paid storage count
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetIncreasePaidStorageCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageCount'][0])
    {
        return $this->operationsGetIncreasePaidStorageCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetIncreasePaidStorageCountAsyncWithHttpInfo
     *
     * Get increase paid storage count
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetIncreasePaidStorageCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetIncreasePaidStorageCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetIncreasePaidStorageCount'
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetIncreasePaidStorageCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageCount'][0])
    {




        $resourcePath = '/v1/operations/increase_paid_storage/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetIncreasePaidStorageOps
     *
     * Get increase paid storage
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $contract Filters by contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[]
     */
    public function operationsGetIncreasePaidStorageOps($sender = null, $contract = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageOps'][0])
    {
        list($response) = $this->operationsGetIncreasePaidStorageOpsWithHttpInfo($sender, $contract, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetIncreasePaidStorageOpsWithHttpInfo
     *
     * Get increase paid storage
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $contract Filters by contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetIncreasePaidStorageOpsWithHttpInfo($sender = null, $contract = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageOps'][0])
    {
        $request = $this->operationsGetIncreasePaidStorageOpsRequest($sender, $contract, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetIncreasePaidStorageOpsAsync
     *
     * Get increase paid storage
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $contract Filters by contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetIncreasePaidStorageOpsAsync($sender = null, $contract = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageOps'][0])
    {
        return $this->operationsGetIncreasePaidStorageOpsAsyncWithHttpInfo($sender, $contract, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetIncreasePaidStorageOpsAsyncWithHttpInfo
     *
     * Get increase paid storage
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $contract Filters by contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetIncreasePaidStorageOpsAsyncWithHttpInfo($sender = null, $contract = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\IncreasePaidStorageOperation[]';
        $request = $this->operationsGetIncreasePaidStorageOpsRequest($sender, $contract, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetIncreasePaidStorageOps'
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $contract Filters by contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetIncreasePaidStorageOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetIncreasePaidStorageOpsRequest($sender = null, $contract = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetIncreasePaidStorageOps'][0])
    {









        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetIncreasePaidStorageOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetIncreasePaidStorageOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/increase_paid_storage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contract,
            'contract', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetMigrationById
     *
     * Get migration by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationById'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\MigrationOperation
     */
    public function operationsGetMigrationById($id, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetMigrationById'][0])
    {
        list($response) = $this->operationsGetMigrationByIdWithHttpInfo($id, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetMigrationByIdWithHttpInfo
     *
     * Get migration by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationById'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\MigrationOperation, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetMigrationByIdWithHttpInfo($id, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetMigrationById'][0])
    {
        $request = $this->operationsGetMigrationByIdRequest($id, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\MigrationOperation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\MigrationOperation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\MigrationOperation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\MigrationOperation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\MigrationOperation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetMigrationByIdAsync
     *
     * Get migration by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetMigrationByIdAsync($id, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetMigrationById'][0])
    {
        return $this->operationsGetMigrationByIdAsyncWithHttpInfo($id, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetMigrationByIdAsyncWithHttpInfo
     *
     * Get migration by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetMigrationByIdAsyncWithHttpInfo($id, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetMigrationById'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\MigrationOperation';
        $request = $this->operationsGetMigrationByIdRequest($id, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetMigrationById'
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetMigrationByIdRequest($id, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetMigrationById'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling operationsGetMigrationById'
            );
        }




        $resourcePath = '/v1/operations/migrations/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetMigrations
     *
     * Get migrations
     *
     * @param  AccountsGetDelegateParameter $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OperationsGetMigrationsKindParameter $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;, &#x60;origination&#x60;, &#x60;subsidy&#x60;, &#x60;remove_bigmap_key&#x60;). (optional)
     * @param  AccountsGetBalanceParameter $balance_change Filters migration operations by amount. (optional)
     * @param  AccountsGetBalanceParameter $id Filters migration operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters migration operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters migration operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrations'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\MigrationOperation[]
     */
    public function operationsGetMigrations($account = null, $kind = null, $balance_change = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetMigrations'][0])
    {
        list($response) = $this->operationsGetMigrationsWithHttpInfo($account, $kind, $balance_change, $id, $level, $timestamp, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetMigrationsWithHttpInfo
     *
     * Get migrations
     *
     * @param  AccountsGetDelegateParameter $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OperationsGetMigrationsKindParameter $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;, &#x60;origination&#x60;, &#x60;subsidy&#x60;, &#x60;remove_bigmap_key&#x60;). (optional)
     * @param  AccountsGetBalanceParameter $balance_change Filters migration operations by amount. (optional)
     * @param  AccountsGetBalanceParameter $id Filters migration operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters migration operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters migration operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrations'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\MigrationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetMigrationsWithHttpInfo($account = null, $kind = null, $balance_change = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetMigrations'][0])
    {
        $request = $this->operationsGetMigrationsRequest($account, $kind, $balance_change, $id, $level, $timestamp, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\MigrationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\MigrationOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\MigrationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\MigrationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\MigrationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetMigrationsAsync
     *
     * Get migrations
     *
     * @param  AccountsGetDelegateParameter $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OperationsGetMigrationsKindParameter $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;, &#x60;origination&#x60;, &#x60;subsidy&#x60;, &#x60;remove_bigmap_key&#x60;). (optional)
     * @param  AccountsGetBalanceParameter $balance_change Filters migration operations by amount. (optional)
     * @param  AccountsGetBalanceParameter $id Filters migration operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters migration operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters migration operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetMigrationsAsync($account = null, $kind = null, $balance_change = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetMigrations'][0])
    {
        return $this->operationsGetMigrationsAsyncWithHttpInfo($account, $kind, $balance_change, $id, $level, $timestamp, $select, $sort, $offset, $limit, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetMigrationsAsyncWithHttpInfo
     *
     * Get migrations
     *
     * @param  AccountsGetDelegateParameter $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OperationsGetMigrationsKindParameter $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;, &#x60;origination&#x60;, &#x60;subsidy&#x60;, &#x60;remove_bigmap_key&#x60;). (optional)
     * @param  AccountsGetBalanceParameter $balance_change Filters migration operations by amount. (optional)
     * @param  AccountsGetBalanceParameter $id Filters migration operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters migration operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters migration operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetMigrationsAsyncWithHttpInfo($account = null, $kind = null, $balance_change = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetMigrations'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\MigrationOperation[]';
        $request = $this->operationsGetMigrationsRequest($account, $kind, $balance_change, $id, $level, $timestamp, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetMigrations'
     *
     * @param  AccountsGetDelegateParameter $account Filters migration operations by account. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  OperationsGetMigrationsKindParameter $kind Filters migration operations by kind (&#x60;bootstrap&#x60;, &#x60;activate_delegate&#x60;, &#x60;airdrop&#x60;, &#x60;proposal_invoice&#x60;, &#x60;origination&#x60;, &#x60;subsidy&#x60;, &#x60;remove_bigmap_key&#x60;). (optional)
     * @param  AccountsGetBalanceParameter $balance_change Filters migration operations by amount. (optional)
     * @param  AccountsGetBalanceParameter $id Filters migration operations by internal TzKT id. (optional)
     * @param  AccountsGetIdParameter $level Filters migration operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters migration operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts migrations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetMigrationsRequest($account = null, $kind = null, $balance_change = null, $id = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetMigrations'][0])
    {










        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetMigrations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetMigrations, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/migrations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account,
            'account', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $kind,
            'kind', // param base name
            'OneOfMigrationKindParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $balance_change,
            'balanceChange', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetMigrationsCount
     *
     * Get migrations count
     *
     * @param  AccountsGetIdParameter $level Filters migrations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters migrations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetMigrationsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetMigrationsCount'][0])
    {
        list($response) = $this->operationsGetMigrationsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetMigrationsCountWithHttpInfo
     *
     * Get migrations count
     *
     * @param  AccountsGetIdParameter $level Filters migrations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters migrations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetMigrationsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetMigrationsCount'][0])
    {
        $request = $this->operationsGetMigrationsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetMigrationsCountAsync
     *
     * Get migrations count
     *
     * @param  AccountsGetIdParameter $level Filters migrations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters migrations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetMigrationsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetMigrationsCount'][0])
    {
        return $this->operationsGetMigrationsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetMigrationsCountAsyncWithHttpInfo
     *
     * Get migrations count
     *
     * @param  AccountsGetIdParameter $level Filters migrations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters migrations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetMigrationsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetMigrationsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetMigrationsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetMigrationsCount'
     *
     * @param  AccountsGetIdParameter $level Filters migrations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters migrations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetMigrationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetMigrationsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetMigrationsCount'][0])
    {




        $resourcePath = '/v1/operations/migrations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetNonceRevelationByHash
     *
     * Get nonce revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\NonceRevelationOperation[]
     */
    public function operationsGetNonceRevelationByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetNonceRevelationByHash'][0])
    {
        list($response) = $this->operationsGetNonceRevelationByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetNonceRevelationByHashWithHttpInfo
     *
     * Get nonce revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\NonceRevelationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetNonceRevelationByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetNonceRevelationByHash'][0])
    {
        $request = $this->operationsGetNonceRevelationByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\NonceRevelationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\NonceRevelationOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetNonceRevelationByHashAsync
     *
     * Get nonce revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetNonceRevelationByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetNonceRevelationByHash'][0])
    {
        return $this->operationsGetNonceRevelationByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetNonceRevelationByHashAsyncWithHttpInfo
     *
     * Get nonce revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetNonceRevelationByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetNonceRevelationByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]';
        $request = $this->operationsGetNonceRevelationByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetNonceRevelationByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetNonceRevelationByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetNonceRevelationByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetNonceRevelationByHash'
            );
        }



        $resourcePath = '/v1/operations/nonce_revelations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetNonceRevelations
     *
     * Get nonce revelations
     *
     * @param  BlocksGetAnyofParameter $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  AccountsGetIdParameter $level Filters nonce revelation operations by level. (optional)
     * @param  AccountsGetIdParameter $revealed_cycle Filters by cycle for which the nonce was revealed. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelations'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\NonceRevelationOperation[]
     */
    public function operationsGetNonceRevelations($anyof = null, $baker = null, $sender = null, $level = null, $revealed_cycle = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetNonceRevelations'][0])
    {
        list($response) = $this->operationsGetNonceRevelationsWithHttpInfo($anyof, $baker, $sender, $level, $revealed_cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetNonceRevelationsWithHttpInfo
     *
     * Get nonce revelations
     *
     * @param  BlocksGetAnyofParameter $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  AccountsGetIdParameter $level Filters nonce revelation operations by level. (optional)
     * @param  AccountsGetIdParameter $revealed_cycle Filters by cycle for which the nonce was revealed. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelations'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\NonceRevelationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetNonceRevelationsWithHttpInfo($anyof = null, $baker = null, $sender = null, $level = null, $revealed_cycle = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetNonceRevelations'][0])
    {
        $request = $this->operationsGetNonceRevelationsRequest($anyof, $baker, $sender, $level, $revealed_cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\NonceRevelationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\NonceRevelationOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetNonceRevelationsAsync
     *
     * Get nonce revelations
     *
     * @param  BlocksGetAnyofParameter $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  AccountsGetIdParameter $level Filters nonce revelation operations by level. (optional)
     * @param  AccountsGetIdParameter $revealed_cycle Filters by cycle for which the nonce was revealed. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetNonceRevelationsAsync($anyof = null, $baker = null, $sender = null, $level = null, $revealed_cycle = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetNonceRevelations'][0])
    {
        return $this->operationsGetNonceRevelationsAsyncWithHttpInfo($anyof, $baker, $sender, $level, $revealed_cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetNonceRevelationsAsyncWithHttpInfo
     *
     * Get nonce revelations
     *
     * @param  BlocksGetAnyofParameter $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  AccountsGetIdParameter $level Filters nonce revelation operations by level. (optional)
     * @param  AccountsGetIdParameter $revealed_cycle Filters by cycle for which the nonce was revealed. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetNonceRevelationsAsyncWithHttpInfo($anyof = null, $baker = null, $sender = null, $level = null, $revealed_cycle = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetNonceRevelations'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\NonceRevelationOperation[]';
        $request = $this->operationsGetNonceRevelationsRequest($anyof, $baker, $sender, $level, $revealed_cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetNonceRevelations'
     *
     * @param  BlocksGetAnyofParameter $anyof Filters nonce revelation operations by any of the specified fields. Example: &#x60;anyof.baker.sender&#x3D;tz1...&#x60; will return operations where &#x60;baker&#x60; OR &#x60;sender&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters nonce revelation operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters nonce revelation operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;baker&#x60;. (optional)
     * @param  AccountsGetIdParameter $level Filters nonce revelation operations by level. (optional)
     * @param  AccountsGetIdParameter $revealed_cycle Filters by cycle for which the nonce was revealed. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters nonce revelation operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts nonce revelation operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;revealedLevel&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetNonceRevelationsRequest($anyof = null, $baker = null, $sender = null, $level = null, $revealed_cycle = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetNonceRevelations'][0])
    {










        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetNonceRevelations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetNonceRevelations, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/nonce_revelations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $revealed_cycle,
            'revealedCycle', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetNonceRevelationsCount
     *
     * Get nonce revelations count
     *
     * @param  AccountsGetIdParameter $level Filters seed nonce revelation operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetNonceRevelationsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetNonceRevelationsCount'][0])
    {
        list($response) = $this->operationsGetNonceRevelationsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetNonceRevelationsCountWithHttpInfo
     *
     * Get nonce revelations count
     *
     * @param  AccountsGetIdParameter $level Filters seed nonce revelation operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetNonceRevelationsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetNonceRevelationsCount'][0])
    {
        $request = $this->operationsGetNonceRevelationsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetNonceRevelationsCountAsync
     *
     * Get nonce revelations count
     *
     * @param  AccountsGetIdParameter $level Filters seed nonce revelation operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetNonceRevelationsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetNonceRevelationsCount'][0])
    {
        return $this->operationsGetNonceRevelationsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetNonceRevelationsCountAsyncWithHttpInfo
     *
     * Get nonce revelations count
     *
     * @param  AccountsGetIdParameter $level Filters seed nonce revelation operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetNonceRevelationsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetNonceRevelationsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetNonceRevelationsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetNonceRevelationsCount'
     *
     * @param  AccountsGetIdParameter $level Filters seed nonce revelation operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters seed nonce revelation operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetNonceRevelationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetNonceRevelationsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetNonceRevelationsCount'][0])
    {




        $resourcePath = '/v1/operations/nonce_revelations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetOriginationByHash
     *
     * Get origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  MichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\OriginationOperation[]
     */
    public function operationsGetOriginationByHash($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetOriginationByHash'][0])
    {
        list($response) = $this->operationsGetOriginationByHashWithHttpInfo($hash, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetOriginationByHashWithHttpInfo
     *
     * Get origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  MichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\OriginationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetOriginationByHashWithHttpInfo($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetOriginationByHash'][0])
    {
        $request = $this->operationsGetOriginationByHashRequest($hash, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\OriginationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\OriginationOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\OriginationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\OriginationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\OriginationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetOriginationByHashAsync
     *
     * Get origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  MichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetOriginationByHashAsync($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetOriginationByHash'][0])
    {
        return $this->operationsGetOriginationByHashAsyncWithHttpInfo($hash, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetOriginationByHashAsyncWithHttpInfo
     *
     * Get origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  MichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetOriginationByHashAsyncWithHttpInfo($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetOriginationByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\OriginationOperation[]';
        $request = $this->operationsGetOriginationByHashRequest($hash, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetOriginationByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  MichelineFormat $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetOriginationByHashRequest($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetOriginationByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetOriginationByHash'
            );
        }




        $resourcePath = '/v1/operations/originations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'MichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetOriginationStatus
     *
     * Get origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetOriginationStatus($hash, string $contentType = self::contentTypes['operationsGetOriginationStatus'][0])
    {
        list($response) = $this->operationsGetOriginationStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetOriginationStatusWithHttpInfo
     *
     * Get origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetOriginationStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetOriginationStatus'][0])
    {
        $request = $this->operationsGetOriginationStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetOriginationStatusAsync
     *
     * Get origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetOriginationStatusAsync($hash, string $contentType = self::contentTypes['operationsGetOriginationStatus'][0])
    {
        return $this->operationsGetOriginationStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetOriginationStatusAsyncWithHttpInfo
     *
     * Get origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetOriginationStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetOriginationStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetOriginationStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetOriginationStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetOriginationStatusRequest($hash, string $contentType = self::contentTypes['operationsGetOriginationStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetOriginationStatus'
            );
        }


        $resourcePath = '/v1/operations/originations/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetOriginations
     *
     * Get originations
     *
     * @param  BlocksGetAnyofParameter $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters origination operations by internal TzKT id (optional)
     * @param  AccountsGetIdParameter $type_hash Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts) (optional)
     * @param  AccountsGetIdParameter $code_hash Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts) (optional)
     * @param  AccountsGetIdParameter $level Filters origination operations by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters origination operations by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $any_code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;codeHash&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginations'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\OriginationOperation[]
     */
    public function operationsGetOriginations($anyof = null, $initiator = null, $sender = null, $contract_manager = null, $contract_delegate = null, $originated_contract = null, $id = null, $type_hash = null, $code_hash = null, $level = null, $timestamp = null, $sender_code_hash = null, $any_code_hash = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetOriginations'][0])
    {
        list($response) = $this->operationsGetOriginationsWithHttpInfo($anyof, $initiator, $sender, $contract_manager, $contract_delegate, $originated_contract, $id, $type_hash, $code_hash, $level, $timestamp, $sender_code_hash, $any_code_hash, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetOriginationsWithHttpInfo
     *
     * Get originations
     *
     * @param  BlocksGetAnyofParameter $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters origination operations by internal TzKT id (optional)
     * @param  AccountsGetIdParameter $type_hash Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts) (optional)
     * @param  AccountsGetIdParameter $code_hash Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts) (optional)
     * @param  AccountsGetIdParameter $level Filters origination operations by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters origination operations by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $any_code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;codeHash&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginations'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\OriginationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetOriginationsWithHttpInfo($anyof = null, $initiator = null, $sender = null, $contract_manager = null, $contract_delegate = null, $originated_contract = null, $id = null, $type_hash = null, $code_hash = null, $level = null, $timestamp = null, $sender_code_hash = null, $any_code_hash = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetOriginations'][0])
    {
        $request = $this->operationsGetOriginationsRequest($anyof, $initiator, $sender, $contract_manager, $contract_delegate, $originated_contract, $id, $type_hash, $code_hash, $level, $timestamp, $sender_code_hash, $any_code_hash, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\OriginationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\OriginationOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\OriginationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\OriginationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\OriginationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetOriginationsAsync
     *
     * Get originations
     *
     * @param  BlocksGetAnyofParameter $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters origination operations by internal TzKT id (optional)
     * @param  AccountsGetIdParameter $type_hash Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts) (optional)
     * @param  AccountsGetIdParameter $code_hash Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts) (optional)
     * @param  AccountsGetIdParameter $level Filters origination operations by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters origination operations by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $any_code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;codeHash&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetOriginationsAsync($anyof = null, $initiator = null, $sender = null, $contract_manager = null, $contract_delegate = null, $originated_contract = null, $id = null, $type_hash = null, $code_hash = null, $level = null, $timestamp = null, $sender_code_hash = null, $any_code_hash = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetOriginations'][0])
    {
        return $this->operationsGetOriginationsAsyncWithHttpInfo($anyof, $initiator, $sender, $contract_manager, $contract_delegate, $originated_contract, $id, $type_hash, $code_hash, $level, $timestamp, $sender_code_hash, $any_code_hash, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetOriginationsAsyncWithHttpInfo
     *
     * Get originations
     *
     * @param  BlocksGetAnyofParameter $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters origination operations by internal TzKT id (optional)
     * @param  AccountsGetIdParameter $type_hash Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts) (optional)
     * @param  AccountsGetIdParameter $code_hash Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts) (optional)
     * @param  AccountsGetIdParameter $level Filters origination operations by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters origination operations by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $any_code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;codeHash&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetOriginationsAsyncWithHttpInfo($anyof = null, $initiator = null, $sender = null, $contract_manager = null, $contract_delegate = null, $originated_contract = null, $id = null, $type_hash = null, $code_hash = null, $level = null, $timestamp = null, $sender_code_hash = null, $any_code_hash = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetOriginations'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\OriginationOperation[]';
        $request = $this->operationsGetOriginationsRequest($anyof, $initiator, $sender, $contract_manager, $contract_delegate, $originated_contract, $id, $type_hash, $code_hash, $level, $timestamp, $sender_code_hash, $any_code_hash, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetOriginations'
     *
     * @param  BlocksGetAnyofParameter $anyof Filters originations by any of the specified fields. Example: &#x60;anyof.sender.initiator&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;initiator&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all originations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters origination operations by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters origination operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;contractManager&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $contract_manager Filters origination operations by manager. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractDelegate&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $contract_delegate Filters origination operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;initiator&#x60;, &#x60;sender&#x60;, &#x60;contractManager&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $originated_contract Filters origination operations by originated contract. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters origination operations by internal TzKT id (optional)
     * @param  AccountsGetIdParameter $type_hash Filters origination operations by 32-bit hash of originated contract parameter and storage types (helpful for searching originations of similar contracts) (optional)
     * @param  AccountsGetIdParameter $code_hash Filters origination operations by 32-bit hash of originated contract code (helpful for searching originations of same contracts) (optional)
     * @param  AccountsGetIdParameter $level Filters origination operations by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters origination operations by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $any_code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;codeHash&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters origination operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts originations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;contractBalance&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetOriginationsRequest($anyof = null, $initiator = null, $sender = null, $contract_manager = null, $contract_delegate = null, $originated_contract = null, $id = null, $type_hash = null, $code_hash = null, $level = null, $timestamp = null, $sender_code_hash = null, $any_code_hash = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetOriginations'][0])
    {


















        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetOriginations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetOriginations, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/originations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $initiator,
            'initiator', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contract_manager,
            'contractManager', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $contract_delegate,
            'contractDelegate', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $originated_contract,
            'originatedContract', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type_hash,
            'typeHash', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $code_hash,
            'codeHash', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender_code_hash,
            'senderCodeHash', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $any_code_hash,
            'anyCodeHash', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetOriginationsCount
     *
     * Get originations count
     *
     * @param  AccountsGetIdParameter $level Filters originations by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters originations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetOriginationsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetOriginationsCount'][0])
    {
        list($response) = $this->operationsGetOriginationsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetOriginationsCountWithHttpInfo
     *
     * Get originations count
     *
     * @param  AccountsGetIdParameter $level Filters originations by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters originations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetOriginationsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetOriginationsCount'][0])
    {
        $request = $this->operationsGetOriginationsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetOriginationsCountAsync
     *
     * Get originations count
     *
     * @param  AccountsGetIdParameter $level Filters originations by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters originations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetOriginationsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetOriginationsCount'][0])
    {
        return $this->operationsGetOriginationsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetOriginationsCountAsyncWithHttpInfo
     *
     * Get originations count
     *
     * @param  AccountsGetIdParameter $level Filters originations by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters originations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetOriginationsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetOriginationsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetOriginationsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetOriginationsCount'
     *
     * @param  AccountsGetIdParameter $level Filters originations by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters originations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetOriginationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetOriginationsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetOriginationsCount'][0])
    {




        $resourcePath = '/v1/operations/originations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetPreendorsementByHash
     *
     * Get preendorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\PreendorsementOperation[]
     */
    public function operationsGetPreendorsementByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetPreendorsementByHash'][0])
    {
        list($response) = $this->operationsGetPreendorsementByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetPreendorsementByHashWithHttpInfo
     *
     * Get preendorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\PreendorsementOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetPreendorsementByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetPreendorsementByHash'][0])
    {
        $request = $this->operationsGetPreendorsementByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\PreendorsementOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\PreendorsementOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\PreendorsementOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\PreendorsementOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\PreendorsementOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetPreendorsementByHashAsync
     *
     * Get preendorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetPreendorsementByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetPreendorsementByHash'][0])
    {
        return $this->operationsGetPreendorsementByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetPreendorsementByHashAsyncWithHttpInfo
     *
     * Get preendorsement by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetPreendorsementByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetPreendorsementByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\PreendorsementOperation[]';
        $request = $this->operationsGetPreendorsementByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetPreendorsementByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetPreendorsementByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetPreendorsementByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetPreendorsementByHash'
            );
        }



        $resourcePath = '/v1/operations/preendorsements/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetPreendorsements
     *
     * Get preendorsements
     *
     * @param  AccountsGetDelegateParameter $delegate Filters by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsements'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\PreendorsementOperation[]
     */
    public function operationsGetPreendorsements($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetPreendorsements'][0])
    {
        list($response) = $this->operationsGetPreendorsementsWithHttpInfo($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetPreendorsementsWithHttpInfo
     *
     * Get preendorsements
     *
     * @param  AccountsGetDelegateParameter $delegate Filters by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsements'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\PreendorsementOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetPreendorsementsWithHttpInfo($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetPreendorsements'][0])
    {
        $request = $this->operationsGetPreendorsementsRequest($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\PreendorsementOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\PreendorsementOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\PreendorsementOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\PreendorsementOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\PreendorsementOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetPreendorsementsAsync
     *
     * Get preendorsements
     *
     * @param  AccountsGetDelegateParameter $delegate Filters by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetPreendorsementsAsync($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetPreendorsements'][0])
    {
        return $this->operationsGetPreendorsementsAsyncWithHttpInfo($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetPreendorsementsAsyncWithHttpInfo
     *
     * Get preendorsements
     *
     * @param  AccountsGetDelegateParameter $delegate Filters by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetPreendorsementsAsyncWithHttpInfo($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetPreendorsements'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\PreendorsementOperation[]';
        $request = $this->operationsGetPreendorsementsRequest($delegate, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetPreendorsements'
     *
     * @param  AccountsGetDelegateParameter $delegate Filters by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsements'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetPreendorsementsRequest($delegate = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetPreendorsements'][0])
    {







        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetPreendorsements, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetPreendorsements, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/preendorsements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delegate,
            'delegate', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetPreendorsementsCount
     *
     * Get preendorsements count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetPreendorsementsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetPreendorsementsCount'][0])
    {
        list($response) = $this->operationsGetPreendorsementsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetPreendorsementsCountWithHttpInfo
     *
     * Get preendorsements count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetPreendorsementsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetPreendorsementsCount'][0])
    {
        $request = $this->operationsGetPreendorsementsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetPreendorsementsCountAsync
     *
     * Get preendorsements count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetPreendorsementsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetPreendorsementsCount'][0])
    {
        return $this->operationsGetPreendorsementsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetPreendorsementsCountAsyncWithHttpInfo
     *
     * Get preendorsements count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetPreendorsementsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetPreendorsementsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetPreendorsementsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetPreendorsementsCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetPreendorsementsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetPreendorsementsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetPreendorsementsCount'][0])
    {




        $resourcePath = '/v1/operations/preendorsements/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetProposalByHash
     *
     * Get proposal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\ProposalOperation[]
     */
    public function operationsGetProposalByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetProposalByHash'][0])
    {
        list($response) = $this->operationsGetProposalByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetProposalByHashWithHttpInfo
     *
     * Get proposal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\ProposalOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetProposalByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetProposalByHash'][0])
    {
        $request = $this->operationsGetProposalByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\ProposalOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\ProposalOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\ProposalOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\ProposalOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\ProposalOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetProposalByHashAsync
     *
     * Get proposal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetProposalByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetProposalByHash'][0])
    {
        return $this->operationsGetProposalByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetProposalByHashAsyncWithHttpInfo
     *
     * Get proposal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetProposalByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetProposalByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\ProposalOperation[]';
        $request = $this->operationsGetProposalByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetProposalByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetProposalByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetProposalByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetProposalByHash'
            );
        }



        $resourcePath = '/v1/operations/proposals/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetProposals
     *
     * Get proposals
     *
     * @param  AccountsGetDelegateParameter $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters proposal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  AccountsGetIdParameter $epoch Filters proposal operations by voting epoch. (optional)
     * @param  AccountsGetIdParameter $period Filters proposal operations by voting period. (optional)
     * @param  OperationsGetBallotsProposalParameter $proposal Filters proposal operations by proposal hash. (optional)
     * @param  AccountsGetStakedParameter $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposals'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\ProposalOperation[]
     */
    public function operationsGetProposals($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $duplicated = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetProposals'][0])
    {
        list($response) = $this->operationsGetProposalsWithHttpInfo($delegate, $level, $timestamp, $epoch, $period, $proposal, $duplicated, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetProposalsWithHttpInfo
     *
     * Get proposals
     *
     * @param  AccountsGetDelegateParameter $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters proposal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  AccountsGetIdParameter $epoch Filters proposal operations by voting epoch. (optional)
     * @param  AccountsGetIdParameter $period Filters proposal operations by voting period. (optional)
     * @param  OperationsGetBallotsProposalParameter $proposal Filters proposal operations by proposal hash. (optional)
     * @param  AccountsGetStakedParameter $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposals'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\ProposalOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetProposalsWithHttpInfo($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $duplicated = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetProposals'][0])
    {
        $request = $this->operationsGetProposalsRequest($delegate, $level, $timestamp, $epoch, $period, $proposal, $duplicated, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\ProposalOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\ProposalOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\ProposalOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\ProposalOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\ProposalOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetProposalsAsync
     *
     * Get proposals
     *
     * @param  AccountsGetDelegateParameter $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters proposal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  AccountsGetIdParameter $epoch Filters proposal operations by voting epoch. (optional)
     * @param  AccountsGetIdParameter $period Filters proposal operations by voting period. (optional)
     * @param  OperationsGetBallotsProposalParameter $proposal Filters proposal operations by proposal hash. (optional)
     * @param  AccountsGetStakedParameter $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposals'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetProposalsAsync($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $duplicated = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetProposals'][0])
    {
        return $this->operationsGetProposalsAsyncWithHttpInfo($delegate, $level, $timestamp, $epoch, $period, $proposal, $duplicated, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetProposalsAsyncWithHttpInfo
     *
     * Get proposals
     *
     * @param  AccountsGetDelegateParameter $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters proposal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  AccountsGetIdParameter $epoch Filters proposal operations by voting epoch. (optional)
     * @param  AccountsGetIdParameter $period Filters proposal operations by voting period. (optional)
     * @param  OperationsGetBallotsProposalParameter $proposal Filters proposal operations by proposal hash. (optional)
     * @param  AccountsGetStakedParameter $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposals'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetProposalsAsyncWithHttpInfo($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $duplicated = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetProposals'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\ProposalOperation[]';
        $request = $this->operationsGetProposalsRequest($delegate, $level, $timestamp, $epoch, $period, $proposal, $duplicated, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetProposals'
     *
     * @param  AccountsGetDelegateParameter $delegate Filters proposal operations by delegate. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters proposal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  AccountsGetIdParameter $epoch Filters proposal operations by voting epoch. (optional)
     * @param  AccountsGetIdParameter $period Filters proposal operations by voting period. (optional)
     * @param  OperationsGetBallotsProposalParameter $proposal Filters proposal operations by proposal hash. (optional)
     * @param  AccountsGetStakedParameter $duplicated Specify whether to include or exclude duplicates, which didn&#39;t actually upvote a proposal. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts proposal operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposals'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetProposalsRequest($delegate = null, $level = null, $timestamp = null, $epoch = null, $period = null, $proposal = null, $duplicated = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetProposals'][0])
    {











        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetProposals, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetProposals, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/proposals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $delegate,
            'delegate', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $epoch,
            'epoch', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period,
            'period', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $proposal,
            'proposal', // param base name
            'OneOfProtocolParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $duplicated,
            'duplicated', // param base name
            'OneOfBoolParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetProposalsCount
     *
     * Get proposals count
     *
     * @param  AccountsGetIdParameter $level Filters proposal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetProposalsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetProposalsCount'][0])
    {
        list($response) = $this->operationsGetProposalsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetProposalsCountWithHttpInfo
     *
     * Get proposals count
     *
     * @param  AccountsGetIdParameter $level Filters proposal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetProposalsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetProposalsCount'][0])
    {
        $request = $this->operationsGetProposalsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetProposalsCountAsync
     *
     * Get proposals count
     *
     * @param  AccountsGetIdParameter $level Filters proposal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetProposalsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetProposalsCount'][0])
    {
        return $this->operationsGetProposalsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetProposalsCountAsyncWithHttpInfo
     *
     * Get proposals count
     *
     * @param  AccountsGetIdParameter $level Filters proposal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetProposalsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetProposalsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetProposalsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetProposalsCount'
     *
     * @param  AccountsGetIdParameter $level Filters proposal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters proposal operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetProposalsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetProposalsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetProposalsCount'][0])
    {




        $resourcePath = '/v1/operations/proposals/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRegisterConstantByHash
     *
     * Get register constant by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\RegisterConstantOperation[]
     */
    public function operationsGetRegisterConstantByHash($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetRegisterConstantByHash'][0])
    {
        list($response) = $this->operationsGetRegisterConstantByHashWithHttpInfo($hash, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRegisterConstantByHashWithHttpInfo
     *
     * Get register constant by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\RegisterConstantOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRegisterConstantByHashWithHttpInfo($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetRegisterConstantByHash'][0])
    {
        $request = $this->operationsGetRegisterConstantByHashRequest($hash, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\RegisterConstantOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\RegisterConstantOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\RegisterConstantOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\RegisterConstantOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\RegisterConstantOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRegisterConstantByHashAsync
     *
     * Get register constant by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRegisterConstantByHashAsync($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetRegisterConstantByHash'][0])
    {
        return $this->operationsGetRegisterConstantByHashAsyncWithHttpInfo($hash, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRegisterConstantByHashAsyncWithHttpInfo
     *
     * Get register constant by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRegisterConstantByHashAsyncWithHttpInfo($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetRegisterConstantByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\RegisterConstantOperation[]';
        $request = $this->operationsGetRegisterConstantByHashRequest($hash, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRegisterConstantByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRegisterConstantByHashRequest($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetRegisterConstantByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetRegisterConstantByHash'
            );
        }




        $resourcePath = '/v1/operations/register_constants/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRegisterConstantStatus
     *
     * Get register constant status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetRegisterConstantStatus($hash, string $contentType = self::contentTypes['operationsGetRegisterConstantStatus'][0])
    {
        list($response) = $this->operationsGetRegisterConstantStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRegisterConstantStatusWithHttpInfo
     *
     * Get register constant status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRegisterConstantStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetRegisterConstantStatus'][0])
    {
        $request = $this->operationsGetRegisterConstantStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRegisterConstantStatusAsync
     *
     * Get register constant status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRegisterConstantStatusAsync($hash, string $contentType = self::contentTypes['operationsGetRegisterConstantStatus'][0])
    {
        return $this->operationsGetRegisterConstantStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRegisterConstantStatusAsyncWithHttpInfo
     *
     * Get register constant status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRegisterConstantStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetRegisterConstantStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetRegisterConstantStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRegisterConstantStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRegisterConstantStatusRequest($hash, string $contentType = self::contentTypes['operationsGetRegisterConstantStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetRegisterConstantStatus'
            );
        }


        $resourcePath = '/v1/operations/register_constants/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRegisterConstants
     *
     * Get register constants
     *
     * @param  AccountsGetDelegateParameter $sender Filters operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  BigMapsGetBigMapKeysHashParameter $address Filters operations by global address of the created constant (starts with &#x60;expr..&#x60;). (optional)
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters operations by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstants'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\RegisterConstantOperation[]
     */
    public function operationsGetRegisterConstants($sender = null, $address = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetRegisterConstants'][0])
    {
        list($response) = $this->operationsGetRegisterConstantsWithHttpInfo($sender, $address, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRegisterConstantsWithHttpInfo
     *
     * Get register constants
     *
     * @param  AccountsGetDelegateParameter $sender Filters operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  BigMapsGetBigMapKeysHashParameter $address Filters operations by global address of the created constant (starts with &#x60;expr..&#x60;). (optional)
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters operations by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstants'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\RegisterConstantOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRegisterConstantsWithHttpInfo($sender = null, $address = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetRegisterConstants'][0])
    {
        $request = $this->operationsGetRegisterConstantsRequest($sender, $address, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\RegisterConstantOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\RegisterConstantOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\RegisterConstantOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\RegisterConstantOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\RegisterConstantOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRegisterConstantsAsync
     *
     * Get register constants
     *
     * @param  AccountsGetDelegateParameter $sender Filters operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  BigMapsGetBigMapKeysHashParameter $address Filters operations by global address of the created constant (starts with &#x60;expr..&#x60;). (optional)
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters operations by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRegisterConstantsAsync($sender = null, $address = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetRegisterConstants'][0])
    {
        return $this->operationsGetRegisterConstantsAsyncWithHttpInfo($sender, $address, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRegisterConstantsAsyncWithHttpInfo
     *
     * Get register constants
     *
     * @param  AccountsGetDelegateParameter $sender Filters operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  BigMapsGetBigMapKeysHashParameter $address Filters operations by global address of the created constant (starts with &#x60;expr..&#x60;). (optional)
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters operations by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRegisterConstantsAsyncWithHttpInfo($sender = null, $address = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetRegisterConstants'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\RegisterConstantOperation[]';
        $request = $this->operationsGetRegisterConstantsRequest($sender, $address, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRegisterConstants'
     *
     * @param  AccountsGetDelegateParameter $sender Filters operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  BigMapsGetBigMapKeysHashParameter $address Filters operations by global address of the created constant (starts with &#x60;expr..&#x60;). (optional)
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters operations by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the constant value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRegisterConstantsRequest($sender = null, $address = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetRegisterConstants'][0])
    {









        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetRegisterConstants, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetRegisterConstants, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/register_constants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address,
            'address', // param base name
            'OneOfExpressionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRegisterConstantsCount
     *
     * Get register constants count
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetRegisterConstantsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRegisterConstantsCount'][0])
    {
        list($response) = $this->operationsGetRegisterConstantsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRegisterConstantsCountWithHttpInfo
     *
     * Get register constants count
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRegisterConstantsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRegisterConstantsCount'][0])
    {
        $request = $this->operationsGetRegisterConstantsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRegisterConstantsCountAsync
     *
     * Get register constants count
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRegisterConstantsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRegisterConstantsCount'][0])
    {
        return $this->operationsGetRegisterConstantsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRegisterConstantsCountAsyncWithHttpInfo
     *
     * Get register constants count
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRegisterConstantsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRegisterConstantsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetRegisterConstantsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRegisterConstantsCount'
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRegisterConstantsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRegisterConstantsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRegisterConstantsCount'][0])
    {




        $resourcePath = '/v1/operations/register_constants/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevealByHash
     *
     * Get reveal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\RevealOperation[]
     */
    public function operationsGetRevealByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetRevealByHash'][0])
    {
        list($response) = $this->operationsGetRevealByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRevealByHashWithHttpInfo
     *
     * Get reveal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\RevealOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevealByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetRevealByHash'][0])
    {
        $request = $this->operationsGetRevealByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\RevealOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\RevealOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\RevealOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\RevealOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\RevealOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevealByHashAsync
     *
     * Get reveal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevealByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetRevealByHash'][0])
    {
        return $this->operationsGetRevealByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevealByHashAsyncWithHttpInfo
     *
     * Get reveal by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevealByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetRevealByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\RevealOperation[]';
        $request = $this->operationsGetRevealByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevealByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevealByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetRevealByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetRevealByHash'
            );
        }



        $resourcePath = '/v1/operations/reveals/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevealStatus
     *
     * Get reveal status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetRevealStatus($hash, string $contentType = self::contentTypes['operationsGetRevealStatus'][0])
    {
        list($response) = $this->operationsGetRevealStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRevealStatusWithHttpInfo
     *
     * Get reveal status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevealStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetRevealStatus'][0])
    {
        $request = $this->operationsGetRevealStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevealStatusAsync
     *
     * Get reveal status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevealStatusAsync($hash, string $contentType = self::contentTypes['operationsGetRevealStatus'][0])
    {
        return $this->operationsGetRevealStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevealStatusAsyncWithHttpInfo
     *
     * Get reveal status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevealStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetRevealStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetRevealStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevealStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevealStatusRequest($hash, string $contentType = self::contentTypes['operationsGetRevealStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetRevealStatus'
            );
        }


        $resourcePath = '/v1/operations/reveals/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetReveals
     *
     * Get reveals
     *
     * @param  AccountsGetDelegateParameter $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters reveal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters reveal operations by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetReveals'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\RevealOperation[]
     */
    public function operationsGetReveals($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetReveals'][0])
    {
        list($response) = $this->operationsGetRevealsWithHttpInfo($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRevealsWithHttpInfo
     *
     * Get reveals
     *
     * @param  AccountsGetDelegateParameter $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters reveal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters reveal operations by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetReveals'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\RevealOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevealsWithHttpInfo($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetReveals'][0])
    {
        $request = $this->operationsGetRevealsRequest($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\RevealOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\RevealOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\RevealOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\RevealOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\RevealOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevealsAsync
     *
     * Get reveals
     *
     * @param  AccountsGetDelegateParameter $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters reveal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters reveal operations by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetReveals'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevealsAsync($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetReveals'][0])
    {
        return $this->operationsGetRevealsAsyncWithHttpInfo($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevealsAsyncWithHttpInfo
     *
     * Get reveals
     *
     * @param  AccountsGetDelegateParameter $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters reveal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters reveal operations by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetReveals'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevealsAsyncWithHttpInfo($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetReveals'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\RevealOperation[]';
        $request = $this->operationsGetRevealsRequest($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetReveals'
     *
     * @param  AccountsGetDelegateParameter $sender Filters reveal operations by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters reveal operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters reveal operations by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters reveal operations by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts reveals by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetReveals'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevealsRequest($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetReveals'][0])
    {








        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetReveals, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetReveals, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/reveals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevealsCount
     *
     * Get reveals count
     *
     * @param  AccountsGetIdParameter $level Filters reveals by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters reveals by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetRevealsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRevealsCount'][0])
    {
        list($response) = $this->operationsGetRevealsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRevealsCountWithHttpInfo
     *
     * Get reveals count
     *
     * @param  AccountsGetIdParameter $level Filters reveals by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters reveals by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevealsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRevealsCount'][0])
    {
        $request = $this->operationsGetRevealsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevealsCountAsync
     *
     * Get reveals count
     *
     * @param  AccountsGetIdParameter $level Filters reveals by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters reveals by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevealsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRevealsCount'][0])
    {
        return $this->operationsGetRevealsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevealsCountAsyncWithHttpInfo
     *
     * Get reveals count
     *
     * @param  AccountsGetIdParameter $level Filters reveals by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters reveals by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevealsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRevealsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetRevealsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevealsCount'
     *
     * @param  AccountsGetIdParameter $level Filters reveals by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters reveals by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevealsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevealsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRevealsCount'][0])
    {




        $resourcePath = '/v1/operations/reveals/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevelationPenalties
     *
     * Get revelation penalties
     *
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters revelation penalty operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenalties'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\RevelationPenaltyOperation[]
     */
    public function operationsGetRevelationPenalties($id = null, $baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetRevelationPenalties'][0])
    {
        list($response) = $this->operationsGetRevelationPenaltiesWithHttpInfo($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRevelationPenaltiesWithHttpInfo
     *
     * Get revelation penalties
     *
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters revelation penalty operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenalties'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\RevelationPenaltyOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevelationPenaltiesWithHttpInfo($id = null, $baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetRevelationPenalties'][0])
    {
        $request = $this->operationsGetRevelationPenaltiesRequest($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\RevelationPenaltyOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\RevelationPenaltyOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\RevelationPenaltyOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\RevelationPenaltyOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\RevelationPenaltyOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevelationPenaltiesAsync
     *
     * Get revelation penalties
     *
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters revelation penalty operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenalties'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevelationPenaltiesAsync($id = null, $baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetRevelationPenalties'][0])
    {
        return $this->operationsGetRevelationPenaltiesAsyncWithHttpInfo($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevelationPenaltiesAsyncWithHttpInfo
     *
     * Get revelation penalties
     *
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters revelation penalty operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenalties'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevelationPenaltiesAsyncWithHttpInfo($id = null, $baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetRevelationPenalties'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\RevelationPenaltyOperation[]';
        $request = $this->operationsGetRevelationPenaltiesRequest($id, $baker, $level, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevelationPenalties'
     *
     * @param  AccountsGetBalanceParameter $id Filters operations by internal TzKT id. (optional)
     * @param  AccountsGetDelegateParameter $baker Filters revelation penalty operations by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters revelation penalty operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts revelation penalty operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenalties'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevelationPenaltiesRequest($id = null, $baker = null, $level = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetRevelationPenalties'][0])
    {








        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetRevelationPenalties, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetRevelationPenalties, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/revelation_penalties';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevelationPenaltiesCount
     *
     * Get revelation penalties count
     *
     * @param  AccountsGetIdParameter $level Filters revelation penalty operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltiesCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetRevelationPenaltiesCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRevelationPenaltiesCount'][0])
    {
        list($response) = $this->operationsGetRevelationPenaltiesCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRevelationPenaltiesCountWithHttpInfo
     *
     * Get revelation penalties count
     *
     * @param  AccountsGetIdParameter $level Filters revelation penalty operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltiesCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevelationPenaltiesCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRevelationPenaltiesCount'][0])
    {
        $request = $this->operationsGetRevelationPenaltiesCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevelationPenaltiesCountAsync
     *
     * Get revelation penalties count
     *
     * @param  AccountsGetIdParameter $level Filters revelation penalty operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltiesCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevelationPenaltiesCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRevelationPenaltiesCount'][0])
    {
        return $this->operationsGetRevelationPenaltiesCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevelationPenaltiesCountAsyncWithHttpInfo
     *
     * Get revelation penalties count
     *
     * @param  AccountsGetIdParameter $level Filters revelation penalty operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltiesCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevelationPenaltiesCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRevelationPenaltiesCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetRevelationPenaltiesCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevelationPenaltiesCount'
     *
     * @param  AccountsGetIdParameter $level Filters revelation penalty operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters revelation penalty operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltiesCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevelationPenaltiesCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetRevelationPenaltiesCount'][0])
    {




        $resourcePath = '/v1/operations/revelation_penalties/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetRevelationPenaltyById
     *
     * Get revelation penalty by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltyById'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\RevelationPenaltyOperation
     */
    public function operationsGetRevelationPenaltyById($id, $quote = null, string $contentType = self::contentTypes['operationsGetRevelationPenaltyById'][0])
    {
        list($response) = $this->operationsGetRevelationPenaltyByIdWithHttpInfo($id, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetRevelationPenaltyByIdWithHttpInfo
     *
     * Get revelation penalty by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltyById'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\RevelationPenaltyOperation, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetRevelationPenaltyByIdWithHttpInfo($id, $quote = null, string $contentType = self::contentTypes['operationsGetRevelationPenaltyById'][0])
    {
        $request = $this->operationsGetRevelationPenaltyByIdRequest($id, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\RevelationPenaltyOperation' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\RevelationPenaltyOperation' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\RevelationPenaltyOperation', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\RevelationPenaltyOperation';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\RevelationPenaltyOperation',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetRevelationPenaltyByIdAsync
     *
     * Get revelation penalty by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltyById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevelationPenaltyByIdAsync($id, $quote = null, string $contentType = self::contentTypes['operationsGetRevelationPenaltyById'][0])
    {
        return $this->operationsGetRevelationPenaltyByIdAsyncWithHttpInfo($id, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetRevelationPenaltyByIdAsyncWithHttpInfo
     *
     * Get revelation penalty by id
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltyById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetRevelationPenaltyByIdAsyncWithHttpInfo($id, $quote = null, string $contentType = self::contentTypes['operationsGetRevelationPenaltyById'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\RevelationPenaltyOperation';
        $request = $this->operationsGetRevelationPenaltyByIdRequest($id, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetRevelationPenaltyById'
     *
     * @param  int $id Operation id (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetRevelationPenaltyById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetRevelationPenaltyByIdRequest($id, $quote = null, string $contentType = self::contentTypes['operationsGetRevelationPenaltyById'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling operationsGetRevelationPenaltyById'
            );
        }



        $resourcePath = '/v1/operations/revelation_penalties/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSetDelegateParametersOps
     *
     * Get set_delegate_parameters ops
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\SetDelegateParametersOperation[]
     */
    public function operationsGetSetDelegateParametersOps($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSetDelegateParametersOps'][0])
    {
        list($response) = $this->operationsGetSetDelegateParametersOpsWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSetDelegateParametersOpsWithHttpInfo
     *
     * Get set_delegate_parameters ops
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\SetDelegateParametersOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSetDelegateParametersOpsWithHttpInfo($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSetDelegateParametersOps'][0])
    {
        $request = $this->operationsGetSetDelegateParametersOpsRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\SetDelegateParametersOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\SetDelegateParametersOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\SetDelegateParametersOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\SetDelegateParametersOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\SetDelegateParametersOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSetDelegateParametersOpsAsync
     *
     * Get set_delegate_parameters ops
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSetDelegateParametersOpsAsync($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSetDelegateParametersOps'][0])
    {
        return $this->operationsGetSetDelegateParametersOpsAsyncWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSetDelegateParametersOpsAsyncWithHttpInfo
     *
     * Get set_delegate_parameters ops
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSetDelegateParametersOpsAsyncWithHttpInfo($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSetDelegateParametersOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\SetDelegateParametersOperation[]';
        $request = $this->operationsGetSetDelegateParametersOpsRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSetDelegateParametersOps'
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSetDelegateParametersOpsRequest($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSetDelegateParametersOps'][0])
    {










        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSetDelegateParametersOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSetDelegateParametersOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/set_delegate_parameters';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSetDelegateParametersOpsCount
     *
     * Get set_delegate_parameters ops count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetSetDelegateParametersOpsCount($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSetDelegateParametersOpsCount'][0])
    {
        list($response) = $this->operationsGetSetDelegateParametersOpsCountWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSetDelegateParametersOpsCountWithHttpInfo
     *
     * Get set_delegate_parameters ops count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSetDelegateParametersOpsCountWithHttpInfo($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSetDelegateParametersOpsCount'][0])
    {
        $request = $this->operationsGetSetDelegateParametersOpsCountRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSetDelegateParametersOpsCountAsync
     *
     * Get set_delegate_parameters ops count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSetDelegateParametersOpsCountAsync($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSetDelegateParametersOpsCount'][0])
    {
        return $this->operationsGetSetDelegateParametersOpsCountAsyncWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSetDelegateParametersOpsCountAsyncWithHttpInfo
     *
     * Get set_delegate_parameters ops count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSetDelegateParametersOpsCountAsyncWithHttpInfo($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSetDelegateParametersOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetSetDelegateParametersOpsCountRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSetDelegateParametersOpsCount'
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDelegateParametersOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSetDelegateParametersOpsCountRequest($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSetDelegateParametersOpsCount'][0])
    {









        $resourcePath = '/v1/operations/set_delegate_parameters/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSetDepositsLimitByHash
     *
     * Get set deposits limit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\SetDepositsLimitOperation[]
     */
    public function operationsGetSetDepositsLimitByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimitByHash'][0])
    {
        list($response) = $this->operationsGetSetDepositsLimitByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSetDepositsLimitByHashWithHttpInfo
     *
     * Get set deposits limit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\SetDepositsLimitOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSetDepositsLimitByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimitByHash'][0])
    {
        $request = $this->operationsGetSetDepositsLimitByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\SetDepositsLimitOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\SetDepositsLimitOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\SetDepositsLimitOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\SetDepositsLimitOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\SetDepositsLimitOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSetDepositsLimitByHashAsync
     *
     * Get set deposits limit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSetDepositsLimitByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimitByHash'][0])
    {
        return $this->operationsGetSetDepositsLimitByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSetDepositsLimitByHashAsyncWithHttpInfo
     *
     * Get set deposits limit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSetDepositsLimitByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimitByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\SetDepositsLimitOperation[]';
        $request = $this->operationsGetSetDepositsLimitByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSetDepositsLimitByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSetDepositsLimitByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimitByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetSetDepositsLimitByHash'
            );
        }



        $resourcePath = '/v1/operations/set_deposits_limits/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSetDepositsLimitStatus
     *
     * Get set deposits limit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetSetDepositsLimitStatus($hash, string $contentType = self::contentTypes['operationsGetSetDepositsLimitStatus'][0])
    {
        list($response) = $this->operationsGetSetDepositsLimitStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSetDepositsLimitStatusWithHttpInfo
     *
     * Get set deposits limit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSetDepositsLimitStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetSetDepositsLimitStatus'][0])
    {
        $request = $this->operationsGetSetDepositsLimitStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSetDepositsLimitStatusAsync
     *
     * Get set deposits limit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSetDepositsLimitStatusAsync($hash, string $contentType = self::contentTypes['operationsGetSetDepositsLimitStatus'][0])
    {
        return $this->operationsGetSetDepositsLimitStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSetDepositsLimitStatusAsyncWithHttpInfo
     *
     * Get set deposits limit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSetDepositsLimitStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetSetDepositsLimitStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetSetDepositsLimitStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSetDepositsLimitStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSetDepositsLimitStatusRequest($hash, string $contentType = self::contentTypes['operationsGetSetDepositsLimitStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetSetDepositsLimitStatus'
            );
        }


        $resourcePath = '/v1/operations/set_deposits_limits/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSetDepositsLimits
     *
     * Get set deposits limits
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimits'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\SetDepositsLimitOperation[]
     */
    public function operationsGetSetDepositsLimits($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimits'][0])
    {
        list($response) = $this->operationsGetSetDepositsLimitsWithHttpInfo($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSetDepositsLimitsWithHttpInfo
     *
     * Get set deposits limits
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimits'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\SetDepositsLimitOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSetDepositsLimitsWithHttpInfo($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimits'][0])
    {
        $request = $this->operationsGetSetDepositsLimitsRequest($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\SetDepositsLimitOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\SetDepositsLimitOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\SetDepositsLimitOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\SetDepositsLimitOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\SetDepositsLimitOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSetDepositsLimitsAsync
     *
     * Get set deposits limits
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSetDepositsLimitsAsync($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimits'][0])
    {
        return $this->operationsGetSetDepositsLimitsAsyncWithHttpInfo($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSetDepositsLimitsAsyncWithHttpInfo
     *
     * Get set deposits limits
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSetDepositsLimitsAsyncWithHttpInfo($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimits'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\SetDepositsLimitOperation[]';
        $request = $this->operationsGetSetDepositsLimitsRequest($sender, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSetDepositsLimits'
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimits'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSetDepositsLimitsRequest($sender = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimits'][0])
    {








        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSetDepositsLimits, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSetDepositsLimits, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/set_deposits_limits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSetDepositsLimitsCount
     *
     * Get set deposits limits count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetSetDepositsLimitsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimitsCount'][0])
    {
        list($response) = $this->operationsGetSetDepositsLimitsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSetDepositsLimitsCountWithHttpInfo
     *
     * Get set deposits limits count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSetDepositsLimitsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimitsCount'][0])
    {
        $request = $this->operationsGetSetDepositsLimitsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSetDepositsLimitsCountAsync
     *
     * Get set deposits limits count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSetDepositsLimitsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimitsCount'][0])
    {
        return $this->operationsGetSetDepositsLimitsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSetDepositsLimitsCountAsyncWithHttpInfo
     *
     * Get set deposits limits count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSetDepositsLimitsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimitsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetSetDepositsLimitsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSetDepositsLimitsCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSetDepositsLimitsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSetDepositsLimitsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetSetDepositsLimitsCount'][0])
    {




        $resourcePath = '/v1/operations/set_deposits_limits/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOps
     *
     * Get smart rollup add messages
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\SmartRollupAddMessagesOperation[]
     */
    public function operationsGetSmartRollupAddMessagesOps($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOps'][0])
    {
        list($response) = $this->operationsGetSmartRollupAddMessagesOpsWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOpsWithHttpInfo
     *
     * Get smart rollup add messages
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\SmartRollupAddMessagesOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupAddMessagesOpsWithHttpInfo($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOps'][0])
    {
        $request = $this->operationsGetSmartRollupAddMessagesOpsRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\SmartRollupAddMessagesOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\SmartRollupAddMessagesOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\SmartRollupAddMessagesOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\SmartRollupAddMessagesOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\SmartRollupAddMessagesOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOpsAsync
     *
     * Get smart rollup add messages
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupAddMessagesOpsAsync($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOps'][0])
    {
        return $this->operationsGetSmartRollupAddMessagesOpsAsyncWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOpsAsyncWithHttpInfo
     *
     * Get smart rollup add messages
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupAddMessagesOpsAsyncWithHttpInfo($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\SmartRollupAddMessagesOperation[]';
        $request = $this->operationsGetSmartRollupAddMessagesOpsRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupAddMessagesOps'
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupAddMessagesOpsRequest($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOps'][0])
    {










        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupAddMessagesOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupAddMessagesOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/sr_add_messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOpsCount
     *
     * Get smart rollup add messages count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetSmartRollupAddMessagesOpsCount($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'][0])
    {
        list($response) = $this->operationsGetSmartRollupAddMessagesOpsCountWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOpsCountWithHttpInfo
     *
     * Get smart rollup add messages count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupAddMessagesOpsCountWithHttpInfo($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'][0])
    {
        $request = $this->operationsGetSmartRollupAddMessagesOpsCountRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOpsCountAsync
     *
     * Get smart rollup add messages count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupAddMessagesOpsCountAsync($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'][0])
    {
        return $this->operationsGetSmartRollupAddMessagesOpsCountAsyncWithHttpInfo($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupAddMessagesOpsCountAsyncWithHttpInfo
     *
     * Get smart rollup add messages count
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupAddMessagesOpsCountAsyncWithHttpInfo($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetSmartRollupAddMessagesOpsCountRequest($id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupAddMessagesOpsCount'
     *
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupAddMessagesOpsCountRequest($id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupAddMessagesOpsCount'][0])
    {









        $resourcePath = '/v1/operations/sr_add_messages/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupCementOps
     *
     * Get smart rollup cement
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\SmartRollupCementOperation[]
     */
    public function operationsGetSmartRollupCementOps($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupCementOps'][0])
    {
        list($response) = $this->operationsGetSmartRollupCementOpsWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupCementOpsWithHttpInfo
     *
     * Get smart rollup cement
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\SmartRollupCementOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupCementOpsWithHttpInfo($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupCementOps'][0])
    {
        $request = $this->operationsGetSmartRollupCementOpsRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\SmartRollupCementOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\SmartRollupCementOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\SmartRollupCementOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\SmartRollupCementOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\SmartRollupCementOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupCementOpsAsync
     *
     * Get smart rollup cement
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupCementOpsAsync($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupCementOps'][0])
    {
        return $this->operationsGetSmartRollupCementOpsAsyncWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupCementOpsAsyncWithHttpInfo
     *
     * Get smart rollup cement
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupCementOpsAsyncWithHttpInfo($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupCementOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\SmartRollupCementOperation[]';
        $request = $this->operationsGetSmartRollupCementOpsRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupCementOps'
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupCementOpsRequest($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupCementOps'][0])
    {











        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupCementOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupCementOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/sr_cement';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfSmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupCementOpsCount
     *
     * Get smart rollup cement count
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetSmartRollupCementOpsCount($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupCementOpsCount'][0])
    {
        list($response) = $this->operationsGetSmartRollupCementOpsCountWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupCementOpsCountWithHttpInfo
     *
     * Get smart rollup cement count
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupCementOpsCountWithHttpInfo($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupCementOpsCount'][0])
    {
        $request = $this->operationsGetSmartRollupCementOpsCountRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupCementOpsCountAsync
     *
     * Get smart rollup cement count
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupCementOpsCountAsync($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupCementOpsCount'][0])
    {
        return $this->operationsGetSmartRollupCementOpsCountAsyncWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupCementOpsCountAsyncWithHttpInfo
     *
     * Get smart rollup cement count
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupCementOpsCountAsyncWithHttpInfo($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupCementOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetSmartRollupCementOpsCountRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupCementOpsCount'
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupCementOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupCementOpsCountRequest($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupCementOpsCount'][0])
    {










        $resourcePath = '/v1/operations/sr_cement/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfSmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupExecuteOps
     *
     * Get smart rollup execute
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\SmartRollupExecuteOperation[]
     */
    public function operationsGetSmartRollupExecuteOps($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOps'][0])
    {
        list($response) = $this->operationsGetSmartRollupExecuteOpsWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupExecuteOpsWithHttpInfo
     *
     * Get smart rollup execute
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\SmartRollupExecuteOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupExecuteOpsWithHttpInfo($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOps'][0])
    {
        $request = $this->operationsGetSmartRollupExecuteOpsRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\SmartRollupExecuteOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\SmartRollupExecuteOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\SmartRollupExecuteOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\SmartRollupExecuteOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\SmartRollupExecuteOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupExecuteOpsAsync
     *
     * Get smart rollup execute
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupExecuteOpsAsync($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOps'][0])
    {
        return $this->operationsGetSmartRollupExecuteOpsAsyncWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupExecuteOpsAsyncWithHttpInfo
     *
     * Get smart rollup execute
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupExecuteOpsAsyncWithHttpInfo($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\SmartRollupExecuteOperation[]';
        $request = $this->operationsGetSmartRollupExecuteOpsRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupExecuteOps'
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupExecuteOpsRequest($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOps'][0])
    {











        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupExecuteOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupExecuteOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/sr_execute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfSmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupExecuteOpsCount
     *
     * Get smart rollup execute count
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetSmartRollupExecuteOpsCount($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOpsCount'][0])
    {
        list($response) = $this->operationsGetSmartRollupExecuteOpsCountWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupExecuteOpsCountWithHttpInfo
     *
     * Get smart rollup execute count
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupExecuteOpsCountWithHttpInfo($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOpsCount'][0])
    {
        $request = $this->operationsGetSmartRollupExecuteOpsCountRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupExecuteOpsCountAsync
     *
     * Get smart rollup execute count
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupExecuteOpsCountAsync($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOpsCount'][0])
    {
        return $this->operationsGetSmartRollupExecuteOpsCountAsyncWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupExecuteOpsCountAsyncWithHttpInfo
     *
     * Get smart rollup execute count
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupExecuteOpsCountAsyncWithHttpInfo($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetSmartRollupExecuteOpsCountRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupExecuteOpsCount'
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupExecuteOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupExecuteOpsCountRequest($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupExecuteOpsCount'][0])
    {










        $resourcePath = '/v1/operations/sr_execute/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfSmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupOriginateOps
     *
     * Get smart rollup originate
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameter type value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\SmartRollupOriginateOperation[]
     */
    public function operationsGetSmartRollupOriginateOps($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, $micheline = null, string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOps'][0])
    {
        list($response) = $this->operationsGetSmartRollupOriginateOpsWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $micheline, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupOriginateOpsWithHttpInfo
     *
     * Get smart rollup originate
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameter type value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\SmartRollupOriginateOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupOriginateOpsWithHttpInfo($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, $micheline = null, string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOps'][0])
    {
        $request = $this->operationsGetSmartRollupOriginateOpsRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $micheline, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\SmartRollupOriginateOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\SmartRollupOriginateOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\SmartRollupOriginateOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\SmartRollupOriginateOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\SmartRollupOriginateOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupOriginateOpsAsync
     *
     * Get smart rollup originate
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameter type value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupOriginateOpsAsync($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, $micheline = null, string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOps'][0])
    {
        return $this->operationsGetSmartRollupOriginateOpsAsyncWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $micheline, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupOriginateOpsAsyncWithHttpInfo
     *
     * Get smart rollup originate
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameter type value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupOriginateOpsAsyncWithHttpInfo($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, $micheline = null, string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\SmartRollupOriginateOperation[]';
        $request = $this->operationsGetSmartRollupOriginateOpsRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $micheline, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupOriginateOps'
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameter type value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupOriginateOpsRequest($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, $micheline = null, string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOps'][0])
    {











        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupOriginateOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupOriginateOps, must be bigger than or equal to 0.');
        }
        




        $resourcePath = '/v1/operations/sr_originate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfSmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupOriginateOpsCount
     *
     * Get smart rollup originate count
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetSmartRollupOriginateOpsCount($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOpsCount'][0])
    {
        list($response) = $this->operationsGetSmartRollupOriginateOpsCountWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupOriginateOpsCountWithHttpInfo
     *
     * Get smart rollup originate count
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupOriginateOpsCountWithHttpInfo($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOpsCount'][0])
    {
        $request = $this->operationsGetSmartRollupOriginateOpsCountRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupOriginateOpsCountAsync
     *
     * Get smart rollup originate count
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupOriginateOpsCountAsync($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOpsCount'][0])
    {
        return $this->operationsGetSmartRollupOriginateOpsCountAsyncWithHttpInfo($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupOriginateOpsCountAsyncWithHttpInfo
     *
     * Get smart rollup originate count
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupOriginateOpsCountAsyncWithHttpInfo($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetSmartRollupOriginateOpsCountRequest($rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupOriginateOpsCount'
     *
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupOriginateOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupOriginateOpsCountRequest($rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupOriginateOpsCount'][0])
    {










        $resourcePath = '/v1/operations/sr_originate/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfSmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupPublishOps
     *
     * Get smart rollup publish
     *
     * @param  AccountsGetIdParameter $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\SmartRollupPublishOperation[]
     */
    public function operationsGetSmartRollupPublishOps($commitment_id = null, $commitment_hash = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupPublishOps'][0])
    {
        list($response) = $this->operationsGetSmartRollupPublishOpsWithHttpInfo($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupPublishOpsWithHttpInfo
     *
     * Get smart rollup publish
     *
     * @param  AccountsGetIdParameter $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\SmartRollupPublishOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupPublishOpsWithHttpInfo($commitment_id = null, $commitment_hash = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupPublishOps'][0])
    {
        $request = $this->operationsGetSmartRollupPublishOpsRequest($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\SmartRollupPublishOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\SmartRollupPublishOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\SmartRollupPublishOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\SmartRollupPublishOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\SmartRollupPublishOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupPublishOpsAsync
     *
     * Get smart rollup publish
     *
     * @param  AccountsGetIdParameter $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupPublishOpsAsync($commitment_id = null, $commitment_hash = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupPublishOps'][0])
    {
        return $this->operationsGetSmartRollupPublishOpsAsyncWithHttpInfo($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupPublishOpsAsyncWithHttpInfo
     *
     * Get smart rollup publish
     *
     * @param  AccountsGetIdParameter $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupPublishOpsAsyncWithHttpInfo($commitment_id = null, $commitment_hash = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupPublishOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\SmartRollupPublishOperation[]';
        $request = $this->operationsGetSmartRollupPublishOpsRequest($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupPublishOps'
     *
     * @param  AccountsGetIdParameter $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupPublishOpsRequest($commitment_id = null, $commitment_hash = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupPublishOps'][0])
    {













        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupPublishOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupPublishOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/sr_publish';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commitment_id,
            'commitment.id', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commitment_hash,
            'commitment.hash', // param base name
            'OneOfSrc1HashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfSmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupPublishOpsCount
     *
     * Get smart rollup publish count
     *
     * @param  AccountsGetIdParameter $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetSmartRollupPublishOpsCount($commitment_id = null, $commitment_hash = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupPublishOpsCount'][0])
    {
        list($response) = $this->operationsGetSmartRollupPublishOpsCountWithHttpInfo($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupPublishOpsCountWithHttpInfo
     *
     * Get smart rollup publish count
     *
     * @param  AccountsGetIdParameter $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupPublishOpsCountWithHttpInfo($commitment_id = null, $commitment_hash = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupPublishOpsCount'][0])
    {
        $request = $this->operationsGetSmartRollupPublishOpsCountRequest($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupPublishOpsCountAsync
     *
     * Get smart rollup publish count
     *
     * @param  AccountsGetIdParameter $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupPublishOpsCountAsync($commitment_id = null, $commitment_hash = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupPublishOpsCount'][0])
    {
        return $this->operationsGetSmartRollupPublishOpsCountAsyncWithHttpInfo($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupPublishOpsCountAsyncWithHttpInfo
     *
     * Get smart rollup publish count
     *
     * @param  AccountsGetIdParameter $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupPublishOpsCountAsyncWithHttpInfo($commitment_id = null, $commitment_hash = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupPublishOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetSmartRollupPublishOpsCountRequest($commitment_id, $commitment_hash, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupPublishOpsCount'
     *
     * @param  AccountsGetIdParameter $commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupPublishOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupPublishOpsCountRequest($commitment_id = null, $commitment_hash = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupPublishOpsCount'][0])
    {












        $resourcePath = '/v1/operations/sr_publish/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commitment_id,
            'commitment.id', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $commitment_hash,
            'commitment.hash', // param base name
            'OneOfSrc1HashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfSmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOps
     *
     * Get smart rollup recover bond
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\SmartRollupRecoverBondOperation[]
     */
    public function operationsGetSmartRollupRecoverBondOps($anyof = null, $staker = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOps'][0])
    {
        list($response) = $this->operationsGetSmartRollupRecoverBondOpsWithHttpInfo($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOpsWithHttpInfo
     *
     * Get smart rollup recover bond
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\SmartRollupRecoverBondOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupRecoverBondOpsWithHttpInfo($anyof = null, $staker = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOps'][0])
    {
        $request = $this->operationsGetSmartRollupRecoverBondOpsRequest($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\SmartRollupRecoverBondOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\SmartRollupRecoverBondOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\SmartRollupRecoverBondOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\SmartRollupRecoverBondOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\SmartRollupRecoverBondOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOpsAsync
     *
     * Get smart rollup recover bond
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupRecoverBondOpsAsync($anyof = null, $staker = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOps'][0])
    {
        return $this->operationsGetSmartRollupRecoverBondOpsAsyncWithHttpInfo($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOpsAsyncWithHttpInfo
     *
     * Get smart rollup recover bond
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupRecoverBondOpsAsyncWithHttpInfo($anyof = null, $staker = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\SmartRollupRecoverBondOperation[]';
        $request = $this->operationsGetSmartRollupRecoverBondOpsRequest($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupRecoverBondOps'
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupRecoverBondOpsRequest($anyof = null, $staker = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOps'][0])
    {













        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupRecoverBondOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupRecoverBondOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/sr_recover_bond';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $staker,
            'staker', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfSmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOpsCount
     *
     * Get smart rollup recover bond count
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetSmartRollupRecoverBondOpsCount($anyof = null, $staker = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'][0])
    {
        list($response) = $this->operationsGetSmartRollupRecoverBondOpsCountWithHttpInfo($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOpsCountWithHttpInfo
     *
     * Get smart rollup recover bond count
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupRecoverBondOpsCountWithHttpInfo($anyof = null, $staker = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'][0])
    {
        $request = $this->operationsGetSmartRollupRecoverBondOpsCountRequest($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOpsCountAsync
     *
     * Get smart rollup recover bond count
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupRecoverBondOpsCountAsync($anyof = null, $staker = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'][0])
    {
        return $this->operationsGetSmartRollupRecoverBondOpsCountAsyncWithHttpInfo($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupRecoverBondOpsCountAsyncWithHttpInfo
     *
     * Get smart rollup recover bond count
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupRecoverBondOpsCountAsyncWithHttpInfo($anyof = null, $staker = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetSmartRollupRecoverBondOpsCountRequest($anyof, $staker, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupRecoverBondOpsCount'
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60; or &#x60;staker&#x60;). Example: &#x60;anyof.sender.staker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;staker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $staker Filter by staker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupRecoverBondOpsCountRequest($anyof = null, $staker = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupRecoverBondOpsCount'][0])
    {












        $resourcePath = '/v1/operations/sr_recover_bond/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $staker,
            'staker', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfSmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupRefuteOps
     *
     * Get smart rollup refute
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsMoveParameter $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\SmartRollupRefuteOperation[]
     */
    public function operationsGetSmartRollupRefuteOps($anyof = null, $game_id = null, $game_initiator = null, $game_initiator_commitment_id = null, $game_initiator_commitment_hash = null, $game_opponent = null, $game_opponent_commitment_id = null, $game_opponent_commitment_hash = null, $move = null, $game_status = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOps'][0])
    {
        list($response) = $this->operationsGetSmartRollupRefuteOpsWithHttpInfo($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupRefuteOpsWithHttpInfo
     *
     * Get smart rollup refute
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsMoveParameter $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\SmartRollupRefuteOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupRefuteOpsWithHttpInfo($anyof = null, $game_id = null, $game_initiator = null, $game_initiator_commitment_id = null, $game_initiator_commitment_hash = null, $game_opponent = null, $game_opponent_commitment_id = null, $game_opponent_commitment_hash = null, $move = null, $game_status = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOps'][0])
    {
        $request = $this->operationsGetSmartRollupRefuteOpsRequest($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\SmartRollupRefuteOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\SmartRollupRefuteOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\SmartRollupRefuteOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\SmartRollupRefuteOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\SmartRollupRefuteOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupRefuteOpsAsync
     *
     * Get smart rollup refute
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsMoveParameter $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupRefuteOpsAsync($anyof = null, $game_id = null, $game_initiator = null, $game_initiator_commitment_id = null, $game_initiator_commitment_hash = null, $game_opponent = null, $game_opponent_commitment_id = null, $game_opponent_commitment_hash = null, $move = null, $game_status = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOps'][0])
    {
        return $this->operationsGetSmartRollupRefuteOpsAsyncWithHttpInfo($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupRefuteOpsAsyncWithHttpInfo
     *
     * Get smart rollup refute
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsMoveParameter $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupRefuteOpsAsyncWithHttpInfo($anyof = null, $game_id = null, $game_initiator = null, $game_initiator_commitment_id = null, $game_initiator_commitment_hash = null, $game_opponent = null, $game_opponent_commitment_id = null, $game_opponent_commitment_hash = null, $move = null, $game_status = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\SmartRollupRefuteOperation[]';
        $request = $this->operationsGetSmartRollupRefuteOpsRequest($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupRefuteOps'
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsMoveParameter $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupRefuteOpsRequest($anyof = null, $game_id = null, $game_initiator = null, $game_initiator_commitment_id = null, $game_initiator_commitment_hash = null, $game_opponent = null, $game_opponent_commitment_id = null, $game_opponent_commitment_hash = null, $move = null, $game_status = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOps'][0])
    {





















        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupRefuteOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetSmartRollupRefuteOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/sr_refute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_id,
            'game.id', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_initiator,
            'game.initiator', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_initiator_commitment_id,
            'game.initiatorCommitment.id', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_initiator_commitment_hash,
            'game.initiatorCommitment.hash', // param base name
            'OneOfSrc1HashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_opponent,
            'game.opponent', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_opponent_commitment_id,
            'game.opponentCommitment.id', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_opponent_commitment_hash,
            'game.opponentCommitment.hash', // param base name
            'OneOfSrc1HashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $move,
            'move', // param base name
            'OneOfRefutationMoveParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_status,
            'gameStatus', // param base name
            'OneOfRefutationGameStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfSmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetSmartRollupRefuteOpsCount
     *
     * Get smart rollup refute count
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsMoveParameter $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetSmartRollupRefuteOpsCount($anyof = null, $game_id = null, $game_initiator = null, $game_initiator_commitment_id = null, $game_initiator_commitment_hash = null, $game_opponent = null, $game_opponent_commitment_id = null, $game_opponent_commitment_hash = null, $move = null, $game_status = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOpsCount'][0])
    {
        list($response) = $this->operationsGetSmartRollupRefuteOpsCountWithHttpInfo($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetSmartRollupRefuteOpsCountWithHttpInfo
     *
     * Get smart rollup refute count
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsMoveParameter $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetSmartRollupRefuteOpsCountWithHttpInfo($anyof = null, $game_id = null, $game_initiator = null, $game_initiator_commitment_id = null, $game_initiator_commitment_hash = null, $game_opponent = null, $game_opponent_commitment_id = null, $game_opponent_commitment_hash = null, $move = null, $game_status = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOpsCount'][0])
    {
        $request = $this->operationsGetSmartRollupRefuteOpsCountRequest($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetSmartRollupRefuteOpsCountAsync
     *
     * Get smart rollup refute count
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsMoveParameter $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupRefuteOpsCountAsync($anyof = null, $game_id = null, $game_initiator = null, $game_initiator_commitment_id = null, $game_initiator_commitment_hash = null, $game_opponent = null, $game_opponent_commitment_id = null, $game_opponent_commitment_hash = null, $move = null, $game_status = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOpsCount'][0])
    {
        return $this->operationsGetSmartRollupRefuteOpsCountAsyncWithHttpInfo($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetSmartRollupRefuteOpsCountAsyncWithHttpInfo
     *
     * Get smart rollup refute count
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsMoveParameter $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetSmartRollupRefuteOpsCountAsyncWithHttpInfo($anyof = null, $game_id = null, $game_initiator = null, $game_initiator_commitment_id = null, $game_initiator_commitment_hash = null, $game_opponent = null, $game_opponent_commitment_id = null, $game_opponent_commitment_hash = null, $move = null, $game_status = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetSmartRollupRefuteOpsCountRequest($anyof, $game_id, $game_initiator, $game_initiator_commitment_id, $game_initiator_commitment_hash, $game_opponent, $game_opponent_commitment_id, $game_opponent_commitment_hash, $move, $game_status, $rollup, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetSmartRollupRefuteOpsCount'
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, &#x60;initiator&#x60;, or &#x60;opponent&#x60;). Example: &#x60;anyof.initiator.opponent&#x3D;tz1...&#x60; will return operations where &#x60;initiator&#x60; OR &#x60;opponent&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_initiator Filter by initiator (who found a wrong commitment and started the refutation game).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_initiator_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_initiator_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $game_opponent Filter by opponent (who was accused in publishing a wrong commitment).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $game_opponent_commitment_id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupPublishOpsCommitmentHashParameter $game_opponent_commitment_hash Filter by commitment hash.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsMoveParameter $move Filter by refutation game move (&#x60;start&#x60;, &#x60;dissection&#x60;, &#x60;proof&#x60;, or &#x60;timeout&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupRefuteOpsGameStatusParameter $game_status Filter by refutation game status (&#x60;none&#x60;, &#x60;ongoing&#x60;, &#x60;loser&#x60;, or &#x60;draw&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupCementOpsRollupParameter $rollup Filter by rollup address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetSmartRollupRefuteOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetSmartRollupRefuteOpsCountRequest($anyof = null, $game_id = null, $game_initiator = null, $game_initiator_commitment_id = null, $game_initiator_commitment_hash = null, $game_opponent = null, $game_opponent_commitment_id = null, $game_opponent_commitment_hash = null, $move = null, $game_status = null, $rollup = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetSmartRollupRefuteOpsCount'][0])
    {




















        $resourcePath = '/v1/operations/sr_refute/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_id,
            'game.id', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_initiator,
            'game.initiator', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_initiator_commitment_id,
            'game.initiatorCommitment.id', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_initiator_commitment_hash,
            'game.initiatorCommitment.hash', // param base name
            'OneOfSrc1HashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_opponent,
            'game.opponent', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_opponent_commitment_id,
            'game.opponentCommitment.id', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_opponent_commitment_hash,
            'game.opponentCommitment.hash', // param base name
            'OneOfSrc1HashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $move,
            'move', // param base name
            'OneOfRefutationMoveParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $game_status,
            'gameStatus', // param base name
            'OneOfRefutationGameStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfSmartRollupParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetStakingOps
     *
     * Get staking ops
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\StakingOperation[]
     */
    public function operationsGetStakingOps($anyof = null, $baker = null, $action = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetStakingOps'][0])
    {
        list($response) = $this->operationsGetStakingOpsWithHttpInfo($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetStakingOpsWithHttpInfo
     *
     * Get staking ops
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\StakingOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetStakingOpsWithHttpInfo($anyof = null, $baker = null, $action = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetStakingOps'][0])
    {
        $request = $this->operationsGetStakingOpsRequest($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\StakingOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\StakingOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\StakingOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\StakingOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\StakingOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetStakingOpsAsync
     *
     * Get staking ops
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetStakingOpsAsync($anyof = null, $baker = null, $action = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetStakingOps'][0])
    {
        return $this->operationsGetStakingOpsAsyncWithHttpInfo($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetStakingOpsAsyncWithHttpInfo
     *
     * Get staking ops
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetStakingOpsAsyncWithHttpInfo($anyof = null, $baker = null, $action = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetStakingOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\StakingOperation[]';
        $request = $this->operationsGetStakingOpsRequest($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $sort, $offset, $limit, $select, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetStakingOps'
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetSortParameter $sort Sorts items (asc or desc) by the specified field. You can see what fields can be used for sorting in the response description, below.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped.   Click on the parameter to expand more details. (optional)
     * @param  int $limit Maximum number of items to return. (optional)
     * @param  BigMapsGetBigMapKeysSelectParameter $select Specify a comma-separated list of fields to include into response or leave it undefined to get default set of fields. This parameter accepts values of the following format: &#x60;{field}{path?}{as alias?}&#x60;, so you can do deep selection (for example, &#x60;?select&#x3D;balance,token.metadata.symbol as token,...&#x60;).   Note, if you select just one field, the response will be flatten into a simple array of values.   Click on the parameter to expand the details. (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetStakingOpsRequest($anyof = null, $baker = null, $action = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, $sort = null, $offset = null, $limit = null, $select = null, $quote = null, string $contentType = self::contentTypes['operationsGetStakingOps'][0])
    {













        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetStakingOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetStakingOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/staking';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action,
            'action', // param base name
            'OneOfStakingActionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetStakingOpsCount
     *
     * Get staking ops count
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetStakingOpsCount($anyof = null, $baker = null, $action = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetStakingOpsCount'][0])
    {
        list($response) = $this->operationsGetStakingOpsCountWithHttpInfo($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetStakingOpsCountWithHttpInfo
     *
     * Get staking ops count
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetStakingOpsCountWithHttpInfo($anyof = null, $baker = null, $action = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetStakingOpsCount'][0])
    {
        $request = $this->operationsGetStakingOpsCountRequest($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetStakingOpsCountAsync
     *
     * Get staking ops count
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetStakingOpsCountAsync($anyof = null, $baker = null, $action = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetStakingOpsCount'][0])
    {
        return $this->operationsGetStakingOpsCountAsyncWithHttpInfo($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetStakingOpsCountAsyncWithHttpInfo
     *
     * Get staking ops count
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetStakingOpsCountAsyncWithHttpInfo($anyof = null, $baker = null, $action = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetStakingOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetStakingOpsCountRequest($anyof, $baker, $action, $id, $hash, $counter, $level, $timestamp, $status, $sender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetStakingOpsCount'
     *
     * @param  BlocksGetAnyofParameter $anyof Filter by any of the specified fields (&#x60;sender&#x60;, or &#x60;baker&#x60;). Example: &#x60;anyof.sender.baker&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;baker&#x60; is equal to the specified value. This parameter is useful when you need to get all operations somehow related to the account in a single request.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $baker Filter by baker address.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetStakingOpsActionParameter $action Filter by staking action (&#x60;stake&#x60;, &#x60;unstake&#x60;, &#x60;finalize&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetBalanceParameter $id Filter by internal TzKT id.   Click on the parameter to expand more details. (optional)
     * @param  OperationsGetSmartRollupAddMessagesOpsHashParameter $hash Filter by operation hash.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $counter Filter by operation counter.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetIdParameter $level Filter by the domain level.   Click on the parameter to expand more details. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filter by timestamp (ISO 8601) of the operation.   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filter by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;).   Click on the parameter to expand more details. (optional)
     * @param  AccountsGetDelegateParameter $sender Filter by operation sender address.   Click on the parameter to expand more details. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStakingOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetStakingOpsCountRequest($anyof = null, $baker = null, $action = null, $id = null, $hash = null, $counter = null, $level = null, $timestamp = null, $status = null, $sender = null, string $contentType = self::contentTypes['operationsGetStakingOpsCount'][0])
    {












        $resourcePath = '/v1/operations/staking/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $action,
            'action', // param base name
            'OneOfStakingActionParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash,
            'hash', // param base name
            'OneOfOpHashParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $counter,
            'counter', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetStatus
     *
     * Get operation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetStatus($hash, string $contentType = self::contentTypes['operationsGetStatus'][0])
    {
        list($response) = $this->operationsGetStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetStatusWithHttpInfo
     *
     * Get operation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetStatus'][0])
    {
        $request = $this->operationsGetStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetStatusAsync
     *
     * Get operation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetStatusAsync($hash, string $contentType = self::contentTypes['operationsGetStatus'][0])
    {
        return $this->operationsGetStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetStatusAsyncWithHttpInfo
     *
     * Get operation status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetStatusRequest($hash, string $contentType = self::contentTypes['operationsGetStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetStatus'
            );
        }


        $resourcePath = '/v1/operations/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactionByHash
     *
     * Get transaction by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TransactionOperation[]
     */
    public function operationsGetTransactionByHash($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHash'][0])
    {
        list($response) = $this->operationsGetTransactionByHashWithHttpInfo($hash, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransactionByHashWithHttpInfo
     *
     * Get transaction by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TransactionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionByHashWithHttpInfo($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHash'][0])
    {
        $request = $this->operationsGetTransactionByHashRequest($hash, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TransactionOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TransactionOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TransactionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TransactionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionByHashAsync
     *
     * Get transaction by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionByHashAsync($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHash'][0])
    {
        return $this->operationsGetTransactionByHashAsyncWithHttpInfo($hash, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionByHashAsyncWithHttpInfo
     *
     * Get transaction by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionByHashAsyncWithHttpInfo($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
        $request = $this->operationsGetTransactionByHashRequest($hash, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactionByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionByHashRequest($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransactionByHash'
            );
        }




        $resourcePath = '/v1/operations/transactions/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactionByHashCounter
     *
     * Get transaction by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounter'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TransactionOperation[]
     */
    public function operationsGetTransactionByHashCounter($hash, $counter, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHashCounter'][0])
    {
        list($response) = $this->operationsGetTransactionByHashCounterWithHttpInfo($hash, $counter, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransactionByHashCounterWithHttpInfo
     *
     * Get transaction by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounter'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TransactionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionByHashCounterWithHttpInfo($hash, $counter, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHashCounter'][0])
    {
        $request = $this->operationsGetTransactionByHashCounterRequest($hash, $counter, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TransactionOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TransactionOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TransactionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TransactionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionByHashCounterAsync
     *
     * Get transaction by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionByHashCounterAsync($hash, $counter, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHashCounter'][0])
    {
        return $this->operationsGetTransactionByHashCounterAsyncWithHttpInfo($hash, $counter, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionByHashCounterAsyncWithHttpInfo
     *
     * Get transaction by hash and counter
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionByHashCounterAsyncWithHttpInfo($hash, $counter, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHashCounter'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
        $request = $this->operationsGetTransactionByHashCounterRequest($hash, $counter, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactionByHashCounter'
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounter'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionByHashCounterRequest($hash, $counter, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHashCounter'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransactionByHashCounter'
            );
        }

        // verify the required parameter 'counter' is set
        if ($counter === null || (is_array($counter) && count($counter) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $counter when calling operationsGetTransactionByHashCounter'
            );
        }




        $resourcePath = '/v1/operations/transactions/{hash}/{counter}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }
        // path params
        if ($counter !== null) {
            $resourcePath = str_replace(
                '{' . 'counter' . '}',
                ObjectSerializer::toPathValue($counter),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactionByHashCounterNonce
     *
     * Get transaction by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TransactionOperation[]
     */
    public function operationsGetTransactionByHashCounterNonce($hash, $counter, $nonce, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHashCounterNonce'][0])
    {
        list($response) = $this->operationsGetTransactionByHashCounterNonceWithHttpInfo($hash, $counter, $nonce, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransactionByHashCounterNonceWithHttpInfo
     *
     * Get transaction by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TransactionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionByHashCounterNonceWithHttpInfo($hash, $counter, $nonce, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHashCounterNonce'][0])
    {
        $request = $this->operationsGetTransactionByHashCounterNonceRequest($hash, $counter, $nonce, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TransactionOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TransactionOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TransactionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TransactionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionByHashCounterNonceAsync
     *
     * Get transaction by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionByHashCounterNonceAsync($hash, $counter, $nonce, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHashCounterNonce'][0])
    {
        return $this->operationsGetTransactionByHashCounterNonceAsyncWithHttpInfo($hash, $counter, $nonce, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionByHashCounterNonceAsyncWithHttpInfo
     *
     * Get transaction by hash, counter and nonce
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionByHashCounterNonceAsyncWithHttpInfo($hash, $counter, $nonce, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHashCounterNonce'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
        $request = $this->operationsGetTransactionByHashCounterNonceRequest($hash, $counter, $nonce, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactionByHashCounterNonce'
     *
     * @param  string $hash Operation hash (required)
     * @param  int $counter Operation counter (required)
     * @param  int $nonce Operation nonce (internal) (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionByHashCounterNonce'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionByHashCounterNonceRequest($hash, $counter, $nonce, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactionByHashCounterNonce'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransactionByHashCounterNonce'
            );
        }

        // verify the required parameter 'counter' is set
        if ($counter === null || (is_array($counter) && count($counter) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $counter when calling operationsGetTransactionByHashCounterNonce'
            );
        }

        // verify the required parameter 'nonce' is set
        if ($nonce === null || (is_array($nonce) && count($nonce) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $nonce when calling operationsGetTransactionByHashCounterNonce'
            );
        }




        $resourcePath = '/v1/operations/transactions/{hash}/{counter}/{nonce}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }
        // path params
        if ($counter !== null) {
            $resourcePath = str_replace(
                '{' . 'counter' . '}',
                ObjectSerializer::toPathValue($counter),
                $resourcePath
            );
        }
        // path params
        if ($nonce !== null) {
            $resourcePath = str_replace(
                '{' . 'nonce' . '}',
                ObjectSerializer::toPathValue($nonce),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactionStatus
     *
     * Get transaction status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetTransactionStatus($hash, string $contentType = self::contentTypes['operationsGetTransactionStatus'][0])
    {
        list($response) = $this->operationsGetTransactionStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransactionStatusWithHttpInfo
     *
     * Get transaction status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTransactionStatus'][0])
    {
        $request = $this->operationsGetTransactionStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionStatusAsync
     *
     * Get transaction status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionStatusAsync($hash, string $contentType = self::contentTypes['operationsGetTransactionStatus'][0])
    {
        return $this->operationsGetTransactionStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionStatusAsyncWithHttpInfo
     *
     * Get transaction status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTransactionStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetTransactionStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactionStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionStatusRequest($hash, string $contentType = self::contentTypes['operationsGetTransactionStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransactionStatus'
            );
        }


        $resourcePath = '/v1/operations/transactions/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactions
     *
     * Get transactions
     *
     * @param  BlocksGetAnyofParameter $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $amount Filters transactions by amount (micro tez). (optional)
     * @param  AccountsGetBalanceParameter $id Filters transactions by id. (optional)
     * @param  AccountsGetIdParameter $level Filters transactions by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $target_code_hash Filters by &#x60;targetCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;targetCodeHash&#x60;. (optional)
     * @param  AccountsGetOperationsEntrypointParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  AccountsGetOperationsParameterParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  AccountsGetStakedParameter $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactions'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TransactionOperation[]
     */
    public function operationsGetTransactions($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $id = null, $level = null, $timestamp = null, $sender_code_hash = null, $target_code_hash = null, $code_hash = null, $entrypoint = null, $parameter = null, $has_internals = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactions'][0])
    {
        list($response) = $this->operationsGetTransactionsWithHttpInfo($anyof, $initiator, $sender, $target, $amount, $id, $level, $timestamp, $sender_code_hash, $target_code_hash, $code_hash, $entrypoint, $parameter, $has_internals, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransactionsWithHttpInfo
     *
     * Get transactions
     *
     * @param  BlocksGetAnyofParameter $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $amount Filters transactions by amount (micro tez). (optional)
     * @param  AccountsGetBalanceParameter $id Filters transactions by id. (optional)
     * @param  AccountsGetIdParameter $level Filters transactions by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $target_code_hash Filters by &#x60;targetCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;targetCodeHash&#x60;. (optional)
     * @param  AccountsGetOperationsEntrypointParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  AccountsGetOperationsParameterParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  AccountsGetStakedParameter $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactions'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TransactionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionsWithHttpInfo($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $id = null, $level = null, $timestamp = null, $sender_code_hash = null, $target_code_hash = null, $code_hash = null, $entrypoint = null, $parameter = null, $has_internals = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactions'][0])
    {
        $request = $this->operationsGetTransactionsRequest($anyof, $initiator, $sender, $target, $amount, $id, $level, $timestamp, $sender_code_hash, $target_code_hash, $code_hash, $entrypoint, $parameter, $has_internals, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TransactionOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TransactionOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TransactionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TransactionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionsAsync
     *
     * Get transactions
     *
     * @param  BlocksGetAnyofParameter $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $amount Filters transactions by amount (micro tez). (optional)
     * @param  AccountsGetBalanceParameter $id Filters transactions by id. (optional)
     * @param  AccountsGetIdParameter $level Filters transactions by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $target_code_hash Filters by &#x60;targetCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;targetCodeHash&#x60;. (optional)
     * @param  AccountsGetOperationsEntrypointParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  AccountsGetOperationsParameterParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  AccountsGetStakedParameter $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionsAsync($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $id = null, $level = null, $timestamp = null, $sender_code_hash = null, $target_code_hash = null, $code_hash = null, $entrypoint = null, $parameter = null, $has_internals = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactions'][0])
    {
        return $this->operationsGetTransactionsAsyncWithHttpInfo($anyof, $initiator, $sender, $target, $amount, $id, $level, $timestamp, $sender_code_hash, $target_code_hash, $code_hash, $entrypoint, $parameter, $has_internals, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionsAsyncWithHttpInfo
     *
     * Get transactions
     *
     * @param  BlocksGetAnyofParameter $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $amount Filters transactions by amount (micro tez). (optional)
     * @param  AccountsGetBalanceParameter $id Filters transactions by id. (optional)
     * @param  AccountsGetIdParameter $level Filters transactions by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $target_code_hash Filters by &#x60;targetCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;targetCodeHash&#x60;. (optional)
     * @param  AccountsGetOperationsEntrypointParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  AccountsGetOperationsParameterParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  AccountsGetStakedParameter $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionsAsyncWithHttpInfo($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $id = null, $level = null, $timestamp = null, $sender_code_hash = null, $target_code_hash = null, $code_hash = null, $entrypoint = null, $parameter = null, $has_internals = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactions'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TransactionOperation[]';
        $request = $this->operationsGetTransactionsRequest($anyof, $initiator, $sender, $target, $amount, $id, $level, $timestamp, $sender_code_hash, $target_code_hash, $code_hash, $entrypoint, $parameter, $has_internals, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactions'
     *
     * @param  BlocksGetAnyofParameter $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $amount Filters transactions by amount (micro tez). (optional)
     * @param  AccountsGetBalanceParameter $id Filters transactions by id. (optional)
     * @param  AccountsGetIdParameter $level Filters transactions by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  AccountsGetIdParameter $sender_code_hash Filters by &#x60;senderCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $target_code_hash Filters by &#x60;targetCodeHash&#x60;. (optional)
     * @param  AccountsGetIdParameter $code_hash Filters by either &#x60;senderCodeHash&#x60; or &#x60;targetCodeHash&#x60;. (optional)
     * @param  AccountsGetOperationsEntrypointParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  AccountsGetOperationsParameterParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  AccountsGetStakedParameter $has_internals Filters transactions by presence of internal operations. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts transactions by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;, &#x60;allocationFee&#x60;, &#x60;amount&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the parameters, storage and diffs: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionsRequest($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $id = null, $level = null, $timestamp = null, $sender_code_hash = null, $target_code_hash = null, $code_hash = null, $entrypoint = null, $parameter = null, $has_internals = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransactions'][0])
    {



















        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTransactions, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTransactions, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/transactions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $initiator,
            'initiator', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target,
            'target', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender_code_hash,
            'senderCodeHash', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target_code_hash,
            'targetCodeHash', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $code_hash,
            'codeHash', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $entrypoint,
            'entrypoint', // param base name
            'OneOfStringParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parameter,
            'parameter', // param base name
            'OneOfJsonParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $has_internals,
            'hasInternals', // param base name
            'OneOfBoolParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransactionsCount
     *
     * Get transactions count
     *
     * @param  BlocksGetAnyofParameter $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $amount Filters transactions by amount (micro tez). (optional)
     * @param  AccountsGetIdParameter $level Filters transactions by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  AccountsGetOperationsEntrypointParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  AccountsGetOperationsParameterParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetTransactionsCount($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $level = null, $timestamp = null, $entrypoint = null, $parameter = null, $status = null, string $contentType = self::contentTypes['operationsGetTransactionsCount'][0])
    {
        list($response) = $this->operationsGetTransactionsCountWithHttpInfo($anyof, $initiator, $sender, $target, $amount, $level, $timestamp, $entrypoint, $parameter, $status, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransactionsCountWithHttpInfo
     *
     * Get transactions count
     *
     * @param  BlocksGetAnyofParameter $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $amount Filters transactions by amount (micro tez). (optional)
     * @param  AccountsGetIdParameter $level Filters transactions by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  AccountsGetOperationsEntrypointParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  AccountsGetOperationsParameterParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransactionsCountWithHttpInfo($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $level = null, $timestamp = null, $entrypoint = null, $parameter = null, $status = null, string $contentType = self::contentTypes['operationsGetTransactionsCount'][0])
    {
        $request = $this->operationsGetTransactionsCountRequest($anyof, $initiator, $sender, $target, $amount, $level, $timestamp, $entrypoint, $parameter, $status, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransactionsCountAsync
     *
     * Get transactions count
     *
     * @param  BlocksGetAnyofParameter $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $amount Filters transactions by amount (micro tez). (optional)
     * @param  AccountsGetIdParameter $level Filters transactions by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  AccountsGetOperationsEntrypointParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  AccountsGetOperationsParameterParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionsCountAsync($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $level = null, $timestamp = null, $entrypoint = null, $parameter = null, $status = null, string $contentType = self::contentTypes['operationsGetTransactionsCount'][0])
    {
        return $this->operationsGetTransactionsCountAsyncWithHttpInfo($anyof, $initiator, $sender, $target, $amount, $level, $timestamp, $entrypoint, $parameter, $status, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransactionsCountAsyncWithHttpInfo
     *
     * Get transactions count
     *
     * @param  BlocksGetAnyofParameter $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $amount Filters transactions by amount (micro tez). (optional)
     * @param  AccountsGetIdParameter $level Filters transactions by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  AccountsGetOperationsEntrypointParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  AccountsGetOperationsParameterParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransactionsCountAsyncWithHttpInfo($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $level = null, $timestamp = null, $entrypoint = null, $parameter = null, $status = null, string $contentType = self::contentTypes['operationsGetTransactionsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetTransactionsCountRequest($anyof, $initiator, $sender, $target, $amount, $level, $timestamp, $entrypoint, $parameter, $status, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransactionsCount'
     *
     * @param  BlocksGetAnyofParameter $anyof Filters transactions by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all transactions associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $initiator Filters transactions by initiator. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters transactions by sender. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;target&#x60;. (optional)
     * @param  AccountsGetDelegateParameter $target Filters transactions by target. Allowed fields for &#x60;.eqx&#x60; mode: &#x60;sender&#x60;, &#x60;initiator&#x60;. (optional)
     * @param  AccountsGetBalanceParameter $amount Filters transactions by amount (micro tez). (optional)
     * @param  AccountsGetIdParameter $level Filters transactions by level. (optional)
     * @param  BigMapsGetBigMapKeysFirstTimeParameter $timestamp Filters transactions by timestamp. (optional)
     * @param  AccountsGetOperationsEntrypointParameter $entrypoint Filters transactions by entrypoint called on the target contract. (optional)
     * @param  AccountsGetOperationsParameterParameter $parameter Filters transactions by parameter value. Note, this query parameter supports the following format: &#x60;?parameter{.path?}{.mode?}&#x3D;...&#x60;,             so you can specify a path to a particular field to filter by, for example: &#x60;?parameter.token_id&#x3D;...&#x60; or &#x60;?parameter.sigs.0.ne&#x3D;...&#x60;.             Also, note that &#x60;.value&#x60; part must be omitted in the path, so, for example, filtering by &#x60;parameter.value.foo&#x60; must be specified as &#x60;?parameter.foo&#x3D;...&#x60;. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters transactions by operation status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransactionsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransactionsCountRequest($anyof = null, $initiator = null, $sender = null, $target = null, $amount = null, $level = null, $timestamp = null, $entrypoint = null, $parameter = null, $status = null, string $contentType = self::contentTypes['operationsGetTransactionsCount'][0])
    {












        $resourcePath = '/v1/operations/transactions/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $initiator,
            'initiator', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target,
            'target', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $amount,
            'amount', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfTimestampParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $entrypoint,
            'entrypoint', // param base name
            'OneOfStringParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $parameter,
            'parameter', // param base name
            'OneOfJsonParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransferTicketOps
     *
     * Get transfer ticket
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters by id. (optional)
     * @param  AccountsGetDelegateParameter $ticketer Filters by ticketer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TransferTicketOperation[]
     */
    public function operationsGetTransferTicketOps($anyof = null, $sender = null, $target = null, $id = null, $ticketer = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransferTicketOps'][0])
    {
        list($response) = $this->operationsGetTransferTicketOpsWithHttpInfo($anyof, $sender, $target, $id, $ticketer, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransferTicketOpsWithHttpInfo
     *
     * Get transfer ticket
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters by id. (optional)
     * @param  AccountsGetDelegateParameter $ticketer Filters by ticketer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TransferTicketOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransferTicketOpsWithHttpInfo($anyof = null, $sender = null, $target = null, $id = null, $ticketer = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransferTicketOps'][0])
    {
        $request = $this->operationsGetTransferTicketOpsRequest($anyof, $sender, $target, $id, $ticketer, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TransferTicketOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TransferTicketOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TransferTicketOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TransferTicketOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TransferTicketOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransferTicketOpsAsync
     *
     * Get transfer ticket
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters by id. (optional)
     * @param  AccountsGetDelegateParameter $ticketer Filters by ticketer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransferTicketOpsAsync($anyof = null, $sender = null, $target = null, $id = null, $ticketer = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransferTicketOps'][0])
    {
        return $this->operationsGetTransferTicketOpsAsyncWithHttpInfo($anyof, $sender, $target, $id, $ticketer, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransferTicketOpsAsyncWithHttpInfo
     *
     * Get transfer ticket
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters by id. (optional)
     * @param  AccountsGetDelegateParameter $ticketer Filters by ticketer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransferTicketOpsAsyncWithHttpInfo($anyof = null, $sender = null, $target = null, $id = null, $ticketer = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransferTicketOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TransferTicketOperation[]';
        $request = $this->operationsGetTransferTicketOpsRequest($anyof, $sender, $target, $id, $ticketer, $level, $timestamp, $status, $select, $sort, $offset, $limit, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransferTicketOps'
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.target&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;target&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $target Filters by target. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetBalanceParameter $id Filters by id. (optional)
     * @param  AccountsGetDelegateParameter $ticketer Filters by ticketer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransferTicketOpsRequest($anyof = null, $sender = null, $target = null, $id = null, $ticketer = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransferTicketOps'][0])
    {












        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTransferTicketOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTransferTicketOps, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/operations/transfer_ticket';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $target,
            'target', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'OneOfInt64Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $ticketer,
            'ticketer', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransferTicketOpsByHash
     *
     * Get transfer ticket by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TransferTicketOperation[]
     */
    public function operationsGetTransferTicketOpsByHash($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransferTicketOpsByHash'][0])
    {
        list($response) = $this->operationsGetTransferTicketOpsByHashWithHttpInfo($hash, $micheline, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransferTicketOpsByHashWithHttpInfo
     *
     * Get transfer ticket by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TransferTicketOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransferTicketOpsByHashWithHttpInfo($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransferTicketOpsByHash'][0])
    {
        $request = $this->operationsGetTransferTicketOpsByHashRequest($hash, $micheline, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TransferTicketOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TransferTicketOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TransferTicketOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TransferTicketOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TransferTicketOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransferTicketOpsByHashAsync
     *
     * Get transfer ticket by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransferTicketOpsByHashAsync($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransferTicketOpsByHash'][0])
    {
        return $this->operationsGetTransferTicketOpsByHashAsyncWithHttpInfo($hash, $micheline, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransferTicketOpsByHashAsyncWithHttpInfo
     *
     * Get transfer ticket by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransferTicketOpsByHashAsyncWithHttpInfo($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransferTicketOpsByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TransferTicketOperation[]';
        $request = $this->operationsGetTransferTicketOpsByHashRequest($hash, $micheline, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransferTicketOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsMichelineParameter $micheline Format of the content value: &#x60;0&#x60; - JSON, &#x60;1&#x60; - JSON string, &#x60;2&#x60; - raw micheline, &#x60;3&#x60; - raw micheline string (optional)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransferTicketOpsByHashRequest($hash, $micheline = null, $quote = null, string $contentType = self::contentTypes['operationsGetTransferTicketOpsByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransferTicketOpsByHash'
            );
        }




        $resourcePath = '/v1/operations/transfer_ticket/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $micheline,
            'micheline', // param base name
            'OneOfMichelineFormat', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransferTicketOpsCount
     *
     * Get transfer ticket count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetTransferTicketOpsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTransferTicketOpsCount'][0])
    {
        list($response) = $this->operationsGetTransferTicketOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransferTicketOpsCountWithHttpInfo
     *
     * Get transfer ticket count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransferTicketOpsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTransferTicketOpsCount'][0])
    {
        $request = $this->operationsGetTransferTicketOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransferTicketOpsCountAsync
     *
     * Get transfer ticket count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransferTicketOpsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTransferTicketOpsCount'][0])
    {
        return $this->operationsGetTransferTicketOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransferTicketOpsCountAsyncWithHttpInfo
     *
     * Get transfer ticket count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransferTicketOpsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTransferTicketOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetTransferTicketOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransferTicketOpsCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransferTicketOpsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTransferTicketOpsCount'][0])
    {




        $resourcePath = '/v1/operations/transfer_ticket/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTransferTicketStatus
     *
     * Get transfer ticket status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetTransferTicketStatus($hash, string $contentType = self::contentTypes['operationsGetTransferTicketStatus'][0])
    {
        list($response) = $this->operationsGetTransferTicketStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTransferTicketStatusWithHttpInfo
     *
     * Get transfer ticket status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTransferTicketStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTransferTicketStatus'][0])
    {
        $request = $this->operationsGetTransferTicketStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTransferTicketStatusAsync
     *
     * Get transfer ticket status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransferTicketStatusAsync($hash, string $contentType = self::contentTypes['operationsGetTransferTicketStatus'][0])
    {
        return $this->operationsGetTransferTicketStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTransferTicketStatusAsyncWithHttpInfo
     *
     * Get transfer ticket status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTransferTicketStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTransferTicketStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetTransferTicketStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTransferTicketStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTransferTicketStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTransferTicketStatusRequest($hash, string $contentType = self::contentTypes['operationsGetTransferTicketStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTransferTicketStatus'
            );
        }


        $resourcePath = '/v1/operations/transfer_ticket/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupCommitOps
     *
     * Get tx rollup commit
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupCommitOperation[]
     */
    public function operationsGetTxRollupCommitOps($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOps'][0])
    {
        list($response) = $this->operationsGetTxRollupCommitOpsWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupCommitOpsWithHttpInfo
     *
     * Get tx rollup commit
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupCommitOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupCommitOpsWithHttpInfo($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOps'][0])
    {
        $request = $this->operationsGetTxRollupCommitOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupCommitOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupCommitOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupCommitOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupCommitOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupCommitOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupCommitOpsAsync
     *
     * Get tx rollup commit
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupCommitOpsAsync($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOps'][0])
    {
        return $this->operationsGetTxRollupCommitOpsAsyncWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupCommitOpsAsyncWithHttpInfo
     *
     * Get tx rollup commit
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupCommitOpsAsyncWithHttpInfo($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupCommitOperation[]';
        $request = $this->operationsGetTxRollupCommitOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupCommitOps'
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupCommitOpsRequest($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOps'][0])
    {









        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupCommitOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupCommitOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_commit';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupCommitOpsByHash
     *
     * Get tx rollup commit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupCommitOperation[]
     */
    public function operationsGetTxRollupCommitOpsByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsByHash'][0])
    {
        list($response) = $this->operationsGetTxRollupCommitOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupCommitOpsByHashWithHttpInfo
     *
     * Get tx rollup commit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupCommitOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupCommitOpsByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsByHash'][0])
    {
        $request = $this->operationsGetTxRollupCommitOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupCommitOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupCommitOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupCommitOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupCommitOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupCommitOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupCommitOpsByHashAsync
     *
     * Get tx rollup commit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupCommitOpsByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsByHash'][0])
    {
        return $this->operationsGetTxRollupCommitOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupCommitOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup commit by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupCommitOpsByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupCommitOperation[]';
        $request = $this->operationsGetTxRollupCommitOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupCommitOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupCommitOpsByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupCommitOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_commit/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupCommitOpsCount
     *
     * Get tx rollup commit count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupCommitOpsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsCount'][0])
    {
        list($response) = $this->operationsGetTxRollupCommitOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupCommitOpsCountWithHttpInfo
     *
     * Get tx rollup commit count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupCommitOpsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsCount'][0])
    {
        $request = $this->operationsGetTxRollupCommitOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupCommitOpsCountAsync
     *
     * Get tx rollup commit count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupCommitOpsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsCount'][0])
    {
        return $this->operationsGetTxRollupCommitOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupCommitOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup commit count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupCommitOpsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupCommitOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupCommitOpsCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupCommitOpsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupCommitOpsCount'][0])
    {




        $resourcePath = '/v1/operations/tx_rollup_commit/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupCommitStatus
     *
     * Get tx rollup commit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupCommitStatus($hash, string $contentType = self::contentTypes['operationsGetTxRollupCommitStatus'][0])
    {
        list($response) = $this->operationsGetTxRollupCommitStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupCommitStatusWithHttpInfo
     *
     * Get tx rollup commit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupCommitStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupCommitStatus'][0])
    {
        $request = $this->operationsGetTxRollupCommitStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupCommitStatusAsync
     *
     * Get tx rollup commit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupCommitStatusAsync($hash, string $contentType = self::contentTypes['operationsGetTxRollupCommitStatus'][0])
    {
        return $this->operationsGetTxRollupCommitStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupCommitStatusAsyncWithHttpInfo
     *
     * Get tx rollup commit status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupCommitStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupCommitStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupCommitStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupCommitStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupCommitStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupCommitStatusRequest($hash, string $contentType = self::contentTypes['operationsGetTxRollupCommitStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupCommitStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_commit/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOps
     *
     * Get tx rollup dispatch tickets
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[]
     */
    public function operationsGetTxRollupDispatchTicketsOps($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOps'][0])
    {
        list($response) = $this->operationsGetTxRollupDispatchTicketsOpsWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsWithHttpInfo
     *
     * Get tx rollup dispatch tickets
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupDispatchTicketsOpsWithHttpInfo($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOps'][0])
    {
        $request = $this->operationsGetTxRollupDispatchTicketsOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsAsync
     *
     * Get tx rollup dispatch tickets
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsOpsAsync($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOps'][0])
    {
        return $this->operationsGetTxRollupDispatchTicketsOpsAsyncWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsAsyncWithHttpInfo
     *
     * Get tx rollup dispatch tickets
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsOpsAsyncWithHttpInfo($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[]';
        $request = $this->operationsGetTxRollupDispatchTicketsOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupDispatchTicketsOps'
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupDispatchTicketsOpsRequest($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOps'][0])
    {









        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupDispatchTicketsOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupDispatchTicketsOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_dispatch_tickets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsByHash
     *
     * Get tx rollup dispatch tickets by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[]
     */
    public function operationsGetTxRollupDispatchTicketsOpsByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'][0])
    {
        list($response) = $this->operationsGetTxRollupDispatchTicketsOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsByHashWithHttpInfo
     *
     * Get tx rollup dispatch tickets by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupDispatchTicketsOpsByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'][0])
    {
        $request = $this->operationsGetTxRollupDispatchTicketsOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsByHashAsync
     *
     * Get tx rollup dispatch tickets by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsOpsByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'][0])
    {
        return $this->operationsGetTxRollupDispatchTicketsOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup dispatch tickets by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsOpsByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupDispatchTicketsOperation[]';
        $request = $this->operationsGetTxRollupDispatchTicketsOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupDispatchTicketsOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupDispatchTicketsOpsByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupDispatchTicketsOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_dispatch_tickets/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsCount
     *
     * Get tx rollup dispatch tickets count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupDispatchTicketsOpsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'][0])
    {
        list($response) = $this->operationsGetTxRollupDispatchTicketsOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsCountWithHttpInfo
     *
     * Get tx rollup dispatch tickets count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupDispatchTicketsOpsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'][0])
    {
        $request = $this->operationsGetTxRollupDispatchTicketsOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsCountAsync
     *
     * Get tx rollup dispatch tickets count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsOpsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'][0])
    {
        return $this->operationsGetTxRollupDispatchTicketsOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup dispatch tickets count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsOpsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupDispatchTicketsOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupDispatchTicketsOpsCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupDispatchTicketsOpsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsOpsCount'][0])
    {




        $resourcePath = '/v1/operations/tx_rollup_dispatch_tickets/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsStatus
     *
     * Get tx rollup dispatch tickets status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupDispatchTicketsStatus($hash, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'][0])
    {
        list($response) = $this->operationsGetTxRollupDispatchTicketsStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsStatusWithHttpInfo
     *
     * Get tx rollup dispatch tickets status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupDispatchTicketsStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'][0])
    {
        $request = $this->operationsGetTxRollupDispatchTicketsStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsStatusAsync
     *
     * Get tx rollup dispatch tickets status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsStatusAsync($hash, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'][0])
    {
        return $this->operationsGetTxRollupDispatchTicketsStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupDispatchTicketsStatusAsyncWithHttpInfo
     *
     * Get tx rollup dispatch tickets status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupDispatchTicketsStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupDispatchTicketsStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupDispatchTicketsStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupDispatchTicketsStatusRequest($hash, string $contentType = self::contentTypes['operationsGetTxRollupDispatchTicketsStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupDispatchTicketsStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_dispatch_tickets/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOps
     *
     * Get tx rollup finalize commitment
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]
     */
    public function operationsGetTxRollupFinalizeCommitmentOps($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'][0])
    {
        list($response) = $this->operationsGetTxRollupFinalizeCommitmentOpsWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsWithHttpInfo
     *
     * Get tx rollup finalize commitment
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsWithHttpInfo($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'][0])
    {
        $request = $this->operationsGetTxRollupFinalizeCommitmentOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsAsync
     *
     * Get tx rollup finalize commitment
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsAsync($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'][0])
    {
        return $this->operationsGetTxRollupFinalizeCommitmentOpsAsyncWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsAsyncWithHttpInfo
     *
     * Get tx rollup finalize commitment
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsAsyncWithHttpInfo($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]';
        $request = $this->operationsGetTxRollupFinalizeCommitmentOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupFinalizeCommitmentOps'
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsRequest($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOps'][0])
    {









        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupFinalizeCommitmentOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupFinalizeCommitmentOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_finalize_commitment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsByHash
     *
     * Get tx rollup finalize commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'][0])
    {
        list($response) = $this->operationsGetTxRollupFinalizeCommitmentOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsByHashWithHttpInfo
     *
     * Get tx rollup finalize commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'][0])
    {
        $request = $this->operationsGetTxRollupFinalizeCommitmentOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsByHashAsync
     *
     * Get tx rollup finalize commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'][0])
    {
        return $this->operationsGetTxRollupFinalizeCommitmentOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup finalize commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupFinalizeCommitmentOperation[]';
        $request = $this->operationsGetTxRollupFinalizeCommitmentOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupFinalizeCommitmentOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupFinalizeCommitmentOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_finalize_commitment/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsCount
     *
     * Get tx rollup finalize commitment count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'][0])
    {
        list($response) = $this->operationsGetTxRollupFinalizeCommitmentOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsCountWithHttpInfo
     *
     * Get tx rollup finalize commitment count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'][0])
    {
        $request = $this->operationsGetTxRollupFinalizeCommitmentOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsCountAsync
     *
     * Get tx rollup finalize commitment count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'][0])
    {
        return $this->operationsGetTxRollupFinalizeCommitmentOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup finalize commitment count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupFinalizeCommitmentOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupFinalizeCommitmentOpsCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupFinalizeCommitmentOpsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentOpsCount'][0])
    {




        $resourcePath = '/v1/operations/tx_rollup_finalize_commitment/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentStatus
     *
     * Get tx rollup finalize commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupFinalizeCommitmentStatus($hash, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'][0])
    {
        list($response) = $this->operationsGetTxRollupFinalizeCommitmentStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentStatusWithHttpInfo
     *
     * Get tx rollup finalize commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupFinalizeCommitmentStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'][0])
    {
        $request = $this->operationsGetTxRollupFinalizeCommitmentStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentStatusAsync
     *
     * Get tx rollup finalize commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentStatusAsync($hash, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'][0])
    {
        return $this->operationsGetTxRollupFinalizeCommitmentStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupFinalizeCommitmentStatusAsyncWithHttpInfo
     *
     * Get tx rollup finalize commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupFinalizeCommitmentStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupFinalizeCommitmentStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupFinalizeCommitmentStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupFinalizeCommitmentStatusRequest($hash, string $contentType = self::contentTypes['operationsGetTxRollupFinalizeCommitmentStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupFinalizeCommitmentStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_finalize_commitment/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupOriginationOps
     *
     * Get tx rollup origination
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupOriginationOperation[]
     */
    public function operationsGetTxRollupOriginationOps($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOps'][0])
    {
        list($response) = $this->operationsGetTxRollupOriginationOpsWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsWithHttpInfo
     *
     * Get tx rollup origination
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupOriginationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupOriginationOpsWithHttpInfo($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOps'][0])
    {
        $request = $this->operationsGetTxRollupOriginationOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupOriginationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupOriginationOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupOriginationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupOriginationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupOriginationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsAsync
     *
     * Get tx rollup origination
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupOriginationOpsAsync($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOps'][0])
    {
        return $this->operationsGetTxRollupOriginationOpsAsyncWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsAsyncWithHttpInfo
     *
     * Get tx rollup origination
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupOriginationOpsAsyncWithHttpInfo($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupOriginationOperation[]';
        $request = $this->operationsGetTxRollupOriginationOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupOriginationOps'
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupOriginationOpsRequest($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOps'][0])
    {









        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupOriginationOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupOriginationOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_origination';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsByHash
     *
     * Get tx rollup origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupOriginationOperation[]
     */
    public function operationsGetTxRollupOriginationOpsByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsByHash'][0])
    {
        list($response) = $this->operationsGetTxRollupOriginationOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsByHashWithHttpInfo
     *
     * Get tx rollup origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupOriginationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupOriginationOpsByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsByHash'][0])
    {
        $request = $this->operationsGetTxRollupOriginationOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupOriginationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupOriginationOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupOriginationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupOriginationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupOriginationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsByHashAsync
     *
     * Get tx rollup origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupOriginationOpsByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsByHash'][0])
    {
        return $this->operationsGetTxRollupOriginationOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup origination by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupOriginationOpsByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupOriginationOperation[]';
        $request = $this->operationsGetTxRollupOriginationOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupOriginationOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupOriginationOpsByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupOriginationOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_origination/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsCount
     *
     * Get tx rollup origination count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupOriginationOpsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsCount'][0])
    {
        list($response) = $this->operationsGetTxRollupOriginationOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsCountWithHttpInfo
     *
     * Get tx rollup origination count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupOriginationOpsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsCount'][0])
    {
        $request = $this->operationsGetTxRollupOriginationOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsCountAsync
     *
     * Get tx rollup origination count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupOriginationOpsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsCount'][0])
    {
        return $this->operationsGetTxRollupOriginationOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupOriginationOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup origination count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupOriginationOpsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupOriginationOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupOriginationOpsCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupOriginationOpsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupOriginationOpsCount'][0])
    {




        $resourcePath = '/v1/operations/tx_rollup_origination/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupOriginationStatus
     *
     * Get tx rollup origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupOriginationStatus($hash, string $contentType = self::contentTypes['operationsGetTxRollupOriginationStatus'][0])
    {
        list($response) = $this->operationsGetTxRollupOriginationStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupOriginationStatusWithHttpInfo
     *
     * Get tx rollup origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupOriginationStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupOriginationStatus'][0])
    {
        $request = $this->operationsGetTxRollupOriginationStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupOriginationStatusAsync
     *
     * Get tx rollup origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupOriginationStatusAsync($hash, string $contentType = self::contentTypes['operationsGetTxRollupOriginationStatus'][0])
    {
        return $this->operationsGetTxRollupOriginationStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupOriginationStatusAsyncWithHttpInfo
     *
     * Get tx rollup origination status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupOriginationStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupOriginationStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupOriginationStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupOriginationStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupOriginationStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupOriginationStatusRequest($hash, string $contentType = self::contentTypes['operationsGetTxRollupOriginationStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupOriginationStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_origination/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRejectionOps
     *
     * Get tx rollup rejection
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.committer&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;committer&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $committer Filters by committer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupRejectionOperation[]
     */
    public function operationsGetTxRollupRejectionOps($anyof = null, $sender = null, $committer = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOps'][0])
    {
        list($response) = $this->operationsGetTxRollupRejectionOpsWithHttpInfo($anyof, $sender, $committer, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsWithHttpInfo
     *
     * Get tx rollup rejection
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.committer&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;committer&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $committer Filters by committer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupRejectionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRejectionOpsWithHttpInfo($anyof = null, $sender = null, $committer = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOps'][0])
    {
        $request = $this->operationsGetTxRollupRejectionOpsRequest($anyof, $sender, $committer, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupRejectionOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupRejectionOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupRejectionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupRejectionOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupRejectionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsAsync
     *
     * Get tx rollup rejection
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.committer&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;committer&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $committer Filters by committer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRejectionOpsAsync($anyof = null, $sender = null, $committer = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOps'][0])
    {
        return $this->operationsGetTxRollupRejectionOpsAsyncWithHttpInfo($anyof, $sender, $committer, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsAsyncWithHttpInfo
     *
     * Get tx rollup rejection
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.committer&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;committer&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $committer Filters by committer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRejectionOpsAsyncWithHttpInfo($anyof = null, $sender = null, $committer = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupRejectionOperation[]';
        $request = $this->operationsGetTxRollupRejectionOpsRequest($anyof, $sender, $committer, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRejectionOps'
     *
     * @param  BlocksGetAnyofParameter $anyof Filters by any of the specified fields. Example: &#x60;anyof.sender.committer&#x3D;tz1...&#x60; will return operations where &#x60;sender&#x60; OR &#x60;committer&#x60; is equal to the specified value. This parameter is useful when you need to retrieve all operations associated with a specified account. (optional)
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $committer Filters by committer. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRejectionOpsRequest($anyof = null, $sender = null, $committer = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOps'][0])
    {











        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupRejectionOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupRejectionOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_rejection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $anyof,
            'anyof', // param base name
            'OneOfAnyOfParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $committer,
            'committer', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsByHash
     *
     * Get tx rollup rejection by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupRejectionOperation[]
     */
    public function operationsGetTxRollupRejectionOpsByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsByHash'][0])
    {
        list($response) = $this->operationsGetTxRollupRejectionOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsByHashWithHttpInfo
     *
     * Get tx rollup rejection by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupRejectionOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRejectionOpsByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsByHash'][0])
    {
        $request = $this->operationsGetTxRollupRejectionOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupRejectionOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupRejectionOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupRejectionOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupRejectionOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupRejectionOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsByHashAsync
     *
     * Get tx rollup rejection by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRejectionOpsByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsByHash'][0])
    {
        return $this->operationsGetTxRollupRejectionOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup rejection by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRejectionOpsByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupRejectionOperation[]';
        $request = $this->operationsGetTxRollupRejectionOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRejectionOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRejectionOpsByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupRejectionOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_rejection/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsCount
     *
     * Get tx rollup rejection count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupRejectionOpsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsCount'][0])
    {
        list($response) = $this->operationsGetTxRollupRejectionOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsCountWithHttpInfo
     *
     * Get tx rollup rejection count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRejectionOpsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsCount'][0])
    {
        $request = $this->operationsGetTxRollupRejectionOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsCountAsync
     *
     * Get tx rollup rejection count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRejectionOpsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsCount'][0])
    {
        return $this->operationsGetTxRollupRejectionOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRejectionOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup rejection count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRejectionOpsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupRejectionOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRejectionOpsCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRejectionOpsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupRejectionOpsCount'][0])
    {




        $resourcePath = '/v1/operations/tx_rollup_rejection/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRejectionStatus
     *
     * Get tx rollup rejection status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupRejectionStatus($hash, string $contentType = self::contentTypes['operationsGetTxRollupRejectionStatus'][0])
    {
        list($response) = $this->operationsGetTxRollupRejectionStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRejectionStatusWithHttpInfo
     *
     * Get tx rollup rejection status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRejectionStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupRejectionStatus'][0])
    {
        $request = $this->operationsGetTxRollupRejectionStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRejectionStatusAsync
     *
     * Get tx rollup rejection status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRejectionStatusAsync($hash, string $contentType = self::contentTypes['operationsGetTxRollupRejectionStatus'][0])
    {
        return $this->operationsGetTxRollupRejectionStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRejectionStatusAsyncWithHttpInfo
     *
     * Get tx rollup rejection status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRejectionStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupRejectionStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupRejectionStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRejectionStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRejectionStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRejectionStatusRequest($hash, string $contentType = self::contentTypes['operationsGetTxRollupRejectionStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupRejectionStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_rejection/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOps
     *
     * Get tx rollup remove commitment
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[]
     */
    public function operationsGetTxRollupRemoveCommitmentOps($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'][0])
    {
        list($response) = $this->operationsGetTxRollupRemoveCommitmentOpsWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsWithHttpInfo
     *
     * Get tx rollup remove commitment
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRemoveCommitmentOpsWithHttpInfo($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'][0])
    {
        $request = $this->operationsGetTxRollupRemoveCommitmentOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsAsync
     *
     * Get tx rollup remove commitment
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentOpsAsync($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'][0])
    {
        return $this->operationsGetTxRollupRemoveCommitmentOpsAsyncWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsAsyncWithHttpInfo
     *
     * Get tx rollup remove commitment
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentOpsAsyncWithHttpInfo($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[]';
        $request = $this->operationsGetTxRollupRemoveCommitmentOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRemoveCommitmentOps'
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRemoveCommitmentOpsRequest($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOps'][0])
    {









        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupRemoveCommitmentOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupRemoveCommitmentOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_remove_commitment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsByHash
     *
     * Get tx rollup remove commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[]
     */
    public function operationsGetTxRollupRemoveCommitmentOpsByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'][0])
    {
        list($response) = $this->operationsGetTxRollupRemoveCommitmentOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsByHashWithHttpInfo
     *
     * Get tx rollup remove commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRemoveCommitmentOpsByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'][0])
    {
        $request = $this->operationsGetTxRollupRemoveCommitmentOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsByHashAsync
     *
     * Get tx rollup remove commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentOpsByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'][0])
    {
        return $this->operationsGetTxRollupRemoveCommitmentOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup remove commitment by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentOpsByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupRemoveCommitmentOperation[]';
        $request = $this->operationsGetTxRollupRemoveCommitmentOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRemoveCommitmentOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRemoveCommitmentOpsByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupRemoveCommitmentOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_remove_commitment/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsCount
     *
     * Get tx rollup remove commitment count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupRemoveCommitmentOpsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'][0])
    {
        list($response) = $this->operationsGetTxRollupRemoveCommitmentOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsCountWithHttpInfo
     *
     * Get tx rollup remove commitment count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRemoveCommitmentOpsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'][0])
    {
        $request = $this->operationsGetTxRollupRemoveCommitmentOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsCountAsync
     *
     * Get tx rollup remove commitment count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentOpsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'][0])
    {
        return $this->operationsGetTxRollupRemoveCommitmentOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup remove commitment count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentOpsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupRemoveCommitmentOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRemoveCommitmentOpsCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRemoveCommitmentOpsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentOpsCount'][0])
    {




        $resourcePath = '/v1/operations/tx_rollup_remove_commitment/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentStatus
     *
     * Get tx rollup remove commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupRemoveCommitmentStatus($hash, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'][0])
    {
        list($response) = $this->operationsGetTxRollupRemoveCommitmentStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentStatusWithHttpInfo
     *
     * Get tx rollup remove commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupRemoveCommitmentStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'][0])
    {
        $request = $this->operationsGetTxRollupRemoveCommitmentStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentStatusAsync
     *
     * Get tx rollup remove commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentStatusAsync($hash, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'][0])
    {
        return $this->operationsGetTxRollupRemoveCommitmentStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupRemoveCommitmentStatusAsyncWithHttpInfo
     *
     * Get tx rollup remove commitment status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupRemoveCommitmentStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupRemoveCommitmentStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupRemoveCommitmentStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupRemoveCommitmentStatusRequest($hash, string $contentType = self::contentTypes['operationsGetTxRollupRemoveCommitmentStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupRemoveCommitmentStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_remove_commitment/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupReturnBondOps
     *
     * Get tx rollup return bond
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[]
     */
    public function operationsGetTxRollupReturnBondOps($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOps'][0])
    {
        list($response) = $this->operationsGetTxRollupReturnBondOpsWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsWithHttpInfo
     *
     * Get tx rollup return bond
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupReturnBondOpsWithHttpInfo($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOps'][0])
    {
        $request = $this->operationsGetTxRollupReturnBondOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsAsync
     *
     * Get tx rollup return bond
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupReturnBondOpsAsync($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOps'][0])
    {
        return $this->operationsGetTxRollupReturnBondOpsAsyncWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsAsyncWithHttpInfo
     *
     * Get tx rollup return bond
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupReturnBondOpsAsyncWithHttpInfo($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[]';
        $request = $this->operationsGetTxRollupReturnBondOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupReturnBondOps'
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupReturnBondOpsRequest($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOps'][0])
    {









        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupReturnBondOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupReturnBondOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_return_bond';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsByHash
     *
     * Get tx rollup return bond by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[]
     */
    public function operationsGetTxRollupReturnBondOpsByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'][0])
    {
        list($response) = $this->operationsGetTxRollupReturnBondOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsByHashWithHttpInfo
     *
     * Get tx rollup return bond by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupReturnBondOpsByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'][0])
    {
        $request = $this->operationsGetTxRollupReturnBondOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsByHashAsync
     *
     * Get tx rollup return bond by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupReturnBondOpsByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'][0])
    {
        return $this->operationsGetTxRollupReturnBondOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup return bond by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupReturnBondOpsByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupReturnBondOperation[]';
        $request = $this->operationsGetTxRollupReturnBondOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupReturnBondOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupReturnBondOpsByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupReturnBondOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_return_bond/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsCount
     *
     * Get tx rollup return bond count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupReturnBondOpsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsCount'][0])
    {
        list($response) = $this->operationsGetTxRollupReturnBondOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsCountWithHttpInfo
     *
     * Get tx rollup return bond count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupReturnBondOpsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsCount'][0])
    {
        $request = $this->operationsGetTxRollupReturnBondOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsCountAsync
     *
     * Get tx rollup return bond count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupReturnBondOpsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsCount'][0])
    {
        return $this->operationsGetTxRollupReturnBondOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupReturnBondOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup return bond count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupReturnBondOpsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupReturnBondOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupReturnBondOpsCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupReturnBondOpsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondOpsCount'][0])
    {




        $resourcePath = '/v1/operations/tx_rollup_return_bond/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupReturnBondStatus
     *
     * Get tx rollup return bond status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupReturnBondStatus($hash, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondStatus'][0])
    {
        list($response) = $this->operationsGetTxRollupReturnBondStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupReturnBondStatusWithHttpInfo
     *
     * Get tx rollup return bond status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupReturnBondStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondStatus'][0])
    {
        $request = $this->operationsGetTxRollupReturnBondStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupReturnBondStatusAsync
     *
     * Get tx rollup return bond status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupReturnBondStatusAsync($hash, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondStatus'][0])
    {
        return $this->operationsGetTxRollupReturnBondStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupReturnBondStatusAsyncWithHttpInfo
     *
     * Get tx rollup return bond status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupReturnBondStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupReturnBondStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupReturnBondStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupReturnBondStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupReturnBondStatusRequest($hash, string $contentType = self::contentTypes['operationsGetTxRollupReturnBondStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupReturnBondStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_return_bond/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOps
     *
     * Get tx rollup submit batch
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[]
     */
    public function operationsGetTxRollupSubmitBatchOps($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOps'][0])
    {
        list($response) = $this->operationsGetTxRollupSubmitBatchOpsWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsWithHttpInfo
     *
     * Get tx rollup submit batch
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupSubmitBatchOpsWithHttpInfo($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOps'][0])
    {
        $request = $this->operationsGetTxRollupSubmitBatchOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsAsync
     *
     * Get tx rollup submit batch
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchOpsAsync($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOps'][0])
    {
        return $this->operationsGetTxRollupSubmitBatchOpsAsyncWithHttpInfo($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsAsyncWithHttpInfo
     *
     * Get tx rollup submit batch
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchOpsAsyncWithHttpInfo($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[]';
        $request = $this->operationsGetTxRollupSubmitBatchOpsRequest($sender, $rollup, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupSubmitBatchOps'
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetDelegateParameter $rollup Filters by rollup. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;bakerFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupSubmitBatchOpsRequest($sender = null, $rollup = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOps'][0])
    {









        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupSubmitBatchOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetTxRollupSubmitBatchOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/tx_rollup_submit_batch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $rollup,
            'rollup', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsByHash
     *
     * Get tx rollup submit batch by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[]
     */
    public function operationsGetTxRollupSubmitBatchOpsByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'][0])
    {
        list($response) = $this->operationsGetTxRollupSubmitBatchOpsByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsByHashWithHttpInfo
     *
     * Get tx rollup submit batch by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupSubmitBatchOpsByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'][0])
    {
        $request = $this->operationsGetTxRollupSubmitBatchOpsByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsByHashAsync
     *
     * Get tx rollup submit batch by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchOpsByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'][0])
    {
        return $this->operationsGetTxRollupSubmitBatchOpsByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsByHashAsyncWithHttpInfo
     *
     * Get tx rollup submit batch by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchOpsByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\TxRollupSubmitBatchOperation[]';
        $request = $this->operationsGetTxRollupSubmitBatchOpsByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupSubmitBatchOpsByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupSubmitBatchOpsByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupSubmitBatchOpsByHash'
            );
        }



        $resourcePath = '/v1/operations/tx_rollup_submit_batch/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsCount
     *
     * Get tx rollup submit batch count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetTxRollupSubmitBatchOpsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'][0])
    {
        list($response) = $this->operationsGetTxRollupSubmitBatchOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsCountWithHttpInfo
     *
     * Get tx rollup submit batch count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupSubmitBatchOpsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'][0])
    {
        $request = $this->operationsGetTxRollupSubmitBatchOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsCountAsync
     *
     * Get tx rollup submit batch count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchOpsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'][0])
    {
        return $this->operationsGetTxRollupSubmitBatchOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchOpsCountAsyncWithHttpInfo
     *
     * Get tx rollup submit batch count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchOpsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetTxRollupSubmitBatchOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupSubmitBatchOpsCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupSubmitBatchOpsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchOpsCount'][0])
    {




        $resourcePath = '/v1/operations/tx_rollup_submit_batch/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchStatus
     *
     * Get tx rollup submit batch status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return bool
     */
    public function operationsGetTxRollupSubmitBatchStatus($hash, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchStatus'][0])
    {
        list($response) = $this->operationsGetTxRollupSubmitBatchStatusWithHttpInfo($hash, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchStatusWithHttpInfo
     *
     * Get tx rollup submit batch status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchStatus'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of bool, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetTxRollupSubmitBatchStatusWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchStatus'][0])
    {
        $request = $this->operationsGetTxRollupSubmitBatchStatusRequest($hash, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('bool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('bool' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'bool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'bool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'bool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchStatusAsync
     *
     * Get tx rollup submit batch status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchStatusAsync($hash, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchStatus'][0])
    {
        return $this->operationsGetTxRollupSubmitBatchStatusAsyncWithHttpInfo($hash, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetTxRollupSubmitBatchStatusAsyncWithHttpInfo
     *
     * Get tx rollup submit batch status
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetTxRollupSubmitBatchStatusAsyncWithHttpInfo($hash, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchStatus'][0])
    {
        $returnType = 'bool';
        $request = $this->operationsGetTxRollupSubmitBatchStatusRequest($hash, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetTxRollupSubmitBatchStatus'
     *
     * @param  string $hash Operation hash (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetTxRollupSubmitBatchStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetTxRollupSubmitBatchStatusRequest($hash, string $contentType = self::contentTypes['operationsGetTxRollupSubmitBatchStatus'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetTxRollupSubmitBatchStatus'
            );
        }


        $resourcePath = '/v1/operations/tx_rollup_submit_batch/{hash}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetUpdateConsensusKeyByHash
     *
     * Get update consensus key by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[]
     */
    public function operationsGetUpdateConsensusKeyByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyByHash'][0])
    {
        list($response) = $this->operationsGetUpdateConsensusKeyByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetUpdateConsensusKeyByHashWithHttpInfo
     *
     * Get update consensus key by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetUpdateConsensusKeyByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyByHash'][0])
    {
        $request = $this->operationsGetUpdateConsensusKeyByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetUpdateConsensusKeyByHashAsync
     *
     * Get update consensus key by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetUpdateConsensusKeyByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyByHash'][0])
    {
        return $this->operationsGetUpdateConsensusKeyByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetUpdateConsensusKeyByHashAsyncWithHttpInfo
     *
     * Get update consensus key by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetUpdateConsensusKeyByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[]';
        $request = $this->operationsGetUpdateConsensusKeyByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetUpdateConsensusKeyByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetUpdateConsensusKeyByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetUpdateConsensusKeyByHash'
            );
        }



        $resourcePath = '/v1/operations/update_consensus_key/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOps
     *
     * Get update consensus key
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $activation_cycle Filters by activation cycle. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[]
     */
    public function operationsGetUpdateConsensusKeyOps($sender = null, $activation_cycle = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOps'][0])
    {
        list($response) = $this->operationsGetUpdateConsensusKeyOpsWithHttpInfo($sender, $activation_cycle, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOpsWithHttpInfo
     *
     * Get update consensus key
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $activation_cycle Filters by activation cycle. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOps'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetUpdateConsensusKeyOpsWithHttpInfo($sender = null, $activation_cycle = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOps'][0])
    {
        $request = $this->operationsGetUpdateConsensusKeyOpsRequest($sender, $activation_cycle, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOpsAsync
     *
     * Get update consensus key
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $activation_cycle Filters by activation cycle. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetUpdateConsensusKeyOpsAsync($sender = null, $activation_cycle = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOps'][0])
    {
        return $this->operationsGetUpdateConsensusKeyOpsAsyncWithHttpInfo($sender, $activation_cycle, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOpsAsyncWithHttpInfo
     *
     * Get update consensus key
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $activation_cycle Filters by activation cycle. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetUpdateConsensusKeyOpsAsyncWithHttpInfo($sender = null, $activation_cycle = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOps'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\UpdateConsensusKeyOperation[]';
        $request = $this->operationsGetUpdateConsensusKeyOpsRequest($sender, $activation_cycle, $level, $timestamp, $status, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetUpdateConsensusKeyOps'
     *
     * @param  AccountsGetDelegateParameter $sender Filters by sender. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $activation_cycle Filters by activation cycle. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetOperationsStatusParameter $status Filters by status (&#x60;applied&#x60;, &#x60;failed&#x60;, &#x60;backtracked&#x60;, &#x60;skipped&#x60;). (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts operations by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;, &#x60;gasUsed&#x60;, &#x60;storageUsed&#x60;, &#x60;bakerFee&#x60;, &#x60;storageFee&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOps'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetUpdateConsensusKeyOpsRequest($sender = null, $activation_cycle = null, $level = null, $timestamp = null, $status = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOps'][0])
    {









        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetUpdateConsensusKeyOps, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetUpdateConsensusKeyOps, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/update_consensus_key';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sender,
            'sender', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $activation_cycle,
            'activationCycle', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'OneOfOperationStatusParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOpsCount
     *
     * Get update consensus key count
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetUpdateConsensusKeyOpsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'][0])
    {
        list($response) = $this->operationsGetUpdateConsensusKeyOpsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOpsCountWithHttpInfo
     *
     * Get update consensus key count
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetUpdateConsensusKeyOpsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'][0])
    {
        $request = $this->operationsGetUpdateConsensusKeyOpsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOpsCountAsync
     *
     * Get update consensus key count
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetUpdateConsensusKeyOpsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'][0])
    {
        return $this->operationsGetUpdateConsensusKeyOpsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetUpdateConsensusKeyOpsCountAsyncWithHttpInfo
     *
     * Get update consensus key count
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetUpdateConsensusKeyOpsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetUpdateConsensusKeyOpsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetUpdateConsensusKeyOpsCount'
     *
     * @param  AccountsGetIdParameter $level Filters operations by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters operations by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetUpdateConsensusKeyOpsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetUpdateConsensusKeyOpsCount'][0])
    {




        $resourcePath = '/v1/operations/update_consensus_key/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetVdfRevelationByHash
     *
     * Get vdf revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\VdfRevelationOperation[]
     */
    public function operationsGetVdfRevelationByHash($hash, $quote = null, string $contentType = self::contentTypes['operationsGetVdfRevelationByHash'][0])
    {
        list($response) = $this->operationsGetVdfRevelationByHashWithHttpInfo($hash, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetVdfRevelationByHashWithHttpInfo
     *
     * Get vdf revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationByHash'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\VdfRevelationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetVdfRevelationByHashWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetVdfRevelationByHash'][0])
    {
        $request = $this->operationsGetVdfRevelationByHashRequest($hash, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\VdfRevelationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\VdfRevelationOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\VdfRevelationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\VdfRevelationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\VdfRevelationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetVdfRevelationByHashAsync
     *
     * Get vdf revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetVdfRevelationByHashAsync($hash, $quote = null, string $contentType = self::contentTypes['operationsGetVdfRevelationByHash'][0])
    {
        return $this->operationsGetVdfRevelationByHashAsyncWithHttpInfo($hash, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetVdfRevelationByHashAsyncWithHttpInfo
     *
     * Get vdf revelation by hash
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetVdfRevelationByHashAsyncWithHttpInfo($hash, $quote = null, string $contentType = self::contentTypes['operationsGetVdfRevelationByHash'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\VdfRevelationOperation[]';
        $request = $this->operationsGetVdfRevelationByHashRequest($hash, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetVdfRevelationByHash'
     *
     * @param  string $hash Operation hash (required)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationByHash'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetVdfRevelationByHashRequest($hash, $quote = null, string $contentType = self::contentTypes['operationsGetVdfRevelationByHash'][0])
    {

        // verify the required parameter 'hash' is set
        if ($hash === null || (is_array($hash) && count($hash) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hash when calling operationsGetVdfRevelationByHash'
            );
        }



        $resourcePath = '/v1/operations/vdf_revelations/{hash}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($hash !== null) {
            $resourcePath = str_replace(
                '{' . 'hash' . '}',
                ObjectSerializer::toPathValue($hash),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetVdfRevelations
     *
     * Get vdf revelations
     *
     * @param  AccountsGetDelegateParameter $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetIdParameter $cycle Filters by cycle in which the operation was included. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelations'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Bzzhh\Tzkt\Model\VdfRevelationOperation[]
     */
    public function operationsGetVdfRevelations($baker = null, $level = null, $cycle = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetVdfRevelations'][0])
    {
        list($response) = $this->operationsGetVdfRevelationsWithHttpInfo($baker, $level, $cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetVdfRevelationsWithHttpInfo
     *
     * Get vdf revelations
     *
     * @param  AccountsGetDelegateParameter $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetIdParameter $cycle Filters by cycle in which the operation was included. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelations'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Bzzhh\Tzkt\Model\VdfRevelationOperation[], HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetVdfRevelationsWithHttpInfo($baker = null, $level = null, $cycle = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetVdfRevelations'][0])
    {
        $request = $this->operationsGetVdfRevelationsRequest($baker, $level, $cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Bzzhh\Tzkt\Model\VdfRevelationOperation[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Bzzhh\Tzkt\Model\VdfRevelationOperation[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Bzzhh\Tzkt\Model\VdfRevelationOperation[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Bzzhh\Tzkt\Model\VdfRevelationOperation[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Bzzhh\Tzkt\Model\VdfRevelationOperation[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetVdfRevelationsAsync
     *
     * Get vdf revelations
     *
     * @param  AccountsGetDelegateParameter $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetIdParameter $cycle Filters by cycle in which the operation was included. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetVdfRevelationsAsync($baker = null, $level = null, $cycle = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetVdfRevelations'][0])
    {
        return $this->operationsGetVdfRevelationsAsyncWithHttpInfo($baker, $level, $cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetVdfRevelationsAsyncWithHttpInfo
     *
     * Get vdf revelations
     *
     * @param  AccountsGetDelegateParameter $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetIdParameter $cycle Filters by cycle in which the operation was included. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetVdfRevelationsAsyncWithHttpInfo($baker = null, $level = null, $cycle = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetVdfRevelations'][0])
    {
        $returnType = '\Bzzhh\Tzkt\Model\VdfRevelationOperation[]';
        $request = $this->operationsGetVdfRevelationsRequest($baker, $level, $cycle, $timestamp, $select, $sort, $offset, $limit, $quote, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetVdfRevelations'
     *
     * @param  AccountsGetDelegateParameter $baker Filters by baker. Allowed fields for &#x60;.eqx&#x60; mode: none. (optional)
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetIdParameter $cycle Filters by cycle in which the operation was included. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  AccountsGetSelectParameter $select Specify comma-separated list of fields to include into response or leave it undefined to return full object. If you select single field, response will be an array of values in both &#x60;.fields&#x60; and &#x60;.values&#x60; modes. (optional)
     * @param  AccountsGetSortParameter $sort Sorts by specified field. Supported fields: &#x60;id&#x60; (default), &#x60;level&#x60;. (optional)
     * @param  AccountsGetOffsetParameter $offset Specifies which or how many items should be skipped (optional)
     * @param  int $limit Maximum number of items to return (optional, default to 100)
     * @param  AccountsGetOperationsQuoteParameter $quote Comma-separated list of ticker symbols to inject historical prices into response (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelations'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetVdfRevelationsRequest($baker = null, $level = null, $cycle = null, $timestamp = null, $select = null, $sort = null, $offset = null, $limit = 100, $quote = null, string $contentType = self::contentTypes['operationsGetVdfRevelations'][0])
    {








        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetVdfRevelations, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling OperationsApi.operationsGetVdfRevelations, must be bigger than or equal to 0.');
        }
        


        $resourcePath = '/v1/operations/vdf_revelations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $baker,
            'baker', // param base name
            'OneOfAccountParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cycle,
            'cycle', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $select,
            'select', // param base name
            'OneOfSelectParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'OneOfSortParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'OneOfOffsetParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quote,
            'quote', // param base name
            'OneOfSymbols', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation operationsGetVdfRevelationsCount
     *
     * Get vdf revelations count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return int
     */
    public function operationsGetVdfRevelationsCount($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetVdfRevelationsCount'][0])
    {
        list($response) = $this->operationsGetVdfRevelationsCountWithHttpInfo($level, $timestamp, $contentType);
        return $response;
    }

    /**
     * Operation operationsGetVdfRevelationsCountWithHttpInfo
     *
     * Get vdf revelations count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationsCount'] to see the possible values for this operation
     *
     * @throws \Bzzhh\Tzkt\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of int, HTTP status code, HTTP response headers (array of strings)
     */
    public function operationsGetVdfRevelationsCountWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetVdfRevelationsCount'][0])
    {
        $request = $this->operationsGetVdfRevelationsCountRequest($level, $timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('int' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('int' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'int', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'int';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'int',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation operationsGetVdfRevelationsCountAsync
     *
     * Get vdf revelations count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetVdfRevelationsCountAsync($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetVdfRevelationsCount'][0])
    {
        return $this->operationsGetVdfRevelationsCountAsyncWithHttpInfo($level, $timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation operationsGetVdfRevelationsCountAsyncWithHttpInfo
     *
     * Get vdf revelations count
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function operationsGetVdfRevelationsCountAsyncWithHttpInfo($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetVdfRevelationsCount'][0])
    {
        $returnType = 'int';
        $request = $this->operationsGetVdfRevelationsCountRequest($level, $timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'operationsGetVdfRevelationsCount'
     *
     * @param  AccountsGetIdParameter $level Filters by level. (optional)
     * @param  AccountsGetOperationsTimestampParameter $timestamp Filters by timestamp. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['operationsGetVdfRevelationsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function operationsGetVdfRevelationsCountRequest($level = null, $timestamp = null, string $contentType = self::contentTypes['operationsGetVdfRevelationsCount'][0])
    {




        $resourcePath = '/v1/operations/vdf_revelations/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $level,
            'level', // param base name
            'OneOfInt32Parameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timestamp,
            'timestamp', // param base name
            'OneOfDateTimeParameter', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
