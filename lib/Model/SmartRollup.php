<?php
/**
 * SmartRollup
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Bzzhh\Tzkt
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * TzKT API
 *
 * # Introduction  TzKT Explorer provides free REST API and WebSocket API for accessing detailed Tezos blockchain data and helps developers build more services and applications on top of Tezos. TzKT is an open-source project, so you can easily clone and build it and use it as a self-hosted service to avoid any risks of depending on third-party services.  TzKT API is available for the following Tezos networks with the following base URLs:   - Mainnet: `https://api.tzkt.io/` or `https://api.mainnet.tzkt.io/` ([view docs](https://api.tzkt.io))  - Ghostnet: `https://api.ghostnet.tzkt.io/` ([view docs](https://api.ghostnet.tzkt.io)) - Mumbainet: `https://api.mumbainet.tzkt.io/` ([view docs](https://api.mumbainet.tzkt.io)) - Nairobinet: `https://api.nairobinet.tzkt.io/` ([view docs](https://api.nairobinet.tzkt.io))  We also provide a staging environment for testing newest features and pre-updating client applications before deploying to production:  - Mainnet staging: `https://staging.api.tzkt.io/` or `https://staging.api.mainnet.tzkt.io/` ([view docs](https://staging.api.tzkt.io))  Feel free to contact us if you have any questions or feature requests. Your feedback really helps us make TzKT better!  - Discord: https://discord.gg/aG8XKuwsQd - Telegram: https://t.me/baking_bad_chat - Slack: https://tezos-dev.slack.com/archives/CV5NX7F2L - Twitter: https://twitter.com/TezosBakingBad - Email: hello@bakingbad.dev  And don't forget to star TzKT project [on GitHub](https://github.com/baking-bad/tzkt) ;)  # Terms of Use  TzKT API is free for everyone and for both commercial and non-commercial usage.  If your application or service uses the TzKT API in any forms: directly on frontend or indirectly on backend, you must mention that fact on your website or application by placing the label **\"Powered by TzKT API\"** or **\"Built with TzKT API\"** with a direct link to [tzkt.io](https://tzkt.io).   # Rate Limits  There will be no rate limits as long as our servers can handle the load without additional infrastructure costs. However, any apparent abuse will be prevented by setting targeted rate limits.  Check out [Tezos Explorer API Best Practices](https://baking-bad.org/blog/tag/TzKT/) and in particular [how to optimize requests count](https://baking-bad.org/blog/2020/07/29/tezos-explorer-api-tzkt-how-often-to-make-requests/).  ---
 *
 * The version of the OpenAPI document: 1.12.1
 * Contact: hello@bakingbad.dev
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Bzzhh\Tzkt\Model;
use \Bzzhh\Tzkt\ObjectSerializer;

/**
 * SmartRollup Class Doc Comment
 *
 * @category Class
 * @package  Bzzhh\Tzkt
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class SmartRollup extends Account
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'SmartRollup';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'id' => 'int',
        'type' => 'string',
        'address' => 'string',
        'alias' => 'string',
        'creator' => 'OneOfAlias',
        'pvm_kind' => 'string',
        'genesis_commitment' => 'string',
        'last_commitment' => 'string',
        'inbox_level' => 'int',
        'total_stakers' => 'int',
        'active_stakers' => 'int',
        'executed_commitments' => 'int',
        'cemented_commitments' => 'int',
        'pending_commitments' => 'int',
        'refuted_commitments' => 'int',
        'orphan_commitments' => 'int',
        'smart_rollup_bonds' => 'int',
        'active_tokens_count' => 'int',
        'token_balances_count' => 'int',
        'token_transfers_count' => 'int',
        'num_transactions' => 'int',
        'transfer_ticket_count' => 'int',
        'smart_rollup_cement_count' => 'int',
        'smart_rollup_execute_count' => 'int',
        'smart_rollup_originate_count' => 'int',
        'smart_rollup_publish_count' => 'int',
        'smart_rollup_recover_bond_count' => 'int',
        'smart_rollup_refute_count' => 'int',
        'refutation_games_count' => 'int',
        'active_refutation_games_count' => 'int',
        'first_activity' => 'int',
        'first_activity_time' => '\DateTime',
        'last_activity' => 'int',
        'last_activity_time' => '\DateTime',
        'extras' => 'mixed'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'id' => 'int32',
        'type' => null,
        'address' => null,
        'alias' => null,
        'creator' => null,
        'pvm_kind' => null,
        'genesis_commitment' => null,
        'last_commitment' => null,
        'inbox_level' => 'int32',
        'total_stakers' => 'int32',
        'active_stakers' => 'int32',
        'executed_commitments' => 'int32',
        'cemented_commitments' => 'int32',
        'pending_commitments' => 'int32',
        'refuted_commitments' => 'int32',
        'orphan_commitments' => 'int32',
        'smart_rollup_bonds' => 'int64',
        'active_tokens_count' => 'int32',
        'token_balances_count' => 'int32',
        'token_transfers_count' => 'int32',
        'num_transactions' => 'int32',
        'transfer_ticket_count' => 'int32',
        'smart_rollup_cement_count' => 'int32',
        'smart_rollup_execute_count' => 'int32',
        'smart_rollup_originate_count' => 'int32',
        'smart_rollup_publish_count' => 'int32',
        'smart_rollup_recover_bond_count' => 'int32',
        'smart_rollup_refute_count' => 'int32',
        'refutation_games_count' => 'int32',
        'active_refutation_games_count' => 'int32',
        'first_activity' => 'int32',
        'first_activity_time' => 'date-time',
        'last_activity' => 'int32',
        'last_activity_time' => 'date-time',
        'extras' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'id' => false,
		'type' => true,
		'address' => true,
		'alias' => true,
		'creator' => true,
		'pvm_kind' => true,
		'genesis_commitment' => true,
		'last_commitment' => true,
		'inbox_level' => false,
		'total_stakers' => false,
		'active_stakers' => false,
		'executed_commitments' => false,
		'cemented_commitments' => false,
		'pending_commitments' => false,
		'refuted_commitments' => false,
		'orphan_commitments' => false,
		'smart_rollup_bonds' => false,
		'active_tokens_count' => false,
		'token_balances_count' => false,
		'token_transfers_count' => false,
		'num_transactions' => false,
		'transfer_ticket_count' => false,
		'smart_rollup_cement_count' => false,
		'smart_rollup_execute_count' => false,
		'smart_rollup_originate_count' => false,
		'smart_rollup_publish_count' => false,
		'smart_rollup_recover_bond_count' => false,
		'smart_rollup_refute_count' => false,
		'refutation_games_count' => false,
		'active_refutation_games_count' => false,
		'first_activity' => false,
		'first_activity_time' => false,
		'last_activity' => false,
		'last_activity_time' => false,
		'extras' => true
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes + parent::openAPITypes();
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats + parent::openAPIFormats();
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables + parent::openAPINullables();
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'type' => 'type',
        'address' => 'address',
        'alias' => 'alias',
        'creator' => 'creator',
        'pvm_kind' => 'pvmKind',
        'genesis_commitment' => 'genesisCommitment',
        'last_commitment' => 'lastCommitment',
        'inbox_level' => 'inboxLevel',
        'total_stakers' => 'totalStakers',
        'active_stakers' => 'activeStakers',
        'executed_commitments' => 'executedCommitments',
        'cemented_commitments' => 'cementedCommitments',
        'pending_commitments' => 'pendingCommitments',
        'refuted_commitments' => 'refutedCommitments',
        'orphan_commitments' => 'orphanCommitments',
        'smart_rollup_bonds' => 'smartRollupBonds',
        'active_tokens_count' => 'activeTokensCount',
        'token_balances_count' => 'tokenBalancesCount',
        'token_transfers_count' => 'tokenTransfersCount',
        'num_transactions' => 'numTransactions',
        'transfer_ticket_count' => 'transferTicketCount',
        'smart_rollup_cement_count' => 'smartRollupCementCount',
        'smart_rollup_execute_count' => 'smartRollupExecuteCount',
        'smart_rollup_originate_count' => 'smartRollupOriginateCount',
        'smart_rollup_publish_count' => 'smartRollupPublishCount',
        'smart_rollup_recover_bond_count' => 'smartRollupRecoverBondCount',
        'smart_rollup_refute_count' => 'smartRollupRefuteCount',
        'refutation_games_count' => 'refutationGamesCount',
        'active_refutation_games_count' => 'activeRefutationGamesCount',
        'first_activity' => 'firstActivity',
        'first_activity_time' => 'firstActivityTime',
        'last_activity' => 'lastActivity',
        'last_activity_time' => 'lastActivityTime',
        'extras' => 'extras'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'type' => 'setType',
        'address' => 'setAddress',
        'alias' => 'setAlias',
        'creator' => 'setCreator',
        'pvm_kind' => 'setPvmKind',
        'genesis_commitment' => 'setGenesisCommitment',
        'last_commitment' => 'setLastCommitment',
        'inbox_level' => 'setInboxLevel',
        'total_stakers' => 'setTotalStakers',
        'active_stakers' => 'setActiveStakers',
        'executed_commitments' => 'setExecutedCommitments',
        'cemented_commitments' => 'setCementedCommitments',
        'pending_commitments' => 'setPendingCommitments',
        'refuted_commitments' => 'setRefutedCommitments',
        'orphan_commitments' => 'setOrphanCommitments',
        'smart_rollup_bonds' => 'setSmartRollupBonds',
        'active_tokens_count' => 'setActiveTokensCount',
        'token_balances_count' => 'setTokenBalancesCount',
        'token_transfers_count' => 'setTokenTransfersCount',
        'num_transactions' => 'setNumTransactions',
        'transfer_ticket_count' => 'setTransferTicketCount',
        'smart_rollup_cement_count' => 'setSmartRollupCementCount',
        'smart_rollup_execute_count' => 'setSmartRollupExecuteCount',
        'smart_rollup_originate_count' => 'setSmartRollupOriginateCount',
        'smart_rollup_publish_count' => 'setSmartRollupPublishCount',
        'smart_rollup_recover_bond_count' => 'setSmartRollupRecoverBondCount',
        'smart_rollup_refute_count' => 'setSmartRollupRefuteCount',
        'refutation_games_count' => 'setRefutationGamesCount',
        'active_refutation_games_count' => 'setActiveRefutationGamesCount',
        'first_activity' => 'setFirstActivity',
        'first_activity_time' => 'setFirstActivityTime',
        'last_activity' => 'setLastActivity',
        'last_activity_time' => 'setLastActivityTime',
        'extras' => 'setExtras'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'type' => 'getType',
        'address' => 'getAddress',
        'alias' => 'getAlias',
        'creator' => 'getCreator',
        'pvm_kind' => 'getPvmKind',
        'genesis_commitment' => 'getGenesisCommitment',
        'last_commitment' => 'getLastCommitment',
        'inbox_level' => 'getInboxLevel',
        'total_stakers' => 'getTotalStakers',
        'active_stakers' => 'getActiveStakers',
        'executed_commitments' => 'getExecutedCommitments',
        'cemented_commitments' => 'getCementedCommitments',
        'pending_commitments' => 'getPendingCommitments',
        'refuted_commitments' => 'getRefutedCommitments',
        'orphan_commitments' => 'getOrphanCommitments',
        'smart_rollup_bonds' => 'getSmartRollupBonds',
        'active_tokens_count' => 'getActiveTokensCount',
        'token_balances_count' => 'getTokenBalancesCount',
        'token_transfers_count' => 'getTokenTransfersCount',
        'num_transactions' => 'getNumTransactions',
        'transfer_ticket_count' => 'getTransferTicketCount',
        'smart_rollup_cement_count' => 'getSmartRollupCementCount',
        'smart_rollup_execute_count' => 'getSmartRollupExecuteCount',
        'smart_rollup_originate_count' => 'getSmartRollupOriginateCount',
        'smart_rollup_publish_count' => 'getSmartRollupPublishCount',
        'smart_rollup_recover_bond_count' => 'getSmartRollupRecoverBondCount',
        'smart_rollup_refute_count' => 'getSmartRollupRefuteCount',
        'refutation_games_count' => 'getRefutationGamesCount',
        'active_refutation_games_count' => 'getActiveRefutationGamesCount',
        'first_activity' => 'getFirstActivity',
        'first_activity_time' => 'getFirstActivityTime',
        'last_activity' => 'getLastActivity',
        'last_activity_time' => 'getLastActivityTime',
        'extras' => 'getExtras'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return parent::attributeMap() + self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return parent::setters() + self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return parent::getters() + self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }



    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        parent::__construct($data);

        $this->setIfExists('id', $data ?? [], null);
        $this->setIfExists('type', $data ?? [], null);
        $this->setIfExists('address', $data ?? [], null);
        $this->setIfExists('alias', $data ?? [], null);
        $this->setIfExists('creator', $data ?? [], null);
        $this->setIfExists('pvm_kind', $data ?? [], null);
        $this->setIfExists('genesis_commitment', $data ?? [], null);
        $this->setIfExists('last_commitment', $data ?? [], null);
        $this->setIfExists('inbox_level', $data ?? [], null);
        $this->setIfExists('total_stakers', $data ?? [], null);
        $this->setIfExists('active_stakers', $data ?? [], null);
        $this->setIfExists('executed_commitments', $data ?? [], null);
        $this->setIfExists('cemented_commitments', $data ?? [], null);
        $this->setIfExists('pending_commitments', $data ?? [], null);
        $this->setIfExists('refuted_commitments', $data ?? [], null);
        $this->setIfExists('orphan_commitments', $data ?? [], null);
        $this->setIfExists('smart_rollup_bonds', $data ?? [], null);
        $this->setIfExists('active_tokens_count', $data ?? [], null);
        $this->setIfExists('token_balances_count', $data ?? [], null);
        $this->setIfExists('token_transfers_count', $data ?? [], null);
        $this->setIfExists('num_transactions', $data ?? [], null);
        $this->setIfExists('transfer_ticket_count', $data ?? [], null);
        $this->setIfExists('smart_rollup_cement_count', $data ?? [], null);
        $this->setIfExists('smart_rollup_execute_count', $data ?? [], null);
        $this->setIfExists('smart_rollup_originate_count', $data ?? [], null);
        $this->setIfExists('smart_rollup_publish_count', $data ?? [], null);
        $this->setIfExists('smart_rollup_recover_bond_count', $data ?? [], null);
        $this->setIfExists('smart_rollup_refute_count', $data ?? [], null);
        $this->setIfExists('refutation_games_count', $data ?? [], null);
        $this->setIfExists('active_refutation_games_count', $data ?? [], null);
        $this->setIfExists('first_activity', $data ?? [], null);
        $this->setIfExists('first_activity_time', $data ?? [], null);
        $this->setIfExists('last_activity', $data ?? [], null);
        $this->setIfExists('last_activity_time', $data ?? [], null);
        $this->setIfExists('extras', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = parent::listInvalidProperties();

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return int|null
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param int|null $id Internal TzKT id
     *
     * @return self
     */
    public function setId($id)
    {

        if (is_null($id)) {
            throw new \InvalidArgumentException('non-nullable id cannot be null');
        }

        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets type
     *
     * @return string|null
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string|null $type Type of the account
     *
     * @return self
     */
    public function setType($type)
    {

        if (is_null($type)) {
            array_push($this->openAPINullablesSetToNull, 'type');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('type', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets address
     *
     * @return string|null
     */
    public function getAddress()
    {
        return $this->container['address'];
    }

    /**
     * Sets address
     *
     * @param string|null $address Address of the account
     *
     * @return self
     */
    public function setAddress($address)
    {

        if (is_null($address)) {
            array_push($this->openAPINullablesSetToNull, 'address');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('address', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['address'] = $address;

        return $this;
    }

    /**
     * Gets alias
     *
     * @return string|null
     */
    public function getAlias()
    {
        return $this->container['alias'];
    }

    /**
     * Sets alias
     *
     * @param string|null $alias Name of the account
     *
     * @return self
     */
    public function setAlias($alias)
    {

        if (is_null($alias)) {
            array_push($this->openAPINullablesSetToNull, 'alias');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('alias', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['alias'] = $alias;

        return $this;
    }

    /**
     * Gets creator
     *
     * @return OneOfAlias|null
     */
    public function getCreator()
    {
        return $this->container['creator'];
    }

    /**
     * Sets creator
     *
     * @param OneOfAlias|null $creator Information about the account, which has deployed the rollup to the blockchain
     *
     * @return self
     */
    public function setCreator($creator)
    {

        if (is_null($creator)) {
            array_push($this->openAPINullablesSetToNull, 'creator');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('creator', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['creator'] = $creator;

        return $this;
    }

    /**
     * Gets pvm_kind
     *
     * @return string|null
     */
    public function getPvmKind()
    {
        return $this->container['pvm_kind'];
    }

    /**
     * Sets pvm_kind
     *
     * @param string|null $pvm_kind PVM kind: `arith` or `wasm`
     *
     * @return self
     */
    public function setPvmKind($pvm_kind)
    {

        if (is_null($pvm_kind)) {
            array_push($this->openAPINullablesSetToNull, 'pvm_kind');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('pvm_kind', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['pvm_kind'] = $pvm_kind;

        return $this;
    }

    /**
     * Gets genesis_commitment
     *
     * @return string|null
     */
    public function getGenesisCommitment()
    {
        return $this->container['genesis_commitment'];
    }

    /**
     * Sets genesis_commitment
     *
     * @param string|null $genesis_commitment Genesis commitment hash
     *
     * @return self
     */
    public function setGenesisCommitment($genesis_commitment)
    {

        if (is_null($genesis_commitment)) {
            array_push($this->openAPINullablesSetToNull, 'genesis_commitment');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('genesis_commitment', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['genesis_commitment'] = $genesis_commitment;

        return $this;
    }

    /**
     * Gets last_commitment
     *
     * @return string|null
     */
    public function getLastCommitment()
    {
        return $this->container['last_commitment'];
    }

    /**
     * Sets last_commitment
     *
     * @param string|null $last_commitment The most recent cemented commitment hash
     *
     * @return self
     */
    public function setLastCommitment($last_commitment)
    {

        if (is_null($last_commitment)) {
            array_push($this->openAPINullablesSetToNull, 'last_commitment');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('last_commitment', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['last_commitment'] = $last_commitment;

        return $this;
    }

    /**
     * Gets inbox_level
     *
     * @return int|null
     */
    public function getInboxLevel()
    {
        return $this->container['inbox_level'];
    }

    /**
     * Sets inbox_level
     *
     * @param int|null $inbox_level Inbox level of the most recent cemented commitment
     *
     * @return self
     */
    public function setInboxLevel($inbox_level)
    {

        if (is_null($inbox_level)) {
            throw new \InvalidArgumentException('non-nullable inbox_level cannot be null');
        }

        $this->container['inbox_level'] = $inbox_level;

        return $this;
    }

    /**
     * Gets total_stakers
     *
     * @return int|null
     */
    public function getTotalStakers()
    {
        return $this->container['total_stakers'];
    }

    /**
     * Sets total_stakers
     *
     * @param int|null $total_stakers Total number of stakers.
     *
     * @return self
     */
    public function setTotalStakers($total_stakers)
    {

        if (is_null($total_stakers)) {
            throw new \InvalidArgumentException('non-nullable total_stakers cannot be null');
        }

        $this->container['total_stakers'] = $total_stakers;

        return $this;
    }

    /**
     * Gets active_stakers
     *
     * @return int|null
     */
    public function getActiveStakers()
    {
        return $this->container['active_stakers'];
    }

    /**
     * Sets active_stakers
     *
     * @param int|null $active_stakers Total number of active stakers.
     *
     * @return self
     */
    public function setActiveStakers($active_stakers)
    {

        if (is_null($active_stakers)) {
            throw new \InvalidArgumentException('non-nullable active_stakers cannot be null');
        }

        $this->container['active_stakers'] = $active_stakers;

        return $this;
    }

    /**
     * Gets executed_commitments
     *
     * @return int|null
     */
    public function getExecutedCommitments()
    {
        return $this->container['executed_commitments'];
    }

    /**
     * Sets executed_commitments
     *
     * @param int|null $executed_commitments Number of commitments that were cemented and executed
     *
     * @return self
     */
    public function setExecutedCommitments($executed_commitments)
    {

        if (is_null($executed_commitments)) {
            throw new \InvalidArgumentException('non-nullable executed_commitments cannot be null');
        }

        $this->container['executed_commitments'] = $executed_commitments;

        return $this;
    }

    /**
     * Gets cemented_commitments
     *
     * @return int|null
     */
    public function getCementedCommitments()
    {
        return $this->container['cemented_commitments'];
    }

    /**
     * Sets cemented_commitments
     *
     * @param int|null $cemented_commitments Number of commitments that were cemented (including executed ones)
     *
     * @return self
     */
    public function setCementedCommitments($cemented_commitments)
    {

        if (is_null($cemented_commitments)) {
            throw new \InvalidArgumentException('non-nullable cemented_commitments cannot be null');
        }

        $this->container['cemented_commitments'] = $cemented_commitments;

        return $this;
    }

    /**
     * Gets pending_commitments
     *
     * @return int|null
     */
    public function getPendingCommitments()
    {
        return $this->container['pending_commitments'];
    }

    /**
     * Sets pending_commitments
     *
     * @param int|null $pending_commitments Number of pending commitments
     *
     * @return self
     */
    public function setPendingCommitments($pending_commitments)
    {

        if (is_null($pending_commitments)) {
            throw new \InvalidArgumentException('non-nullable pending_commitments cannot be null');
        }

        $this->container['pending_commitments'] = $pending_commitments;

        return $this;
    }

    /**
     * Gets refuted_commitments
     *
     * @return int|null
     */
    public function getRefutedCommitments()
    {
        return $this->container['refuted_commitments'];
    }

    /**
     * Sets refuted_commitments
     *
     * @param int|null $refuted_commitments Number of commitments that were refuted
     *
     * @return self
     */
    public function setRefutedCommitments($refuted_commitments)
    {

        if (is_null($refuted_commitments)) {
            throw new \InvalidArgumentException('non-nullable refuted_commitments cannot be null');
        }

        $this->container['refuted_commitments'] = $refuted_commitments;

        return $this;
    }

    /**
     * Gets orphan_commitments
     *
     * @return int|null
     */
    public function getOrphanCommitments()
    {
        return $this->container['orphan_commitments'];
    }

    /**
     * Sets orphan_commitments
     *
     * @param int|null $orphan_commitments Number of commitments that became orphan, due to their parent was refuted
     *
     * @return self
     */
    public function setOrphanCommitments($orphan_commitments)
    {

        if (is_null($orphan_commitments)) {
            throw new \InvalidArgumentException('non-nullable orphan_commitments cannot be null');
        }

        $this->container['orphan_commitments'] = $orphan_commitments;

        return $this;
    }

    /**
     * Gets smart_rollup_bonds
     *
     * @return int|null
     */
    public function getSmartRollupBonds()
    {
        return $this->container['smart_rollup_bonds'];
    }

    /**
     * Sets smart_rollup_bonds
     *
     * @param int|null $smart_rollup_bonds Amount of mutez locked as bonds
     *
     * @return self
     */
    public function setSmartRollupBonds($smart_rollup_bonds)
    {

        if (is_null($smart_rollup_bonds)) {
            throw new \InvalidArgumentException('non-nullable smart_rollup_bonds cannot be null');
        }

        $this->container['smart_rollup_bonds'] = $smart_rollup_bonds;

        return $this;
    }

    /**
     * Gets active_tokens_count
     *
     * @return int|null
     */
    public function getActiveTokensCount()
    {
        return $this->container['active_tokens_count'];
    }

    /**
     * Sets active_tokens_count
     *
     * @param int|null $active_tokens_count Number of account tokens with non-zero balances
     *
     * @return self
     */
    public function setActiveTokensCount($active_tokens_count)
    {

        if (is_null($active_tokens_count)) {
            throw new \InvalidArgumentException('non-nullable active_tokens_count cannot be null');
        }

        $this->container['active_tokens_count'] = $active_tokens_count;

        return $this;
    }

    /**
     * Gets token_balances_count
     *
     * @return int|null
     */
    public function getTokenBalancesCount()
    {
        return $this->container['token_balances_count'];
    }

    /**
     * Sets token_balances_count
     *
     * @param int|null $token_balances_count Number of tokens the account ever had
     *
     * @return self
     */
    public function setTokenBalancesCount($token_balances_count)
    {

        if (is_null($token_balances_count)) {
            throw new \InvalidArgumentException('non-nullable token_balances_count cannot be null');
        }

        $this->container['token_balances_count'] = $token_balances_count;

        return $this;
    }

    /**
     * Gets token_transfers_count
     *
     * @return int|null
     */
    public function getTokenTransfersCount()
    {
        return $this->container['token_transfers_count'];
    }

    /**
     * Sets token_transfers_count
     *
     * @param int|null $token_transfers_count Number of token transfers from/to the account
     *
     * @return self
     */
    public function setTokenTransfersCount($token_transfers_count)
    {

        if (is_null($token_transfers_count)) {
            throw new \InvalidArgumentException('non-nullable token_transfers_count cannot be null');
        }

        $this->container['token_transfers_count'] = $token_transfers_count;

        return $this;
    }

    /**
     * Gets num_transactions
     *
     * @return int|null
     */
    public function getNumTransactions()
    {
        return $this->container['num_transactions'];
    }

    /**
     * Sets num_transactions
     *
     * @param int|null $num_transactions Number of transaction operations related to the account
     *
     * @return self
     */
    public function setNumTransactions($num_transactions)
    {

        if (is_null($num_transactions)) {
            throw new \InvalidArgumentException('non-nullable num_transactions cannot be null');
        }

        $this->container['num_transactions'] = $num_transactions;

        return $this;
    }

    /**
     * Gets transfer_ticket_count
     *
     * @return int|null
     */
    public function getTransferTicketCount()
    {
        return $this->container['transfer_ticket_count'];
    }

    /**
     * Sets transfer_ticket_count
     *
     * @param int|null $transfer_ticket_count Number of transfer ticket operations related to the account
     *
     * @return self
     */
    public function setTransferTicketCount($transfer_ticket_count)
    {

        if (is_null($transfer_ticket_count)) {
            throw new \InvalidArgumentException('non-nullable transfer_ticket_count cannot be null');
        }

        $this->container['transfer_ticket_count'] = $transfer_ticket_count;

        return $this;
    }

    /**
     * Gets smart_rollup_cement_count
     *
     * @return int|null
     */
    public function getSmartRollupCementCount()
    {
        return $this->container['smart_rollup_cement_count'];
    }

    /**
     * Sets smart_rollup_cement_count
     *
     * @param int|null $smart_rollup_cement_count Number of `smart_rollup_cement` operations related to the account
     *
     * @return self
     */
    public function setSmartRollupCementCount($smart_rollup_cement_count)
    {

        if (is_null($smart_rollup_cement_count)) {
            throw new \InvalidArgumentException('non-nullable smart_rollup_cement_count cannot be null');
        }

        $this->container['smart_rollup_cement_count'] = $smart_rollup_cement_count;

        return $this;
    }

    /**
     * Gets smart_rollup_execute_count
     *
     * @return int|null
     */
    public function getSmartRollupExecuteCount()
    {
        return $this->container['smart_rollup_execute_count'];
    }

    /**
     * Sets smart_rollup_execute_count
     *
     * @param int|null $smart_rollup_execute_count Number of `smart_rollup_execute_outbox_message` operations related to the account
     *
     * @return self
     */
    public function setSmartRollupExecuteCount($smart_rollup_execute_count)
    {

        if (is_null($smart_rollup_execute_count)) {
            throw new \InvalidArgumentException('non-nullable smart_rollup_execute_count cannot be null');
        }

        $this->container['smart_rollup_execute_count'] = $smart_rollup_execute_count;

        return $this;
    }

    /**
     * Gets smart_rollup_originate_count
     *
     * @return int|null
     */
    public function getSmartRollupOriginateCount()
    {
        return $this->container['smart_rollup_originate_count'];
    }

    /**
     * Sets smart_rollup_originate_count
     *
     * @param int|null $smart_rollup_originate_count Number of `smart_rollup_originate` operations related to the account
     *
     * @return self
     */
    public function setSmartRollupOriginateCount($smart_rollup_originate_count)
    {

        if (is_null($smart_rollup_originate_count)) {
            throw new \InvalidArgumentException('non-nullable smart_rollup_originate_count cannot be null');
        }

        $this->container['smart_rollup_originate_count'] = $smart_rollup_originate_count;

        return $this;
    }

    /**
     * Gets smart_rollup_publish_count
     *
     * @return int|null
     */
    public function getSmartRollupPublishCount()
    {
        return $this->container['smart_rollup_publish_count'];
    }

    /**
     * Sets smart_rollup_publish_count
     *
     * @param int|null $smart_rollup_publish_count Number of `smart_rollup_publish` operations related to the account
     *
     * @return self
     */
    public function setSmartRollupPublishCount($smart_rollup_publish_count)
    {

        if (is_null($smart_rollup_publish_count)) {
            throw new \InvalidArgumentException('non-nullable smart_rollup_publish_count cannot be null');
        }

        $this->container['smart_rollup_publish_count'] = $smart_rollup_publish_count;

        return $this;
    }

    /**
     * Gets smart_rollup_recover_bond_count
     *
     * @return int|null
     */
    public function getSmartRollupRecoverBondCount()
    {
        return $this->container['smart_rollup_recover_bond_count'];
    }

    /**
     * Sets smart_rollup_recover_bond_count
     *
     * @param int|null $smart_rollup_recover_bond_count Number of `smart_rollup_recover_bond` operations related to the account
     *
     * @return self
     */
    public function setSmartRollupRecoverBondCount($smart_rollup_recover_bond_count)
    {

        if (is_null($smart_rollup_recover_bond_count)) {
            throw new \InvalidArgumentException('non-nullable smart_rollup_recover_bond_count cannot be null');
        }

        $this->container['smart_rollup_recover_bond_count'] = $smart_rollup_recover_bond_count;

        return $this;
    }

    /**
     * Gets smart_rollup_refute_count
     *
     * @return int|null
     */
    public function getSmartRollupRefuteCount()
    {
        return $this->container['smart_rollup_refute_count'];
    }

    /**
     * Sets smart_rollup_refute_count
     *
     * @param int|null $smart_rollup_refute_count Number of `smart_rollup_refute` operations related to the account
     *
     * @return self
     */
    public function setSmartRollupRefuteCount($smart_rollup_refute_count)
    {

        if (is_null($smart_rollup_refute_count)) {
            throw new \InvalidArgumentException('non-nullable smart_rollup_refute_count cannot be null');
        }

        $this->container['smart_rollup_refute_count'] = $smart_rollup_refute_count;

        return $this;
    }

    /**
     * Gets refutation_games_count
     *
     * @return int|null
     */
    public function getRefutationGamesCount()
    {
        return $this->container['refutation_games_count'];
    }

    /**
     * Sets refutation_games_count
     *
     * @param int|null $refutation_games_count Number of smart rollup refutation games related to the account
     *
     * @return self
     */
    public function setRefutationGamesCount($refutation_games_count)
    {

        if (is_null($refutation_games_count)) {
            throw new \InvalidArgumentException('non-nullable refutation_games_count cannot be null');
        }

        $this->container['refutation_games_count'] = $refutation_games_count;

        return $this;
    }

    /**
     * Gets active_refutation_games_count
     *
     * @return int|null
     */
    public function getActiveRefutationGamesCount()
    {
        return $this->container['active_refutation_games_count'];
    }

    /**
     * Sets active_refutation_games_count
     *
     * @param int|null $active_refutation_games_count Number of active smart rollup refutation games related to the account
     *
     * @return self
     */
    public function setActiveRefutationGamesCount($active_refutation_games_count)
    {

        if (is_null($active_refutation_games_count)) {
            throw new \InvalidArgumentException('non-nullable active_refutation_games_count cannot be null');
        }

        $this->container['active_refutation_games_count'] = $active_refutation_games_count;

        return $this;
    }

    /**
     * Gets first_activity
     *
     * @return int|null
     */
    public function getFirstActivity()
    {
        return $this->container['first_activity'];
    }

    /**
     * Sets first_activity
     *
     * @param int|null $first_activity Block height at which the ghost contract appeared first time
     *
     * @return self
     */
    public function setFirstActivity($first_activity)
    {

        if (is_null($first_activity)) {
            throw new \InvalidArgumentException('non-nullable first_activity cannot be null');
        }

        $this->container['first_activity'] = $first_activity;

        return $this;
    }

    /**
     * Gets first_activity_time
     *
     * @return \DateTime|null
     */
    public function getFirstActivityTime()
    {
        return $this->container['first_activity_time'];
    }

    /**
     * Sets first_activity_time
     *
     * @param \DateTime|null $first_activity_time Block datetime at which the ghost contract appeared first time (ISO 8601, e.g. `2020-02-20T02:40:57Z`)
     *
     * @return self
     */
    public function setFirstActivityTime($first_activity_time)
    {

        if (is_null($first_activity_time)) {
            throw new \InvalidArgumentException('non-nullable first_activity_time cannot be null');
        }

        $this->container['first_activity_time'] = $first_activity_time;

        return $this;
    }

    /**
     * Gets last_activity
     *
     * @return int|null
     */
    public function getLastActivity()
    {
        return $this->container['last_activity'];
    }

    /**
     * Sets last_activity
     *
     * @param int|null $last_activity Height of the block in which the ghost contract state was changed last time
     *
     * @return self
     */
    public function setLastActivity($last_activity)
    {

        if (is_null($last_activity)) {
            throw new \InvalidArgumentException('non-nullable last_activity cannot be null');
        }

        $this->container['last_activity'] = $last_activity;

        return $this;
    }

    /**
     * Gets last_activity_time
     *
     * @return \DateTime|null
     */
    public function getLastActivityTime()
    {
        return $this->container['last_activity_time'];
    }

    /**
     * Sets last_activity_time
     *
     * @param \DateTime|null $last_activity_time Datetime of the block in which the ghost contract state was changed last time (ISO 8601, e.g. `2020-02-20T02:40:57Z`)
     *
     * @return self
     */
    public function setLastActivityTime($last_activity_time)
    {

        if (is_null($last_activity_time)) {
            throw new \InvalidArgumentException('non-nullable last_activity_time cannot be null');
        }

        $this->container['last_activity_time'] = $last_activity_time;

        return $this;
    }

    /**
     * Gets extras
     *
     * @return mixed|null
     */
    public function getExtras()
    {
        return $this->container['extras'];
    }

    /**
     * Sets extras
     *
     * @param mixed|null $extras Off-chain extras
     *
     * @return self
     */
    public function setExtras($extras)
    {

        if (is_null($extras)) {
            array_push($this->openAPINullablesSetToNull, 'extras');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('extras', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['extras'] = $extras;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


